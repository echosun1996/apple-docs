{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"apple\u6587\u6863\u7ffb\u8bd1\u8ba1\u5212 \u76ee\u524d\u4e3b\u8981\u9488\u5bf9apple\u6587\u6863\u4e2d\u7684Swift\u548cSwiftUI\u4e24\u90e8\u5206\u8fdb\u884c\u7ffb\u8bd1\u3002 \u5bf9\u6bcf\u4e00\u6761\u7684\u7ffb\u8bd1\u90fd\u9644\u5e26\u4e86\u539f\u6587\uff0c\u53ef\u4ee5\u901a\u8fc7\u641c\u7d22\u529f\u80fd\u5feb\u901f\u5b9a\u4f4d\u5230\u8981\u67e5\u8be2\u7684\u4f4d\u7f6e\u3002 \u5c5e\u4e8e\u4e00\u8fb9\u5b66\u4e60\u4e00\u8fb9\u7ffb\u8bd1\u7684\u72b6\u6001\uff0c\u5982\u679c\u6709\u5174\u8da3\u4e00\u8d77\u5b66\u4e60\uff0c\u6b22\u8fcePR\u3002","title":"apple\u6587\u6863\u7ffb\u8bd1\u8ba1\u5212"},{"location":"#apple","text":"\u76ee\u524d\u4e3b\u8981\u9488\u5bf9apple\u6587\u6863\u4e2d\u7684Swift\u548cSwiftUI\u4e24\u90e8\u5206\u8fdb\u884c\u7ffb\u8bd1\u3002 \u5bf9\u6bcf\u4e00\u6761\u7684\u7ffb\u8bd1\u90fd\u9644\u5e26\u4e86\u539f\u6587\uff0c\u53ef\u4ee5\u901a\u8fc7\u641c\u7d22\u529f\u80fd\u5feb\u901f\u5b9a\u4f4d\u5230\u8981\u67e5\u8be2\u7684\u4f4d\u7f6e\u3002 \u5c5e\u4e8e\u4e00\u8fb9\u5b66\u4e60\u4e00\u8fb9\u7ffb\u8bd1\u7684\u72b6\u6001\uff0c\u5982\u679c\u6709\u5174\u8da3\u4e00\u8d77\u5b66\u4e60\uff0c\u6b22\u8fcePR\u3002","title":"apple\u6587\u6863\u7ffb\u8bd1\u8ba1\u5212"},{"location":"instruction/","text":"\u8bf4\u660e \u672c\u6587\u6863\u4f7f\u7528 Mkdocs \u6784\u5efa\u3002\u66f4\u591a\u5185\u5bb9\u8be6\u89c1\uff1a mkdocs.org \u3002 Mkdocs \u5e38\u7528\u547d\u4ee4 mkdocs new [dir-name] \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6587\u6863\u5de5\u7a0b mkdocs serve \u547d\u4ee4\u53ef\u4ee5\u542f\u52a8\u5185\u5efa\u670d\u52a1\u5668\uff0c\u6267\u884c\u6210\u529f\u540e\uff0c\u5728\u6d4f\u89c8\u5668\u6253\u5f00 http://127.0.0.1:8000/ \u5373\u53ef\u9884\u89c8\u3002 mkdocs build \u5c06\u6587\u6863\u4ee5\u7f51\u9875\u5f62\u5f0f\u6784\u5efa\u5230 site\\ \u6587\u4ef6\u5939\u4e0b mkdocs -h \u8f93\u51fa\u5e2e\u52a9\u4fe1\u606f Mkdocs \u76ee\u5f55\u7ed3\u6784 apple-docs \u6587\u4ef6\u5939\u4e2d\u6bcf\u4e2a\u6587\u4ef6\u7684\u4f5c\u7528\uff1a mkdocs.yml \u6b64\u4e3a\u914d\u7f6e\u6587\u4ef6\uff0c\u6587\u6863\u7684\u7ed3\u6784\u3001\u4e3b\u9898\u90fd\u53ef\u4ee5\u5728\u6b64\u8bbe\u7f6e\u3002 docs\u6587\u4ef6\u5939 \u64b0\u5199\u7684 Markdown \u6587\u6863\u90fd\u653e\u5728\u8fd9\u4e2a\u6587\u4ef6\u5939\u5185\u3002 index.md \u9ed8\u8ba4\u9996\u9875\u3002 Mkdocs \u4e3b\u9898 MkDocs \u9879\u76ee\u6258\u7ba1\u5728 github \u4e0a\uff0c\u5728\u9879\u76ee\u7684 community wiki \u4e2d\uff0c\u63d0\u4f9b\u4e86\u5927\u91cf\u7684 \u7b2c\u4e09\u65b9\u4e3b\u9898 \u3002 mkdocs-material mkdocs-material \u53ef\u5b9a\u5236\u3001\u53ef\u641c\u7d22\u3001\u79fb\u52a8\u53cb\u597d\u3001\u652f\u630140\u591a\u79cd\u8bed\u8a00\u7684\u7ffb\u8bd1 mkdocs-material\u7684\u5b89\u88c5\u548c\u4f7f\u7528 pip install mkdocs-material \u5728 mkdocs.yml \u4e2d\u914d\u7f6e\uff1a theme: name: material rtd-dropdown \u540d\u79f0\u4e3a rtd-dropdown \u7684\u4e3b\u9898\u975e\u5e38\u597d\u7528\uff0c\u662f\u5185\u7f6e\u4e3b\u9898 readthedocs \u7684\u5347\u7ea7\u7248\uff0c\u76f8\u6bd4\u4e8e\u4e4b\u524d\u7684\u7248\u672c\uff0c\u5347\u7ea7\u7248\u7684\u4e3b\u9898\u6709\u4ee5\u4e0b\u51e0\u4e2a\u4f18\u70b9\uff1a \u652f\u6301\u83dc\u5355\u76ee\u5f55\u6298\u53e0\u3002\u70b9\u51fb + \u53ef\u4ee5\u5c55\u5f00\uff0c\u5c55\u5f00\u540e\u4f1a\u663e\u793a\u4e0b\u4e00\u7ea7\u7684\u6240\u6709\u6807\u9898\uff0c\u5982\u679c\u8fd8\u6709\u4e0b\u4e00\u7ea7\u6807\u9898\u4e2d\u8fd8\u6709\u5b50\u6807\u9898\uff0c\u5219\u4f1a\u5d4c\u5957\u663e\u793a + \u3002 rtd-dropdown \u4e3b\u9898\u53d6\u6d88\u4e86\u5b50\u76ee\u5f55\u7684\u7f29\u8fdb\uff0c\u9632\u6b62\u76ee\u5f55\u7ea7\u522b\u8fc7\u591a\u800c\u5bfc\u81f4\u6392\u7248\u51fa\u73b0\u95ee\u9898\u3002 \u5bf9\u5e94\u7684 markdown \u6587\u6863\u53ea\u5b58\u5728\u4e00\u4e2a\u4e00\u7ea7\u6807\u9898\u7684\u60c5\u51b5\u4e0b\uff0c\u5c06\u4e0d\u4e88\u663e\u793a\u5728\u5bfc\u822a\u76ee\u5f55\u4e2d\u3002 \u7136\u800c\uff0c\u67d0\u4e9b\u65f6\u5019\u5c55\u5f00\u76ee\u5f55\u65f6\uff0c + \u4f1a\u8986\u76d6\u6587\u5b57\uff0c\u4e0d\u7f8e\u89c2\u3002 rtd-dropdown\u7684\u5b89\u88c5\u548c\u4f7f\u7528 pip install mkdocs-rtd-dropdown \u5728 mkdocs.yml \u4e2d\u914d\u7f6e\uff1a theme: rtd-dropdown","title":"\u8bf4\u660e"},{"location":"instruction/#_1","text":"\u672c\u6587\u6863\u4f7f\u7528 Mkdocs \u6784\u5efa\u3002\u66f4\u591a\u5185\u5bb9\u8be6\u89c1\uff1a mkdocs.org \u3002","title":"\u8bf4\u660e"},{"location":"instruction/#mkdocs","text":"mkdocs new [dir-name] \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6587\u6863\u5de5\u7a0b mkdocs serve \u547d\u4ee4\u53ef\u4ee5\u542f\u52a8\u5185\u5efa\u670d\u52a1\u5668\uff0c\u6267\u884c\u6210\u529f\u540e\uff0c\u5728\u6d4f\u89c8\u5668\u6253\u5f00 http://127.0.0.1:8000/ \u5373\u53ef\u9884\u89c8\u3002 mkdocs build \u5c06\u6587\u6863\u4ee5\u7f51\u9875\u5f62\u5f0f\u6784\u5efa\u5230 site\\ \u6587\u4ef6\u5939\u4e0b mkdocs -h \u8f93\u51fa\u5e2e\u52a9\u4fe1\u606f","title":"Mkdocs \u5e38\u7528\u547d\u4ee4"},{"location":"instruction/#mkdocs_1","text":"apple-docs \u6587\u4ef6\u5939\u4e2d\u6bcf\u4e2a\u6587\u4ef6\u7684\u4f5c\u7528\uff1a mkdocs.yml \u6b64\u4e3a\u914d\u7f6e\u6587\u4ef6\uff0c\u6587\u6863\u7684\u7ed3\u6784\u3001\u4e3b\u9898\u90fd\u53ef\u4ee5\u5728\u6b64\u8bbe\u7f6e\u3002 docs\u6587\u4ef6\u5939 \u64b0\u5199\u7684 Markdown \u6587\u6863\u90fd\u653e\u5728\u8fd9\u4e2a\u6587\u4ef6\u5939\u5185\u3002 index.md \u9ed8\u8ba4\u9996\u9875\u3002","title":"Mkdocs \u76ee\u5f55\u7ed3\u6784"},{"location":"instruction/#mkdocs_2","text":"MkDocs \u9879\u76ee\u6258\u7ba1\u5728 github \u4e0a\uff0c\u5728\u9879\u76ee\u7684 community wiki \u4e2d\uff0c\u63d0\u4f9b\u4e86\u5927\u91cf\u7684 \u7b2c\u4e09\u65b9\u4e3b\u9898 \u3002","title":"Mkdocs \u4e3b\u9898"},{"location":"instruction/#mkdocs-material","text":"mkdocs-material \u53ef\u5b9a\u5236\u3001\u53ef\u641c\u7d22\u3001\u79fb\u52a8\u53cb\u597d\u3001\u652f\u630140\u591a\u79cd\u8bed\u8a00\u7684\u7ffb\u8bd1","title":"mkdocs-material"},{"location":"instruction/#mkdocs-material_1","text":"pip install mkdocs-material \u5728 mkdocs.yml \u4e2d\u914d\u7f6e\uff1a theme: name: material","title":"mkdocs-material\u7684\u5b89\u88c5\u548c\u4f7f\u7528"},{"location":"instruction/#rtd-dropdown","text":"\u540d\u79f0\u4e3a rtd-dropdown \u7684\u4e3b\u9898\u975e\u5e38\u597d\u7528\uff0c\u662f\u5185\u7f6e\u4e3b\u9898 readthedocs \u7684\u5347\u7ea7\u7248\uff0c\u76f8\u6bd4\u4e8e\u4e4b\u524d\u7684\u7248\u672c\uff0c\u5347\u7ea7\u7248\u7684\u4e3b\u9898\u6709\u4ee5\u4e0b\u51e0\u4e2a\u4f18\u70b9\uff1a \u652f\u6301\u83dc\u5355\u76ee\u5f55\u6298\u53e0\u3002\u70b9\u51fb + \u53ef\u4ee5\u5c55\u5f00\uff0c\u5c55\u5f00\u540e\u4f1a\u663e\u793a\u4e0b\u4e00\u7ea7\u7684\u6240\u6709\u6807\u9898\uff0c\u5982\u679c\u8fd8\u6709\u4e0b\u4e00\u7ea7\u6807\u9898\u4e2d\u8fd8\u6709\u5b50\u6807\u9898\uff0c\u5219\u4f1a\u5d4c\u5957\u663e\u793a + \u3002 rtd-dropdown \u4e3b\u9898\u53d6\u6d88\u4e86\u5b50\u76ee\u5f55\u7684\u7f29\u8fdb\uff0c\u9632\u6b62\u76ee\u5f55\u7ea7\u522b\u8fc7\u591a\u800c\u5bfc\u81f4\u6392\u7248\u51fa\u73b0\u95ee\u9898\u3002 \u5bf9\u5e94\u7684 markdown \u6587\u6863\u53ea\u5b58\u5728\u4e00\u4e2a\u4e00\u7ea7\u6807\u9898\u7684\u60c5\u51b5\u4e0b\uff0c\u5c06\u4e0d\u4e88\u663e\u793a\u5728\u5bfc\u822a\u76ee\u5f55\u4e2d\u3002 \u7136\u800c\uff0c\u67d0\u4e9b\u65f6\u5019\u5c55\u5f00\u76ee\u5f55\u65f6\uff0c + \u4f1a\u8986\u76d6\u6587\u5b57\uff0c\u4e0d\u7f8e\u89c2\u3002","title":"rtd-dropdown"},{"location":"instruction/#rtd-dropdown_1","text":"pip install mkdocs-rtd-dropdown \u5728 mkdocs.yml \u4e2d\u914d\u7f6e\uff1a theme: rtd-dropdown","title":"rtd-dropdown\u7684\u5b89\u88c5\u548c\u4f7f\u7528"},{"location":"Swift/0.swift%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/","text":"swift\u6587\u6863\u8bf4\u660e Swift\u5305\u542b\u4e86\u8bb8\u591a\u73b0\u4ee3\u4ee3\u7801\u7684\u7279\u6027\uff0c\u5982\u7c7b\u578b\u63a8\u65ad\u3001\u53ef\u9009\u9879\u548c\u95ed\u5305\uff0c\u8fd9\u4f7f\u5f97\u8bed\u6cd5\u7b80\u6d01\u800c\u5bcc\u6709\u8868\u73b0\u529b\u3002Swift\u786e\u4fdd\u4f60\u7684\u4ee3\u7801\u5feb\u901f\u9ad8\u6548\uff0c\u540c\u65f6\u5b83\u7684\u5185\u5b58\u5b89\u5168\u548c\u672c\u5730\u9519\u8bef\u5904\u7406\u4f7f\u8bed\u8a00\u8bbe\u8ba1\u5b89\u5168\u3002\u5728Swift Playgrounds\u3001Xcode\u4e2d\u7684playgrounds\u548cREPL\u4e2d\u53ef\u4ee5\u4ea4\u4e92\u5f0f\u7684\u7f16\u5199Swift\u4ee3\u7801\u3002 Swift includes modern features like type inference, optionals, and closures, which make the syntax concise yet expressive. Swift ensures your code is fast and efficient, while its memory safety and native error handling make the language safe by design. Writing Swift code is interactive and fun in Swift Playgrounds, playgrounds in Xcode, and REPL. \u76ee\u5f55\u7ed3\u6784 StandardLibrary \u6807\u51c6\u5e93 DataModeling \u6570\u636e\u6a21\u578b DataFlowAndControlFlow \u6570\u636e\u6d41\u548c\u63a7\u5236\u6d41 LanguageInteroperability \u6570\u636e\u4e92\u901a","title":"swift\u6587\u6863\u8bf4\u660e"},{"location":"Swift/0.swift%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/#swift","text":"Swift\u5305\u542b\u4e86\u8bb8\u591a\u73b0\u4ee3\u4ee3\u7801\u7684\u7279\u6027\uff0c\u5982\u7c7b\u578b\u63a8\u65ad\u3001\u53ef\u9009\u9879\u548c\u95ed\u5305\uff0c\u8fd9\u4f7f\u5f97\u8bed\u6cd5\u7b80\u6d01\u800c\u5bcc\u6709\u8868\u73b0\u529b\u3002Swift\u786e\u4fdd\u4f60\u7684\u4ee3\u7801\u5feb\u901f\u9ad8\u6548\uff0c\u540c\u65f6\u5b83\u7684\u5185\u5b58\u5b89\u5168\u548c\u672c\u5730\u9519\u8bef\u5904\u7406\u4f7f\u8bed\u8a00\u8bbe\u8ba1\u5b89\u5168\u3002\u5728Swift Playgrounds\u3001Xcode\u4e2d\u7684playgrounds\u548cREPL\u4e2d\u53ef\u4ee5\u4ea4\u4e92\u5f0f\u7684\u7f16\u5199Swift\u4ee3\u7801\u3002 Swift includes modern features like type inference, optionals, and closures, which make the syntax concise yet expressive. Swift ensures your code is fast and efficient, while its memory safety and native error handling make the language safe by design. Writing Swift code is interactive and fun in Swift Playgrounds, playgrounds in Xcode, and REPL.","title":"swift\u6587\u6863\u8bf4\u660e"},{"location":"Swift/0.swift%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/#_1","text":"StandardLibrary \u6807\u51c6\u5e93 DataModeling \u6570\u636e\u6a21\u578b DataFlowAndControlFlow \u6570\u636e\u6d41\u548c\u63a7\u5236\u6d41 LanguageInteroperability \u6570\u636e\u4e92\u901a","title":"\u76ee\u5f55\u7ed3\u6784"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/1.%E6%95%B4%E6%95%B0-Int/1.%E6%95%B4%E6%95%B0-Int/","text":"1.\u6574\u6570-Int \u6709\u7b26\u53f7\u6574\u6570 A signed integer value type. \u8bf4\u660e-Declaration @frozen struct Int \u6982\u8ff0-Overview \u572832\u4f4d\u5e73\u53f0\u4e0a\uff0c Int \u7684\u5927\u5c0f\u7b49\u4e8e Int32 \u7684\u5927\u5c0f\u3002\u800c\u572864\u4f4d\u5e73\u53f0\u4e0a Int \u7684\u5927\u5c0f\u7b49\u4e8e Int64 \u7684\u5927\u5c0f\u3002 On 32-bit platforms, Int is the same size as Int32 , and on 64-bit platforms, Int is the same size as Int64 .","title":"1.\u6574\u6570-Int"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/1.%E6%95%B4%E6%95%B0-Int/1.%E6%95%B4%E6%95%B0-Int/#1-int","text":"\u6709\u7b26\u53f7\u6574\u6570 A signed integer value type. \u8bf4\u660e-Declaration @frozen struct Int \u6982\u8ff0-Overview \u572832\u4f4d\u5e73\u53f0\u4e0a\uff0c Int \u7684\u5927\u5c0f\u7b49\u4e8e Int32 \u7684\u5927\u5c0f\u3002\u800c\u572864\u4f4d\u5e73\u53f0\u4e0a Int \u7684\u5927\u5c0f\u7b49\u4e8e Int64 \u7684\u5927\u5c0f\u3002 On 32-bit platforms, Int is the same size as Int32 , and on 64-bit platforms, Int is the same size as Int64 .","title":"1.\u6574\u6570-Int"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/2.%E6%B5%AE%E7%82%B9%E6%95%B0-Double/2.%E6%B5%AE%E7%82%B9%E6%95%B0-Double/","text":"\u6d6e\u70b9\u6570-Double \u53cc\u7cbe\u5ea6\u7684\u6d6e\u70b9\u7c7b\u578b A double-precision, floating-point value type. \u8bf4\u660e-Declaration @frozen struct Double","title":"\u6d6e\u70b9\u6570-Double"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/2.%E6%B5%AE%E7%82%B9%E6%95%B0-Double/2.%E6%B5%AE%E7%82%B9%E6%95%B0-Double/#-double","text":"\u53cc\u7cbe\u5ea6\u7684\u6d6e\u70b9\u7c7b\u578b A double-precision, floating-point value type. \u8bf4\u660e-Declaration @frozen struct Double","title":"\u6d6e\u70b9\u6570-Double"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/","text":"\u5b57\u7b26\u4e32-String \u7531\u5b57\u7b26\u96c6\u7ec4\u6210\u7684Unicode\u5b57\u7b26\u4e32\u503c\u3002 A Unicode string value that is a collection of characters. \u8bf4\u660e-Declaration @frozen struct String \u6982\u8ff0-Overview \u5b57\u7b26\u4e32\u7531\u4e00\u7cfb\u5217\u50cf \"Swift\" \u8fd9\u6837\u7684\u5b57\u7b26\u7ec4\u6210\u7684\u51e0\u4f55\u3002Swift\u4e2d\u5b57\u7b26\u4e32\u7684\u8bbe\u8ba1\u5f88\u9ad8\u6548\uff0c\u5b83\u652f\u6301Unicode\u7f16\u7801\uff0c\u56e0\u6b64\u4e0d\u53d7\u5730\u57df\u6587\u5b57\u5dee\u5f02\u7684\u9650\u5236\u3002 String \u7c7b\u578b\u6865\u63a5\u4e86Objective-C \u8bed\u8a00\u4e2d\u7684 NSString \uff0c\u5e76\u4e14\u80fd\u591f\u7528\u5b57\u7b26\u4e32\u4e0eC\u8bed\u8a00\u51fd\u6570\u7684\u76f8\u4e92\u64cd\u4f5c\u3002 \u4f60\u53ef\u4ee5\u4f7f\u7528\u201c\u5b57\u7b26\u4e32\u5b57\u9762\u91cf\u201d(string literals)\u6216\u201c\u5b57\u7b26\u4e32\u63d2\u503c\u201d(string interpolation)\u6765\u521b\u5efa\u65b0\u7684\u5b57\u7b26\u4e32\u3002\u4e00\u4e2a \u5b57\u7b26\u4e32\u5b57\u9762\u91cf \u662f\u4e00\u4e9b\u7528\u5f15\u53f7\u62ec\u8d77\u6765\u7684\u5b57\u7b26\u3002 A string is a series of characters, such as \"Swift\" , that forms a collection. Strings in Swift are Unicode correct and locale insensitive, and are designed to be efficient. The String type bridges with the Objective-C class NSString and offers interoperability with C functions that works with strings. You can create new strings using string literals or string interpolations. A string literal is a series of characters enclosed in quotes. let greeting = \"Welcome!\" \u5b57\u7b26\u4e32\u63d2\u503c \u662f\u5b57\u7b26\u4e32\u5b57\u5143\uff0c\u5b83\u53ef\u4ee5\u8bc4\u4f30\u4efb\u4f55\u5305\u542b\u7684\u8868\u8fbe\u5f0f\u5e76\u5c06\u7ed3\u679c\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u5f62\u5f0f\u3002\u5b57\u7b26\u4e32\u63d2\u503c\u4e3a\u4f60\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\u65b9\u6cd5\u6765\u4ece\u591a\u4e2a\u7247\u6bb5\u4e2d\u5efa\u7acb\u4e00\u4e2a\u5b57\u7b26\u4e32\u3002\u5728\u5b57\u7b26\u4e32\u63d2\u503c\u4e2d\uff0c\u7528\u62ec\u53f7\u5c06\u6bcf\u4e2a\u8868\u8fbe\u5f0f\u5305\u88f9\u8d77\u6765\uff0c\u5e76\u5728\u62ec\u53f7\u524d\u52a0\u53cd\u659c\u6760\u3002 String interpolations are string literals that evaluate any included expressions and convert the results to string form. String interpolations give you an easy way to build a string from multiple pieces. Wrap each expression in a string interpolation in parentheses, prefixed by a backslash. let name = \"Rosa\" let personalizedGreeting = \"Welcome, \\\\(name)!\" // personalizedGreeting == \"Welcome, Rosa!\" let price = 2 let number = 3 let cookiePrice = \"\\\\(number) cookies: $\\\\(price * number).\" // cookiePrice == \"3 cookies: $6.\" let longerGreeting = greeting + \" We're glad you're here!\" // longerGreeting == \"Welcome! We're glad you're here!\" Multiline string literals are enclosed in three double quotation marks (\"\"\"), with each delimiter on its own line. Indentation is stripped from each line of a multiline string literal to match the indentation of the closing delimiter. let banner = \"\"\" __, ( o /) _/_ `. , , , , // / (___)(_(_/_(_ //_ (__ /) (/ \"\"\" Modifying and Comparing Strings Strings always have value semantics. Modifying a copy of a string leaves the original unaffected. var otherGreeting = greeting otherGreeting += \" Have a nice time!\" // otherGreeting == \"Welcome! Have a nice time!\" print(greeting) // Prints \"Welcome!\" Comparing strings for equality using the equal-to operator (==) or a relational operator (like < or >=) is always performed using Unicode canonical representation. As a result, different representations of a string compare as being equal. let cafe1 = \"Cafe\\u{301}\" let cafe2 = \"Caf\u00e9\" print(cafe1 == cafe2) // Prints \"true\" The Unicode scalar value \"\\u{301}\" modifies the preceding character to include an accent, so \"e\\u{301}\" has the same canonical representation as the single Unicode scalar value \"\u00e9\". Basic string operations are not sensitive to locale settings, ensuring that string comparisons and other operations always have a single, stable result, allowing strings to be used as keys in Dictionary instances and for other purposes. Accessing String Elements A string is a collection of extended grapheme clusters, which approximate human-readable characters. Many individual characters, such as \u201c\u00e9\u201d, \u201c\uae40\u201d, and \u201c\ud83c\uddee\ud83c\uddf3\u201d, can be made up of multiple Unicode scalar values. These scalar values are combined by Unicode\u2019s boundary algorithms into extended grapheme clusters, represented by the Swift Character type. Each element of a string is represented by a Character instance. For example, to retrieve the first word of a longer string, you can search for a space and then create a substring from a prefix of the string up to that point: let name = \"Marie Curie\" let firstSpace = name.firstIndex(of: \" \") ?? name.endIndex let firstName = name[..<firstSpace] // firstName == \"Marie\" The firstName constant is an instance of the Substring type\u2014a type that represents substrings of a string while sharing the original string\u2019s storage. Substrings present the same interface as strings. print(\"\\(name)'s first name has \\(firstName.count) letters.\") // Prints \"Marie Curie's first name has 5 letters.\" Accessing a String\u2019s Unicode Representation If you need to access the contents of a string as encoded in different Unicode encodings, use one of the string\u2019s unicodeScalars, utf16, or utf8 properties. Each property provides access to a view of the string as a series of code units, each encoded in a different Unicode encoding. To demonstrate the different views available for every string, the following examples use this String instance: let cafe = \"Cafe\\u{301} du \ud83c\udf0d\" print(cafe) // Prints \"Caf\u00e9 du \ud83c\udf0d\" The cafe string is a collection of the nine characters that are visible when the string is displayed. print(cafe.count) // Prints \"9\" print(Array(cafe)) // Prints \"[\"C\", \"a\", \"f\", \"\u00e9\", \" \", \"d\", \"u\", \" \", \"\ud83c\udf0d\"]\" Unicode Scalar View A string\u2019s unicodeScalars property is a collection of Unicode scalar values, the 21-bit codes that are the basic unit of Unicode. Each scalar value is represented by a Unicode.Scalar instance and is equivalent to a UTF-32 code unit. print(cafe.unicodeScalars.count) // Prints \"10\" print(Array(cafe.unicodeScalars)) // Prints \"[\"C\", \"a\", \"f\", \"e\", \"\\u{0301}\", \" \", \"d\", \"u\", \" \", \"\\u{0001F30D}\"]\" print(cafe.unicodeScalars.map { $0.value }) // Prints \"[67, 97, 102, 101, 769, 32, 100, 117, 32, 127757]\" The unicodeScalars view\u2019s elements comprise each Unicode scalar value in the cafe string. In particular, because cafe was declared using the decomposed form of the \"\u00e9\" character, unicodeScalars contains the scalar values for both the letter \"e\" (101) and the accent character \"\u00b4\" (769). UTF-16 View A string\u2019s utf16 property is a collection of UTF-16 code units, the 16-bit encoding form of the string\u2019s Unicode scalar values. Each code unit is stored as a UInt16 instance. print(cafe.utf16.count) // Prints \"11\" print(Array(cafe.utf16)) // Prints \"[67, 97, 102, 101, 769, 32, 100, 117, 32, 55356, 57101]\" The elements of the utf16 view are the code units for the string when encoded in UTF-16. These elements match those accessed through indexed NSString APIs. let nscafe = cafe as NSString print(nscafe.length) // Prints \"11\" print(nscafe.character(at: 3)) // Prints \"101\" UTF-8 View A string\u2019s utf8 property is a collection of UTF-8 code units, the 8-bit encoding form of the string\u2019s Unicode scalar values. Each code unit is stored as a UInt8 instance. print(cafe.utf8.count) // Prints \"14\" print(Array(cafe.utf8)) // Prints \"[67, 97, 102, 101, 204, 129, 32, 100, 117, 32, 240, 159, 140, 141]\" The elements of the utf8 view are the code units for the string when encoded in UTF-8. This representation matches the one used when String instances are passed to C APIs. let cLength = strlen(cafe) print(cLength) // Prints \"14\" Measuring the Length of a String When you need to know the length of a string, you must first consider what you\u2019ll use the length for. Are you measuring the number of characters that will be displayed on the screen, or are you measuring the amount of storage needed for the string in a particular encoding? A single string can have greatly differing lengths when measured by its different views. For example, an ASCII character like the capital letter A is represented by a single element in each of its four views. The Unicode scalar value of A is 65, which is small enough to fit in a single code unit in both UTF-16 and UTF-8. let capitalA = \"A\" print(capitalA.count) // Prints \"1\" print(capitalA.unicodeScalars.count) // Prints \"1\" print(capitalA.utf16.count) // Prints \"1\" print(capitalA.utf8.count) // Prints \"1\" On the other hand, an emoji flag character is constructed from a pair of Unicode scalar values, like \"\\u{1F1F5}\" and \"\\u{1F1F7}\". Each of these scalar values, in turn, is too large to fit into a single UTF-16 or UTF-8 code unit. As a result, each view of the string \"\ud83c\uddf5\ud83c\uddf7\" reports a different length. let flag = \"\ud83c\uddf5\ud83c\uddf7\" print(flag.count) // Prints \"1\" print(flag.unicodeScalars.count) // Prints \"2\" print(flag.utf16.count) // Prints \"4\" print(flag.utf8.count) // Prints \"8\" To check whether a string is empty, use its isEmpty property instead of comparing the length of one of the views to 0. Unlike with isEmpty, calculating a view\u2019s count property requires iterating through the elements of the string. Accessing String View Elements To find individual elements of a string, use the appropriate view for your task. For example, to retrieve the first word of a longer string, you can search the string for a space and then create a new string from a prefix of the string up to that point. let name = \"Marie Curie\" let firstSpace = name.firstIndex(of: \" \") ?? name.endIndex let firstName = name[..<firstSpace] print(firstName) // Prints \"Marie\" Strings and their views share indices, so you can access the UTF-8 view of the name string using the same firstSpace index. print(Array(name.utf8[..<firstSpace])) // Prints \"[77, 97, 114, 105, 101]\" Note that an index into one view may not have an exact corresponding position in another view. For example, the flag string declared above comprises a single character, but is composed of eight code units when encoded as UTF-8. The following code creates constants for the first and second positions in the flag.utf8 view. Accessing the utf8 view with these indices yields the first and second code UTF-8 units. let firstCodeUnit = flag.startIndex let secondCodeUnit = flag.utf8.index(after: firstCodeUnit) // flag.utf8[firstCodeUnit] == 240 // flag.utf8[secondCodeUnit] == 159 When used to access the elements of the flag string itself, however, the secondCodeUnit index does not correspond to the position of a specific character. Instead of only accessing the specific UTF-8 code unit, that index is treated as the position of the character at the index\u2019s encoded offset. In the case of secondCodeUnit, that character is still the flag itself. // flag[firstCodeUnit] == \"\ud83c\uddf5\ud83c\uddf7\" // flag[secondCodeUnit] == \"\ud83c\uddf5\ud83c\uddf7\" If you need to validate that an index from one string\u2019s view corresponds with an exact position in another view, use the index\u2019s samePosition(in:) method or the init(_:within:) initializer. if let exactIndex = secondCodeUnit.samePosition(in: flag) { print(flag[exactIndex]) } else { print(\"No exact match for this position.\") } // Prints \"No exact match for this position.\" Performance Optimizations Although strings in Swift have value semantics, strings use a copy-on-write strategy to store their data in a buffer. This buffer can then be shared by different copies of a string. A string\u2019s data is only copied lazily, upon mutation, when more than one string instance is using the same buffer. Therefore, the first in any sequence of mutating operations may cost O(n) time and space. When a string\u2019s contiguous storage fills up, a new buffer must be allocated and data must be moved to the new storage. String buffers use an exponential growth strategy that makes appending to a string a constant time operation when averaged over many append operations. Bridging Between String and NSString Any String instance can be bridged to NSString using the type-cast operator (as), and any String instance that originates in Objective-C may use an NSString instance as its storage. Because any arbitrary subclass of NSString can become a String instance, there are no guarantees about representation or efficiency when a String instance is backed by NSString storage. Because NSString is immutable, it is just as though the storage was shared by a copy. The first in any sequence of mutating operations causes elements to be copied into unique, contiguous storage which may cost O(n) time and space, where n is the length of the string\u2019s encoded representation (or more, if the underlying NSString has unusual performance characteristics). For more information about the Unicode terms used in this discussion, see the Unicode.org glossary. In particular, this discussion mentions extended grapheme clusters, Unicode scalar values, and canonical equivalence.","title":"\u5b57\u7b26\u4e32-String"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/#-string","text":"\u7531\u5b57\u7b26\u96c6\u7ec4\u6210\u7684Unicode\u5b57\u7b26\u4e32\u503c\u3002 A Unicode string value that is a collection of characters. \u8bf4\u660e-Declaration @frozen struct String \u6982\u8ff0-Overview \u5b57\u7b26\u4e32\u7531\u4e00\u7cfb\u5217\u50cf \"Swift\" \u8fd9\u6837\u7684\u5b57\u7b26\u7ec4\u6210\u7684\u51e0\u4f55\u3002Swift\u4e2d\u5b57\u7b26\u4e32\u7684\u8bbe\u8ba1\u5f88\u9ad8\u6548\uff0c\u5b83\u652f\u6301Unicode\u7f16\u7801\uff0c\u56e0\u6b64\u4e0d\u53d7\u5730\u57df\u6587\u5b57\u5dee\u5f02\u7684\u9650\u5236\u3002 String \u7c7b\u578b\u6865\u63a5\u4e86Objective-C \u8bed\u8a00\u4e2d\u7684 NSString \uff0c\u5e76\u4e14\u80fd\u591f\u7528\u5b57\u7b26\u4e32\u4e0eC\u8bed\u8a00\u51fd\u6570\u7684\u76f8\u4e92\u64cd\u4f5c\u3002 \u4f60\u53ef\u4ee5\u4f7f\u7528\u201c\u5b57\u7b26\u4e32\u5b57\u9762\u91cf\u201d(string literals)\u6216\u201c\u5b57\u7b26\u4e32\u63d2\u503c\u201d(string interpolation)\u6765\u521b\u5efa\u65b0\u7684\u5b57\u7b26\u4e32\u3002\u4e00\u4e2a \u5b57\u7b26\u4e32\u5b57\u9762\u91cf \u662f\u4e00\u4e9b\u7528\u5f15\u53f7\u62ec\u8d77\u6765\u7684\u5b57\u7b26\u3002 A string is a series of characters, such as \"Swift\" , that forms a collection. Strings in Swift are Unicode correct and locale insensitive, and are designed to be efficient. The String type bridges with the Objective-C class NSString and offers interoperability with C functions that works with strings. You can create new strings using string literals or string interpolations. A string literal is a series of characters enclosed in quotes. let greeting = \"Welcome!\" \u5b57\u7b26\u4e32\u63d2\u503c \u662f\u5b57\u7b26\u4e32\u5b57\u5143\uff0c\u5b83\u53ef\u4ee5\u8bc4\u4f30\u4efb\u4f55\u5305\u542b\u7684\u8868\u8fbe\u5f0f\u5e76\u5c06\u7ed3\u679c\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u5f62\u5f0f\u3002\u5b57\u7b26\u4e32\u63d2\u503c\u4e3a\u4f60\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\u65b9\u6cd5\u6765\u4ece\u591a\u4e2a\u7247\u6bb5\u4e2d\u5efa\u7acb\u4e00\u4e2a\u5b57\u7b26\u4e32\u3002\u5728\u5b57\u7b26\u4e32\u63d2\u503c\u4e2d\uff0c\u7528\u62ec\u53f7\u5c06\u6bcf\u4e2a\u8868\u8fbe\u5f0f\u5305\u88f9\u8d77\u6765\uff0c\u5e76\u5728\u62ec\u53f7\u524d\u52a0\u53cd\u659c\u6760\u3002 String interpolations are string literals that evaluate any included expressions and convert the results to string form. String interpolations give you an easy way to build a string from multiple pieces. Wrap each expression in a string interpolation in parentheses, prefixed by a backslash. let name = \"Rosa\" let personalizedGreeting = \"Welcome, \\\\(name)!\" // personalizedGreeting == \"Welcome, Rosa!\" let price = 2 let number = 3 let cookiePrice = \"\\\\(number) cookies: $\\\\(price * number).\" // cookiePrice == \"3 cookies: $6.\" let longerGreeting = greeting + \" We're glad you're here!\" // longerGreeting == \"Welcome! We're glad you're here!\" Multiline string literals are enclosed in three double quotation marks (\"\"\"), with each delimiter on its own line. Indentation is stripped from each line of a multiline string literal to match the indentation of the closing delimiter. let banner = \"\"\" __, ( o /) _/_ `. , , , , // / (___)(_(_/_(_ //_ (__ /) (/ \"\"\"","title":"\u5b57\u7b26\u4e32-String"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/#modifying-and-comparing-strings","text":"Strings always have value semantics. Modifying a copy of a string leaves the original unaffected. var otherGreeting = greeting otherGreeting += \" Have a nice time!\" // otherGreeting == \"Welcome! Have a nice time!\" print(greeting) // Prints \"Welcome!\" Comparing strings for equality using the equal-to operator (==) or a relational operator (like < or >=) is always performed using Unicode canonical representation. As a result, different representations of a string compare as being equal. let cafe1 = \"Cafe\\u{301}\" let cafe2 = \"Caf\u00e9\" print(cafe1 == cafe2) // Prints \"true\" The Unicode scalar value \"\\u{301}\" modifies the preceding character to include an accent, so \"e\\u{301}\" has the same canonical representation as the single Unicode scalar value \"\u00e9\". Basic string operations are not sensitive to locale settings, ensuring that string comparisons and other operations always have a single, stable result, allowing strings to be used as keys in Dictionary instances and for other purposes.","title":"Modifying and Comparing Strings"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/#accessing-string-elements","text":"A string is a collection of extended grapheme clusters, which approximate human-readable characters. Many individual characters, such as \u201c\u00e9\u201d, \u201c\uae40\u201d, and \u201c\ud83c\uddee\ud83c\uddf3\u201d, can be made up of multiple Unicode scalar values. These scalar values are combined by Unicode\u2019s boundary algorithms into extended grapheme clusters, represented by the Swift Character type. Each element of a string is represented by a Character instance. For example, to retrieve the first word of a longer string, you can search for a space and then create a substring from a prefix of the string up to that point: let name = \"Marie Curie\" let firstSpace = name.firstIndex(of: \" \") ?? name.endIndex let firstName = name[..<firstSpace] // firstName == \"Marie\" The firstName constant is an instance of the Substring type\u2014a type that represents substrings of a string while sharing the original string\u2019s storage. Substrings present the same interface as strings. print(\"\\(name)'s first name has \\(firstName.count) letters.\") // Prints \"Marie Curie's first name has 5 letters.\"","title":"Accessing String Elements"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/#accessing-a-strings-unicode-representation","text":"If you need to access the contents of a string as encoded in different Unicode encodings, use one of the string\u2019s unicodeScalars, utf16, or utf8 properties. Each property provides access to a view of the string as a series of code units, each encoded in a different Unicode encoding. To demonstrate the different views available for every string, the following examples use this String instance: let cafe = \"Cafe\\u{301} du \ud83c\udf0d\" print(cafe) // Prints \"Caf\u00e9 du \ud83c\udf0d\" The cafe string is a collection of the nine characters that are visible when the string is displayed. print(cafe.count) // Prints \"9\" print(Array(cafe)) // Prints \"[\"C\", \"a\", \"f\", \"\u00e9\", \" \", \"d\", \"u\", \" \", \"\ud83c\udf0d\"]\"","title":"Accessing a String\u2019s Unicode Representation"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/#unicode-scalar-view","text":"A string\u2019s unicodeScalars property is a collection of Unicode scalar values, the 21-bit codes that are the basic unit of Unicode. Each scalar value is represented by a Unicode.Scalar instance and is equivalent to a UTF-32 code unit. print(cafe.unicodeScalars.count) // Prints \"10\" print(Array(cafe.unicodeScalars)) // Prints \"[\"C\", \"a\", \"f\", \"e\", \"\\u{0301}\", \" \", \"d\", \"u\", \" \", \"\\u{0001F30D}\"]\" print(cafe.unicodeScalars.map { $0.value }) // Prints \"[67, 97, 102, 101, 769, 32, 100, 117, 32, 127757]\" The unicodeScalars view\u2019s elements comprise each Unicode scalar value in the cafe string. In particular, because cafe was declared using the decomposed form of the \"\u00e9\" character, unicodeScalars contains the scalar values for both the letter \"e\" (101) and the accent character \"\u00b4\" (769).","title":"Unicode Scalar View"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/#utf-16-view","text":"A string\u2019s utf16 property is a collection of UTF-16 code units, the 16-bit encoding form of the string\u2019s Unicode scalar values. Each code unit is stored as a UInt16 instance. print(cafe.utf16.count) // Prints \"11\" print(Array(cafe.utf16)) // Prints \"[67, 97, 102, 101, 769, 32, 100, 117, 32, 55356, 57101]\" The elements of the utf16 view are the code units for the string when encoded in UTF-16. These elements match those accessed through indexed NSString APIs. let nscafe = cafe as NSString print(nscafe.length) // Prints \"11\" print(nscafe.character(at: 3)) // Prints \"101\"","title":"UTF-16 View"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/#utf-8-view","text":"A string\u2019s utf8 property is a collection of UTF-8 code units, the 8-bit encoding form of the string\u2019s Unicode scalar values. Each code unit is stored as a UInt8 instance. print(cafe.utf8.count) // Prints \"14\" print(Array(cafe.utf8)) // Prints \"[67, 97, 102, 101, 204, 129, 32, 100, 117, 32, 240, 159, 140, 141]\" The elements of the utf8 view are the code units for the string when encoded in UTF-8. This representation matches the one used when String instances are passed to C APIs. let cLength = strlen(cafe) print(cLength) // Prints \"14\" Measuring the Length of a String When you need to know the length of a string, you must first consider what you\u2019ll use the length for. Are you measuring the number of characters that will be displayed on the screen, or are you measuring the amount of storage needed for the string in a particular encoding? A single string can have greatly differing lengths when measured by its different views. For example, an ASCII character like the capital letter A is represented by a single element in each of its four views. The Unicode scalar value of A is 65, which is small enough to fit in a single code unit in both UTF-16 and UTF-8. let capitalA = \"A\" print(capitalA.count) // Prints \"1\" print(capitalA.unicodeScalars.count) // Prints \"1\" print(capitalA.utf16.count) // Prints \"1\" print(capitalA.utf8.count) // Prints \"1\" On the other hand, an emoji flag character is constructed from a pair of Unicode scalar values, like \"\\u{1F1F5}\" and \"\\u{1F1F7}\". Each of these scalar values, in turn, is too large to fit into a single UTF-16 or UTF-8 code unit. As a result, each view of the string \"\ud83c\uddf5\ud83c\uddf7\" reports a different length. let flag = \"\ud83c\uddf5\ud83c\uddf7\" print(flag.count) // Prints \"1\" print(flag.unicodeScalars.count) // Prints \"2\" print(flag.utf16.count) // Prints \"4\" print(flag.utf8.count) // Prints \"8\" To check whether a string is empty, use its isEmpty property instead of comparing the length of one of the views to 0. Unlike with isEmpty, calculating a view\u2019s count property requires iterating through the elements of the string.","title":"UTF-8 View"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/#accessing-string-view-elements","text":"To find individual elements of a string, use the appropriate view for your task. For example, to retrieve the first word of a longer string, you can search the string for a space and then create a new string from a prefix of the string up to that point. let name = \"Marie Curie\" let firstSpace = name.firstIndex(of: \" \") ?? name.endIndex let firstName = name[..<firstSpace] print(firstName) // Prints \"Marie\" Strings and their views share indices, so you can access the UTF-8 view of the name string using the same firstSpace index. print(Array(name.utf8[..<firstSpace])) // Prints \"[77, 97, 114, 105, 101]\" Note that an index into one view may not have an exact corresponding position in another view. For example, the flag string declared above comprises a single character, but is composed of eight code units when encoded as UTF-8. The following code creates constants for the first and second positions in the flag.utf8 view. Accessing the utf8 view with these indices yields the first and second code UTF-8 units. let firstCodeUnit = flag.startIndex let secondCodeUnit = flag.utf8.index(after: firstCodeUnit) // flag.utf8[firstCodeUnit] == 240 // flag.utf8[secondCodeUnit] == 159 When used to access the elements of the flag string itself, however, the secondCodeUnit index does not correspond to the position of a specific character. Instead of only accessing the specific UTF-8 code unit, that index is treated as the position of the character at the index\u2019s encoded offset. In the case of secondCodeUnit, that character is still the flag itself. // flag[firstCodeUnit] == \"\ud83c\uddf5\ud83c\uddf7\" // flag[secondCodeUnit] == \"\ud83c\uddf5\ud83c\uddf7\" If you need to validate that an index from one string\u2019s view corresponds with an exact position in another view, use the index\u2019s samePosition(in:) method or the init(_:within:) initializer. if let exactIndex = secondCodeUnit.samePosition(in: flag) { print(flag[exactIndex]) } else { print(\"No exact match for this position.\") } // Prints \"No exact match for this position.\"","title":"Accessing String View Elements"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/#performance-optimizations","text":"Although strings in Swift have value semantics, strings use a copy-on-write strategy to store their data in a buffer. This buffer can then be shared by different copies of a string. A string\u2019s data is only copied lazily, upon mutation, when more than one string instance is using the same buffer. Therefore, the first in any sequence of mutating operations may cost O(n) time and space. When a string\u2019s contiguous storage fills up, a new buffer must be allocated and data must be moved to the new storage. String buffers use an exponential growth strategy that makes appending to a string a constant time operation when averaged over many append operations.","title":"Performance Optimizations"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/3.%E5%AD%97%E7%AC%A6%E4%B8%B2-String/#bridging-between-string-and-nsstring","text":"Any String instance can be bridged to NSString using the type-cast operator (as), and any String instance that originates in Objective-C may use an NSString instance as its storage. Because any arbitrary subclass of NSString can become a String instance, there are no guarantees about representation or efficiency when a String instance is backed by NSString storage. Because NSString is immutable, it is just as though the storage was shared by a copy. The first in any sequence of mutating operations causes elements to be copied into unique, contiguous storage which may cost O(n) time and space, where n is the length of the string\u2019s encoded representation (or more, if the underlying NSString has unusual performance characteristics). For more information about the Unicode terms used in this discussion, see the Unicode.org glossary. In particular, this discussion mentions extended grapheme clusters, Unicode scalar values, and canonical equivalence.","title":"Bridging Between String and NSString"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/4.%E6%95%B0%E7%BB%84-Array/4.%E6%95%B0%E7%BB%84-Array/","text":"\u6570\u7ec4-Array \u4e00\u4e2a\u6709\u5e8f\u7684\u3001\u968f\u673a\u8bbf\u95ee\u7684\u96c6\u5408\u3002 An ordered, random-access collection. \u8bf4\u660e @frozen struct Array<Element> \u6982\u8ff0","title":"\u6570\u7ec4-Array"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/4.%E6%95%B0%E7%BB%84-Array/4.%E6%95%B0%E7%BB%84-Array/#-array","text":"\u4e00\u4e2a\u6709\u5e8f\u7684\u3001\u968f\u673a\u8bbf\u95ee\u7684\u96c6\u5408\u3002 An ordered, random-access collection. \u8bf4\u660e @frozen struct Array<Element> \u6982\u8ff0","title":"\u6570\u7ec4-Array"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/5.%E5%AD%97%E5%85%B8-Dictionary/5.%E5%AD%97%E5%85%B8-Dictionary/","text":"\u5b57\u5178-Dictionary.md","title":"\u5b57\u5178-Dictionary.md"},{"location":"Swift/1.%E6%A0%87%E5%87%86%E5%BA%93-StandardLibrary/5.%E5%AD%97%E5%85%B8-Dictionary/5.%E5%AD%97%E5%85%B8-Dictionary/#-dictionarymd","text":"","title":"\u5b57\u5178-Dictionary.md"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/1.%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9-ChoosingBetweenStructuresAndClasses/","text":"\u7ed3\u6784\u4f53\u548c\u7c7b\u7684\u9009\u62e9-Choosing Between Structures and Classes \u51b3\u5b9a\u5982\u4f55\u5b58\u50a8\u6570\u636e\u548c\u6a21\u578b\u7684\u884c\u4e3a\u3002 Decide how to store data and model behavior. \u6982\u8ff0 \u7ed3\u6784\u4f53\u548c\u7c7b\u662f\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u5b58\u50a8\u6570\u636e\u548c\u5efa\u6a21\u884c\u4e3a\u7684\u597d\u9009\u62e9\uff0c\u4f46\u5b83\u4eec\u7684\u76f8\u4f3c\u6027\u53ef\u80fd\u4f1a\u8ba9\u4f60\u5f88\u96be\u9009\u62e9\u3002 Structures and classes are good choices for storing data and modeling behavior in your apps, but their similarities can make it difficult to choose one over the other. \u5728\u5411\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6dfb\u52a0\u65b0\u6570\u636e\u7c7b\u578b\u65f6\u8003\u8651\u4ee5\u4e0b\u5efa\u8bae\uff0c\u80fd\u591f\u5e2e\u52a9\u60a8\u505a\u51fa\u5408\u7406\u7684\u9009\u62e9\u3002 \u9ed8\u8ba4\u4f7f\u7528\u7ed3\u6784\u4f53 \u5f53\u4f60\u9700\u8981Objective-C\u7684\u4e92\u64cd\u4f5c\u6027\u65f6\uff0c\u8bf7\u4f7f\u7528\u7c7b\u3002 \u5f53\u4f60\u9700\u8981\u63a7\u5236\u4f60\u6b63\u5728\u5efa\u6a21\u7684\u6570\u636e\u7684\u8eab\u4efd\u65f6\uff0c\u8bf7\u4f7f\u7528\u7c7b\u3002 Consider the following recommendations to help choose which option makes sense when adding a new data type to your app. Use structures by default. Use classes when you need Objective-C interoperability. Use classes when you need to control the identity of the data you're modeling. \u9ed8\u8ba4\u4f7f\u7528\u7ed3\u6784\u4f53 \u4f7f\u7528\u7ed3\u6784\u4f53\u6765\u8868\u793a\u5e38\u89c1\u7684\u6570\u636e\u79cd\u7c7b\u3002Swift\u4e2d\u7684\u7ed3\u6784\u4f53\u5305\u542b\u4e86\u8bb8\u591a\u5728\u5176\u4ed6\u8bed\u8a00\u4e2d\u4ec5\u9650\u4e8e\u7c7b\u7684\u529f\u80fd\uff1a\u5b83\u53ef\u4ee5\u5305\u62ec\u5b58\u50a8\u5c5e\u6027\u3001\u8ba1\u7b97\u5c5e\u6027\u548c\u65b9\u6cd5\u3002\u6b64\u5916\uff0cSwift\u7684\u7ed3\u6784\u4f53\u53ef\u4ee5\u91c7\u7528\u534f\u8bae\uff0c\u901a\u8fc7\u9ed8\u8ba4\u5b9e\u73b0\uff08default implementations\uff09\u6765\u83b7\u5f97\u884c\u4e3a\u3002\u5728Swift\u6807\u51c6\u5e93\u548cFoundation\u4e2d\uff0c\u60a8\u7ecf\u5e38\u4f7f\u7528\u7684\u7c7b\u578b\u90fd\u662f\u7ed3\u6784\u4f53\uff0c\u5982\u6570\u5b57\u3001\u5b57\u7b26\u4e32\u3001\u6570\u7ec4\u548c\u5b57\u5178\u3002 Use structures to represent common kinds of data. Structures in Swift include many features that are limited to classes in other languages: They can include stored properties, computed properties, and methods. Moreover, Swift structures can adopt protocols to gain behavior through default implementations. The Swift standard library and Foundation use structures for types you use frequently, such as numbers, strings, arrays, and dictionaries. \u4f7f\u7528\u7ed3\u6784\u4f53\u53ef\u4ee5\u66f4\u5bb9\u6613\u5730\u5bf9\u4e00\u6bb5\u4ee3\u7801\u8fdb\u884c\u63a8\u7406\uff0c\u800c\u4e0d\u9700\u8981\u8003\u8651\u5e94\u7528\u7a0b\u5e8f\u7684\u6574\u4f53\u72b6\u6001\u3002\u56e0\u4e3a\u7ed3\u6784\u4f53\u662f\u503c\u7c7b\u578b\u2014\u2014\u4e0e\u7c7b\u4e0d\u540c\u2014\u2014\u5bf9\u7ed3\u6784\u4f53\u7684\u5c40\u90e8\u66f4\u6539\u5bf9\u5e94\u7528\u7a0b\u5e8f\u7684\u5176\u4ed6\u90e8\u5206\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\u9664\u975e\u60a8\u6709\u610f\u66b4\u9732\u8fd9\u4e9b\u66f4\u6539\uff0c\u4f5c\u4e3a\u5e94\u7528\u7a0b\u5e8f\u6d41\u7a0b\u7684\u4e00\u90e8\u5206\u3002\u56e0\u6b64\uff0c\u60a8\u53ef\u4ee5\u67e5\u770b\u4e00\u6bb5\u4ee3\u7801\uff0c\u5e76\u66f4\u6709\u4fe1\u5fc3\u5bf9\u8be5\u90e8\u5206\u7684\u5b9e\u4f8b\u8fdb\u884c\u660e\u786e\u7684\u66f4\u6539\uff0c\u800c\u4e0d\u662f\u4ece\u4e00\u4e2a\u76f8\u5173\u7684\u51fd\u6570\u8c03\u7528\u4e2d\u9690\u5f62\u5730\u8fdb\u884c\u66f4\u6539\u3002 Using structures makes it easier to reason about a portion of your code without needing to consider the whole state of your app. Because structures are value types\u2014unlike classes\u2014local changes to a structure aren't visible to the rest of your app unless you intentionally communicate those changes as part of the flow of your app. As a result, you can look at a section of code and be more confident that changes to instances in that section will be made explicitly, rather than being made invisibly from a tangentially related function call. \u5f53\u4f60\u9700\u8981Objective-C\u7684\u4e92\u64cd\u4f5c\u6027\u65f6\uff0c\u8bf7\u4f7f\u7528\u7c7b\u3002 \u5982\u679c\u4f60\u4f7f\u7528\u4e00\u4e2a\u9700\u8981\u5904\u7406\u6570\u636e\u7684Objective-C API\uff0c\u6216\u8005\u4f60\u9700\u8981\u5c06\u4f60\u7684\u6570\u636e\u6a21\u578b\u9002\u5408\u4e8eObjective-C\u6846\u67b6\u4e2d\u5b9a\u4e49\u7684\u73b0\u6709\u7c7b\u5c42\u6b21\u7ed3\u6784\uff0c\u4f60\u53ef\u80fd\u9700\u8981\u4f7f\u7528\u7c7b\u548c\u7c7b\u7ee7\u627f\u6765\u5bf9\u4f60\u7684\u6570\u636e\u8fdb\u884c\u5efa\u6a21\u3002\u4f8b\u5982\uff0c\u8bb8\u591aObjective-C\u6846\u67b6\u90fd\u66b4\u9732\u4e86\u4f60\u6240\u9700\u5b50\u7c7b\u7684\u7c7b\u3002 If you use an Objective-C API that needs to process your data, or you need to fit your data model into an existing class hierarchy defined in an Objective-C framework, you might need to use classes and class inheritance to model your data. For example, many Objective-C frameworks expose classes that you are expected to subclass. \u5f53\u4f60\u9700\u8981\u8eab\u4efd\u63a7\u5236\u65f6\uff0c\u8bf7\u4f7f\u7528\u7c7b Swift\u4e2d\u7684\u7c7b\u56e0\u4e3a\u662f\u5f15\u7528\u7c7b\u578b\uff0c\u6240\u4ee5\u5e26\u6709\u5185\u7f6e\u7684\u8eab\u4efd\u6982\u5ff5\u3002\u8fd9\u610f\u5473\u7740\uff0c\u5f53\u4e24\u4e2a\u4e0d\u540c\u7684\u7c7b\u5b9e\u4f8b\uff0c\u5373\u4fbf\u5404\u5b58\u50a8\u5c5e\u6027\u7684\u503c\u5bf9\u5e94\u76f8\u540c\uff0c\u5b83\u4eec\u4ecd\u7136\u88ab\u8eab\u4efd\u64cd\u4f5c\u7b26\uff08===\uff09\u8ba4\u4e3a\u662f\u4e0d\u540c\u7684\u3002\u8fd9\u4e5f\u610f\u5473\u7740\uff0c\u5f53\u4f60\u5728\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\u5171\u4eab\u4e00\u4e2a\u7c7b\u5b9e\u4f8b\u65f6\uff0c\u4f60\u5bf9\u8be5\u5b9e\u4f8b\u6240\u505a\u7684\u66f4\u6539\u5bf9\u4f60\u7684\u4ee3\u7801\u4e2d\u6301\u6709\u8be5\u5b9e\u4f8b\u5f15\u7528\u7684\u6bcf\u4e00\u90e8\u5206\u90fd\u662f\u53ef\u89c1\u7684\u3002\u5f53\u4f60\u9700\u8981\u4f60\u7684\u5b9e\u4f8b\u5177\u6709\u8fd9\u79cd\u8eab\u4efd\u65f6\uff0c\u8bf7\u4f7f\u7528\u7c7b\u3002\u5e38\u89c1\u7684\u7528\u4f8b\u662f\u6587\u4ef6\u53e5\u67c4\u3001\u7f51\u7edc\u8fde\u63a5\u548c\u50cfCBCentralManager\u8fd9\u6837\u7684\u5171\u4eab\u786c\u4ef6\u4e2d\u4ecb\u3002 Classes in Swift come with a built-in notion of identity because they're reference types. This means that when two different class instances have the same value for each of their stored properties, they're still considered to be different by the identity operator (===). It also means that when you share a class instance across your app, changes you make to that instance are visible to every part of your code that holds a reference to that instance. Use classes when you need your instances to have this kind of identity. Common use cases are file handles, network connections, and shared hardware intermediaries like CBCentralManager. \u4f8b\u5982\uff0c\u5982\u679c\u4f60\u6709\u4e00\u4e2a\u4ee3\u8868\u672c\u5730\u6570\u636e\u5e93\u8fde\u63a5\u7684\u7c7b\u578b\uff0c\u90a3\u4e48\u5728\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\uff0c\u7ba1\u7406\u8bbf\u95ee\u8be5\u6570\u636e\u5e93\u7684\u4ee3\u7801\u9700\u8981\u80fd\u591f\u5b8c\u5168\u63a7\u5236\u6570\u636e\u5e93\u7684\u72b6\u6001\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u4e00\u4e2a\u7c7b\u662f\u5408\u9002\u7684\uff0c\u4f46\u4e00\u5b9a\u8981\u9650\u5236\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\u7684\u54ea\u4e9b\u90e8\u5206\u53ef\u4ee5\u8bbf\u95ee\u5171\u4eab\u6570\u636e\u5e93\u5bf9\u8c61\u3002 For example, if you have a type that represents a local database connection, the code that manages access to that database needs full control over the state of the database as viewed from your app. It's appropriate to use a class in this case, but be sure to limit which parts of your app get access to the shared database object. \u91cd\u8981 \u8c28\u614e\u5bf9\u5f85\u8eab\u4efd\u3002\u5728\u6574\u4e2a\u5e94\u7528\u4e2d\u7ecf\u5e38\u5171\u4eab\u7c7b\u5b9e\u4f8b\u4f1a\u589e\u5927\u903b\u8f91\u9519\u8bef\u51fa\u73b0\u7684\u53ef\u80fd\u6027\u3002\u4f60\u53ef\u80fd\u65e0\u6cd5\u9884\u6599\u5230\u6539\u53d8\u4e00\u4e2a\u5927\u91cf\u5171\u4eab\u5b9e\u4f8b\u7684\u540e\u679c\uff0c\u6240\u4ee5\u8981\u6b63\u786e\u5730\u5199\u51fa\u8fd9\u6837\u7684\u4ee3\u7801\u662f\u6bd4\u8f83\u8f9b\u82e6\u7684\u3002 Important Treat identity with care. Sharing class instances pervasively throughout an app makes logic errors more likely. You might not anticipate the consequences of changing a heavily shared instance, so it's more work to write such code correctly. \u5f53\u4f60\u4e0d\u9700\u8981\u8eab\u4efd\u63a7\u5236\u65f6\uff0c\u8bf7\u4f7f\u7528\u7ed3\u6784\u4f53 \u5bf9\u542b\u6709\u60a8\u4e0d\u60f3\u63a7\u5236\u8eab\u4efd\u7684\u5b9e\u4f53\u8fdb\u884c\u5efa\u6a21\u65f6\uff0c\u8bf7\u4f7f\u7528\u7ed3\u6784\u4f53\u3002 Use structures when you're modeling data that contains information about an entity with an identity that you don't control. \u4f8b\u5982\uff0c\u5728\u4e00\u4e2a\u67e5\u8be2\u8fdc\u7a0b\u6570\u636e\u5e93\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\uff0c\u4e00\u4e2a\u5b9e\u4f8b\u7684\u8eab\u4efd\u53ef\u80fd\u5b8c\u5168\u7531\u5916\u90e8\u5b9e\u4f53\u62e5\u6709\uff0c\u5e76\u901a\u8fc7\u6807\u8bc6\u7b26\u8fdb\u884c\u901a\u4fe1\u3002\u5982\u679c\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u6a21\u578b\u4e00\u81f4\u6027\u5b58\u50a8\u5728\u670d\u52a1\u5668\u4e0a\uff0c\u60a8\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u8bb0\u5f55\u5efa\u6a21\u6210\u5e26\u6709\u6807\u8bc6\u7b26\u7684\u7ed3\u6784\u4f53\u3002\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0cjsonResponse\u5305\u542b\u4e00\u4e2a\u7531\u670d\u52a1\u5668\u7f16\u7801\u7684PenPalRecord\u5b9e\u4f8b\u3002 In an app that consults a remote database, for example, an instance's identity may be fully owned by an external entity and communicated by an identifier. If the consistency of an app's models is stored on a server, you can model records as structures with identifiers. In the example below, jsonResponse contains an encoded PenPalRecord instance from a server: struct PenPalRecord { let myID: Int var myNickname: String var recommendedPenPalID: Int } var myRecord = try JSONDecoder().decode(PenPalRecord.self, from: jsonResponse) \u50cfPenPalRecord\u8fd9\u6837\u7684\u6a21\u578b\u7c7b\u578b\u7684\u672c\u5730\u66f4\u6539\u662f\u6709\u7528\u7684\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u4f1a\u6839\u636e\u7528\u6237\u53cd\u9988\u63a8\u8350\u591a\u4e2a\u4e0d\u540c\u7684\u7b14\u53cb\u3002\u56e0\u4e3aPenPalRecord\u7ed3\u6784\u4f53\u5e76\u4e0d\u63a7\u5236\u5e95\u5c42\u6570\u636e\u5e93\u8bb0\u5f55\u7684\u8eab\u4efd\uff0c\u6240\u4ee5\u5bf9\u672c\u5730PenPalRecord\u5b9e\u4f8b\u8fdb\u884c\u66f4\u6539\u4e0d\u4f1a\u610f\u5916\u6539\u53d8\u6570\u636e\u5e93\u4e2d\u7684\u503c\u3002 Local changes to model types like PenPalRecord are useful. For example, an app might recommend multiple different penpals in response to user feedback. Because the PenPalRecord structure doesn't control the identity of the underlying database records, there's no risk that the changes made to local PenPalRecord instances accidentally change values in the database. \u5982\u679c\u5e94\u7528\u7a0b\u5e8f\u7684\u53e6\u4e00\u90e8\u5206\u66f4\u6539\u4e86myNickname\uff0c\u5e76\u5411\u670d\u52a1\u5668\u63d0\u4ea4\u4e86\u66f4\u6539\u8bf7\u6c42\uff0c\u90a3\u4e48\u6700\u540e\u4e00\u6b21\u7b14\u53cb\u63a8\u8350\u7684\u62d2\u7edd\u5c31\u4e0d\u4f1a\u56e0\u4e3a\u672c\u6b21\u7684\u66f4\u6539\u800c\u88ab\u9519\u8bef\u5730\u63a5\u53d7\u3002\u56e0\u4e3amyID\u5c5e\u6027\u88ab\u58f0\u660e\u4e3a\u5e38\u91cf\uff0c\u6240\u4ee5\u5b83\u65e0\u6cd5\u88ab\u4fee\u6539\u3002\u56e0\u6b64\uff0c\u5bf9\u6570\u636e\u5e93\u7684\u8bf7\u6c42\u4e0d\u4f1a\u610f\u5916\u5730\u6539\u9519\u8bb0\u5f55\u3002 If another part of the app changes myNickname and submits a change request back to the server, the most recently rejected penpal recommendation won't be mistakenly picked up by the change. Because the myID property is declared as a constant, it can't change locally. As a result, requests to the database won't accidentally change the wrong record. \u4f7f\u7528\u7ed3\u6784\u4f53\u548c\u534f\u8bae\u6765\u6a21\u62df\u7ee7\u627f\u548c\u5171\u4eab\u884c\u4e3a \u7ed3\u6784\u4f53\u548c\u7c7b\u90fd\u652f\u6301\u4e00\u79cd\u5f62\u5f0f\u7684\u7ee7\u627f\u3002\u7ed3\u6784\u4f53\u548c\u534f\u8bae\u53ea\u80fd\u91c7\u7528\u534f\u8bae\u6765\u7ee7\u627f\uff0c\u5b83\u4eec\u4e0d\u80fd\u4ece\u7c7b\u7ee7\u627f\u3002\u7136\u800c\uff0c\u4f60\u53ef\u4ee5\u7528\u7c7b\u7ee7\u627f\u6765\u5efa\u7acb\u7684\u90a3\u79cd\u7ee7\u627f\u5c42\u6b21\uff0c\u4e5f\u53ef\u4ee5\u7528\u534f\u8bae\u7ee7\u627f\u548c\u7ed3\u6784\u4f53\u6765\u5efa\u6a21\u3002 Structures and classes both support a form of inheritance. Structures and protocols can only adopt protocols; they can't inherit from classes. However, the kinds of inheritance hierarchies you can build with class inheritance can be also modeled using protocol inheritance and structures. \u5982\u679c\u4f60\u8981\u4ece\u5934\u5f00\u59cb\u5efa\u7acb\u7ee7\u627f\u5173\u7cfb\uff0c\u6700\u597d\u4f7f\u7528\u534f\u8bae\u7ee7\u627f\u3002\u534f\u8bae\u5141\u8bb8\u7c7b\u3001\u7ed3\u6784\u4f53\u548c\u679a\u4e3e\u53c2\u4e0e\u7ee7\u627f\uff0c\u800c\u7c7b\u7ee7\u627f\u53ea\u4e0e\u5176\u4ed6\u7c7b\u517c\u5bb9\u3002\u5f53\u4f60\u5728\u9009\u62e9\u5982\u4f55\u5bf9\u6570\u636e\u8fdb\u884c\u5efa\u6a21\u65f6\uff0c\u5148\u5c1d\u8bd5\u4f7f\u7528\u534f\u8bae\u7ee7\u627f\u6765\u6784\u5efa\u6570\u636e\u7c7b\u578b\u7684\u5c42\u6b21\u7ed3\u6784\uff0c\u7136\u540e\u5728\u7ed3\u6784\u4f53\u4e2d\u91c7\u7528\u8fd9\u4e9b\u534f\u8bae\u3002 If you're building an inheritance relationship from scratch, prefer protocol inheritance. Protocols permit classes, structures, and enumerations to participate in inheritance, while class inheritance is only compatible with other classes. When you're choosing how to model your data, try building the hierarchy of data types using protocol inheritance first, then adopt those protocols in your structures.","title":"\u7ed3\u6784\u4f53\u548c\u7c7b\u7684\u9009\u62e9-Choosing Between Structures and Classes"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/1.%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9-ChoosingBetweenStructuresAndClasses/#-choosing-between-structures-and-classes","text":"\u51b3\u5b9a\u5982\u4f55\u5b58\u50a8\u6570\u636e\u548c\u6a21\u578b\u7684\u884c\u4e3a\u3002 Decide how to store data and model behavior.","title":"\u7ed3\u6784\u4f53\u548c\u7c7b\u7684\u9009\u62e9-Choosing Between Structures and Classes"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/1.%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9-ChoosingBetweenStructuresAndClasses/#_1","text":"\u7ed3\u6784\u4f53\u548c\u7c7b\u662f\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u5b58\u50a8\u6570\u636e\u548c\u5efa\u6a21\u884c\u4e3a\u7684\u597d\u9009\u62e9\uff0c\u4f46\u5b83\u4eec\u7684\u76f8\u4f3c\u6027\u53ef\u80fd\u4f1a\u8ba9\u4f60\u5f88\u96be\u9009\u62e9\u3002 Structures and classes are good choices for storing data and modeling behavior in your apps, but their similarities can make it difficult to choose one over the other. \u5728\u5411\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6dfb\u52a0\u65b0\u6570\u636e\u7c7b\u578b\u65f6\u8003\u8651\u4ee5\u4e0b\u5efa\u8bae\uff0c\u80fd\u591f\u5e2e\u52a9\u60a8\u505a\u51fa\u5408\u7406\u7684\u9009\u62e9\u3002 \u9ed8\u8ba4\u4f7f\u7528\u7ed3\u6784\u4f53 \u5f53\u4f60\u9700\u8981Objective-C\u7684\u4e92\u64cd\u4f5c\u6027\u65f6\uff0c\u8bf7\u4f7f\u7528\u7c7b\u3002 \u5f53\u4f60\u9700\u8981\u63a7\u5236\u4f60\u6b63\u5728\u5efa\u6a21\u7684\u6570\u636e\u7684\u8eab\u4efd\u65f6\uff0c\u8bf7\u4f7f\u7528\u7c7b\u3002 Consider the following recommendations to help choose which option makes sense when adding a new data type to your app. Use structures by default. Use classes when you need Objective-C interoperability. Use classes when you need to control the identity of the data you're modeling.","title":"\u6982\u8ff0"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/1.%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9-ChoosingBetweenStructuresAndClasses/#_2","text":"\u4f7f\u7528\u7ed3\u6784\u4f53\u6765\u8868\u793a\u5e38\u89c1\u7684\u6570\u636e\u79cd\u7c7b\u3002Swift\u4e2d\u7684\u7ed3\u6784\u4f53\u5305\u542b\u4e86\u8bb8\u591a\u5728\u5176\u4ed6\u8bed\u8a00\u4e2d\u4ec5\u9650\u4e8e\u7c7b\u7684\u529f\u80fd\uff1a\u5b83\u53ef\u4ee5\u5305\u62ec\u5b58\u50a8\u5c5e\u6027\u3001\u8ba1\u7b97\u5c5e\u6027\u548c\u65b9\u6cd5\u3002\u6b64\u5916\uff0cSwift\u7684\u7ed3\u6784\u4f53\u53ef\u4ee5\u91c7\u7528\u534f\u8bae\uff0c\u901a\u8fc7\u9ed8\u8ba4\u5b9e\u73b0\uff08default implementations\uff09\u6765\u83b7\u5f97\u884c\u4e3a\u3002\u5728Swift\u6807\u51c6\u5e93\u548cFoundation\u4e2d\uff0c\u60a8\u7ecf\u5e38\u4f7f\u7528\u7684\u7c7b\u578b\u90fd\u662f\u7ed3\u6784\u4f53\uff0c\u5982\u6570\u5b57\u3001\u5b57\u7b26\u4e32\u3001\u6570\u7ec4\u548c\u5b57\u5178\u3002 Use structures to represent common kinds of data. Structures in Swift include many features that are limited to classes in other languages: They can include stored properties, computed properties, and methods. Moreover, Swift structures can adopt protocols to gain behavior through default implementations. The Swift standard library and Foundation use structures for types you use frequently, such as numbers, strings, arrays, and dictionaries. \u4f7f\u7528\u7ed3\u6784\u4f53\u53ef\u4ee5\u66f4\u5bb9\u6613\u5730\u5bf9\u4e00\u6bb5\u4ee3\u7801\u8fdb\u884c\u63a8\u7406\uff0c\u800c\u4e0d\u9700\u8981\u8003\u8651\u5e94\u7528\u7a0b\u5e8f\u7684\u6574\u4f53\u72b6\u6001\u3002\u56e0\u4e3a\u7ed3\u6784\u4f53\u662f\u503c\u7c7b\u578b\u2014\u2014\u4e0e\u7c7b\u4e0d\u540c\u2014\u2014\u5bf9\u7ed3\u6784\u4f53\u7684\u5c40\u90e8\u66f4\u6539\u5bf9\u5e94\u7528\u7a0b\u5e8f\u7684\u5176\u4ed6\u90e8\u5206\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\u9664\u975e\u60a8\u6709\u610f\u66b4\u9732\u8fd9\u4e9b\u66f4\u6539\uff0c\u4f5c\u4e3a\u5e94\u7528\u7a0b\u5e8f\u6d41\u7a0b\u7684\u4e00\u90e8\u5206\u3002\u56e0\u6b64\uff0c\u60a8\u53ef\u4ee5\u67e5\u770b\u4e00\u6bb5\u4ee3\u7801\uff0c\u5e76\u66f4\u6709\u4fe1\u5fc3\u5bf9\u8be5\u90e8\u5206\u7684\u5b9e\u4f8b\u8fdb\u884c\u660e\u786e\u7684\u66f4\u6539\uff0c\u800c\u4e0d\u662f\u4ece\u4e00\u4e2a\u76f8\u5173\u7684\u51fd\u6570\u8c03\u7528\u4e2d\u9690\u5f62\u5730\u8fdb\u884c\u66f4\u6539\u3002 Using structures makes it easier to reason about a portion of your code without needing to consider the whole state of your app. Because structures are value types\u2014unlike classes\u2014local changes to a structure aren't visible to the rest of your app unless you intentionally communicate those changes as part of the flow of your app. As a result, you can look at a section of code and be more confident that changes to instances in that section will be made explicitly, rather than being made invisibly from a tangentially related function call.","title":"\u9ed8\u8ba4\u4f7f\u7528\u7ed3\u6784\u4f53"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/1.%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9-ChoosingBetweenStructuresAndClasses/#objective-c","text":"\u5982\u679c\u4f60\u4f7f\u7528\u4e00\u4e2a\u9700\u8981\u5904\u7406\u6570\u636e\u7684Objective-C API\uff0c\u6216\u8005\u4f60\u9700\u8981\u5c06\u4f60\u7684\u6570\u636e\u6a21\u578b\u9002\u5408\u4e8eObjective-C\u6846\u67b6\u4e2d\u5b9a\u4e49\u7684\u73b0\u6709\u7c7b\u5c42\u6b21\u7ed3\u6784\uff0c\u4f60\u53ef\u80fd\u9700\u8981\u4f7f\u7528\u7c7b\u548c\u7c7b\u7ee7\u627f\u6765\u5bf9\u4f60\u7684\u6570\u636e\u8fdb\u884c\u5efa\u6a21\u3002\u4f8b\u5982\uff0c\u8bb8\u591aObjective-C\u6846\u67b6\u90fd\u66b4\u9732\u4e86\u4f60\u6240\u9700\u5b50\u7c7b\u7684\u7c7b\u3002 If you use an Objective-C API that needs to process your data, or you need to fit your data model into an existing class hierarchy defined in an Objective-C framework, you might need to use classes and class inheritance to model your data. For example, many Objective-C frameworks expose classes that you are expected to subclass.","title":"\u5f53\u4f60\u9700\u8981Objective-C\u7684\u4e92\u64cd\u4f5c\u6027\u65f6\uff0c\u8bf7\u4f7f\u7528\u7c7b\u3002"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/1.%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9-ChoosingBetweenStructuresAndClasses/#_3","text":"Swift\u4e2d\u7684\u7c7b\u56e0\u4e3a\u662f\u5f15\u7528\u7c7b\u578b\uff0c\u6240\u4ee5\u5e26\u6709\u5185\u7f6e\u7684\u8eab\u4efd\u6982\u5ff5\u3002\u8fd9\u610f\u5473\u7740\uff0c\u5f53\u4e24\u4e2a\u4e0d\u540c\u7684\u7c7b\u5b9e\u4f8b\uff0c\u5373\u4fbf\u5404\u5b58\u50a8\u5c5e\u6027\u7684\u503c\u5bf9\u5e94\u76f8\u540c\uff0c\u5b83\u4eec\u4ecd\u7136\u88ab\u8eab\u4efd\u64cd\u4f5c\u7b26\uff08===\uff09\u8ba4\u4e3a\u662f\u4e0d\u540c\u7684\u3002\u8fd9\u4e5f\u610f\u5473\u7740\uff0c\u5f53\u4f60\u5728\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\u5171\u4eab\u4e00\u4e2a\u7c7b\u5b9e\u4f8b\u65f6\uff0c\u4f60\u5bf9\u8be5\u5b9e\u4f8b\u6240\u505a\u7684\u66f4\u6539\u5bf9\u4f60\u7684\u4ee3\u7801\u4e2d\u6301\u6709\u8be5\u5b9e\u4f8b\u5f15\u7528\u7684\u6bcf\u4e00\u90e8\u5206\u90fd\u662f\u53ef\u89c1\u7684\u3002\u5f53\u4f60\u9700\u8981\u4f60\u7684\u5b9e\u4f8b\u5177\u6709\u8fd9\u79cd\u8eab\u4efd\u65f6\uff0c\u8bf7\u4f7f\u7528\u7c7b\u3002\u5e38\u89c1\u7684\u7528\u4f8b\u662f\u6587\u4ef6\u53e5\u67c4\u3001\u7f51\u7edc\u8fde\u63a5\u548c\u50cfCBCentralManager\u8fd9\u6837\u7684\u5171\u4eab\u786c\u4ef6\u4e2d\u4ecb\u3002 Classes in Swift come with a built-in notion of identity because they're reference types. This means that when two different class instances have the same value for each of their stored properties, they're still considered to be different by the identity operator (===). It also means that when you share a class instance across your app, changes you make to that instance are visible to every part of your code that holds a reference to that instance. Use classes when you need your instances to have this kind of identity. Common use cases are file handles, network connections, and shared hardware intermediaries like CBCentralManager. \u4f8b\u5982\uff0c\u5982\u679c\u4f60\u6709\u4e00\u4e2a\u4ee3\u8868\u672c\u5730\u6570\u636e\u5e93\u8fde\u63a5\u7684\u7c7b\u578b\uff0c\u90a3\u4e48\u5728\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\uff0c\u7ba1\u7406\u8bbf\u95ee\u8be5\u6570\u636e\u5e93\u7684\u4ee3\u7801\u9700\u8981\u80fd\u591f\u5b8c\u5168\u63a7\u5236\u6570\u636e\u5e93\u7684\u72b6\u6001\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u4e00\u4e2a\u7c7b\u662f\u5408\u9002\u7684\uff0c\u4f46\u4e00\u5b9a\u8981\u9650\u5236\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\u7684\u54ea\u4e9b\u90e8\u5206\u53ef\u4ee5\u8bbf\u95ee\u5171\u4eab\u6570\u636e\u5e93\u5bf9\u8c61\u3002 For example, if you have a type that represents a local database connection, the code that manages access to that database needs full control over the state of the database as viewed from your app. It's appropriate to use a class in this case, but be sure to limit which parts of your app get access to the shared database object. \u91cd\u8981 \u8c28\u614e\u5bf9\u5f85\u8eab\u4efd\u3002\u5728\u6574\u4e2a\u5e94\u7528\u4e2d\u7ecf\u5e38\u5171\u4eab\u7c7b\u5b9e\u4f8b\u4f1a\u589e\u5927\u903b\u8f91\u9519\u8bef\u51fa\u73b0\u7684\u53ef\u80fd\u6027\u3002\u4f60\u53ef\u80fd\u65e0\u6cd5\u9884\u6599\u5230\u6539\u53d8\u4e00\u4e2a\u5927\u91cf\u5171\u4eab\u5b9e\u4f8b\u7684\u540e\u679c\uff0c\u6240\u4ee5\u8981\u6b63\u786e\u5730\u5199\u51fa\u8fd9\u6837\u7684\u4ee3\u7801\u662f\u6bd4\u8f83\u8f9b\u82e6\u7684\u3002 Important Treat identity with care. Sharing class instances pervasively throughout an app makes logic errors more likely. You might not anticipate the consequences of changing a heavily shared instance, so it's more work to write such code correctly.","title":"\u5f53\u4f60\u9700\u8981\u8eab\u4efd\u63a7\u5236\u65f6\uff0c\u8bf7\u4f7f\u7528\u7c7b"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/1.%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9-ChoosingBetweenStructuresAndClasses/#_4","text":"\u5bf9\u542b\u6709\u60a8\u4e0d\u60f3\u63a7\u5236\u8eab\u4efd\u7684\u5b9e\u4f53\u8fdb\u884c\u5efa\u6a21\u65f6\uff0c\u8bf7\u4f7f\u7528\u7ed3\u6784\u4f53\u3002 Use structures when you're modeling data that contains information about an entity with an identity that you don't control. \u4f8b\u5982\uff0c\u5728\u4e00\u4e2a\u67e5\u8be2\u8fdc\u7a0b\u6570\u636e\u5e93\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\uff0c\u4e00\u4e2a\u5b9e\u4f8b\u7684\u8eab\u4efd\u53ef\u80fd\u5b8c\u5168\u7531\u5916\u90e8\u5b9e\u4f53\u62e5\u6709\uff0c\u5e76\u901a\u8fc7\u6807\u8bc6\u7b26\u8fdb\u884c\u901a\u4fe1\u3002\u5982\u679c\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u6a21\u578b\u4e00\u81f4\u6027\u5b58\u50a8\u5728\u670d\u52a1\u5668\u4e0a\uff0c\u60a8\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u8bb0\u5f55\u5efa\u6a21\u6210\u5e26\u6709\u6807\u8bc6\u7b26\u7684\u7ed3\u6784\u4f53\u3002\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0cjsonResponse\u5305\u542b\u4e00\u4e2a\u7531\u670d\u52a1\u5668\u7f16\u7801\u7684PenPalRecord\u5b9e\u4f8b\u3002 In an app that consults a remote database, for example, an instance's identity may be fully owned by an external entity and communicated by an identifier. If the consistency of an app's models is stored on a server, you can model records as structures with identifiers. In the example below, jsonResponse contains an encoded PenPalRecord instance from a server: struct PenPalRecord { let myID: Int var myNickname: String var recommendedPenPalID: Int } var myRecord = try JSONDecoder().decode(PenPalRecord.self, from: jsonResponse) \u50cfPenPalRecord\u8fd9\u6837\u7684\u6a21\u578b\u7c7b\u578b\u7684\u672c\u5730\u66f4\u6539\u662f\u6709\u7528\u7684\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u53ef\u80fd\u4f1a\u6839\u636e\u7528\u6237\u53cd\u9988\u63a8\u8350\u591a\u4e2a\u4e0d\u540c\u7684\u7b14\u53cb\u3002\u56e0\u4e3aPenPalRecord\u7ed3\u6784\u4f53\u5e76\u4e0d\u63a7\u5236\u5e95\u5c42\u6570\u636e\u5e93\u8bb0\u5f55\u7684\u8eab\u4efd\uff0c\u6240\u4ee5\u5bf9\u672c\u5730PenPalRecord\u5b9e\u4f8b\u8fdb\u884c\u66f4\u6539\u4e0d\u4f1a\u610f\u5916\u6539\u53d8\u6570\u636e\u5e93\u4e2d\u7684\u503c\u3002 Local changes to model types like PenPalRecord are useful. For example, an app might recommend multiple different penpals in response to user feedback. Because the PenPalRecord structure doesn't control the identity of the underlying database records, there's no risk that the changes made to local PenPalRecord instances accidentally change values in the database. \u5982\u679c\u5e94\u7528\u7a0b\u5e8f\u7684\u53e6\u4e00\u90e8\u5206\u66f4\u6539\u4e86myNickname\uff0c\u5e76\u5411\u670d\u52a1\u5668\u63d0\u4ea4\u4e86\u66f4\u6539\u8bf7\u6c42\uff0c\u90a3\u4e48\u6700\u540e\u4e00\u6b21\u7b14\u53cb\u63a8\u8350\u7684\u62d2\u7edd\u5c31\u4e0d\u4f1a\u56e0\u4e3a\u672c\u6b21\u7684\u66f4\u6539\u800c\u88ab\u9519\u8bef\u5730\u63a5\u53d7\u3002\u56e0\u4e3amyID\u5c5e\u6027\u88ab\u58f0\u660e\u4e3a\u5e38\u91cf\uff0c\u6240\u4ee5\u5b83\u65e0\u6cd5\u88ab\u4fee\u6539\u3002\u56e0\u6b64\uff0c\u5bf9\u6570\u636e\u5e93\u7684\u8bf7\u6c42\u4e0d\u4f1a\u610f\u5916\u5730\u6539\u9519\u8bb0\u5f55\u3002 If another part of the app changes myNickname and submits a change request back to the server, the most recently rejected penpal recommendation won't be mistakenly picked up by the change. Because the myID property is declared as a constant, it can't change locally. As a result, requests to the database won't accidentally change the wrong record.","title":"\u5f53\u4f60\u4e0d\u9700\u8981\u8eab\u4efd\u63a7\u5236\u65f6\uff0c\u8bf7\u4f7f\u7528\u7ed3\u6784\u4f53"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/1.%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E9%80%89%E6%8B%A9-ChoosingBetweenStructuresAndClasses/#_5","text":"\u7ed3\u6784\u4f53\u548c\u7c7b\u90fd\u652f\u6301\u4e00\u79cd\u5f62\u5f0f\u7684\u7ee7\u627f\u3002\u7ed3\u6784\u4f53\u548c\u534f\u8bae\u53ea\u80fd\u91c7\u7528\u534f\u8bae\u6765\u7ee7\u627f\uff0c\u5b83\u4eec\u4e0d\u80fd\u4ece\u7c7b\u7ee7\u627f\u3002\u7136\u800c\uff0c\u4f60\u53ef\u4ee5\u7528\u7c7b\u7ee7\u627f\u6765\u5efa\u7acb\u7684\u90a3\u79cd\u7ee7\u627f\u5c42\u6b21\uff0c\u4e5f\u53ef\u4ee5\u7528\u534f\u8bae\u7ee7\u627f\u548c\u7ed3\u6784\u4f53\u6765\u5efa\u6a21\u3002 Structures and classes both support a form of inheritance. Structures and protocols can only adopt protocols; they can't inherit from classes. However, the kinds of inheritance hierarchies you can build with class inheritance can be also modeled using protocol inheritance and structures. \u5982\u679c\u4f60\u8981\u4ece\u5934\u5f00\u59cb\u5efa\u7acb\u7ee7\u627f\u5173\u7cfb\uff0c\u6700\u597d\u4f7f\u7528\u534f\u8bae\u7ee7\u627f\u3002\u534f\u8bae\u5141\u8bb8\u7c7b\u3001\u7ed3\u6784\u4f53\u548c\u679a\u4e3e\u53c2\u4e0e\u7ee7\u627f\uff0c\u800c\u7c7b\u7ee7\u627f\u53ea\u4e0e\u5176\u4ed6\u7c7b\u517c\u5bb9\u3002\u5f53\u4f60\u5728\u9009\u62e9\u5982\u4f55\u5bf9\u6570\u636e\u8fdb\u884c\u5efa\u6a21\u65f6\uff0c\u5148\u5c1d\u8bd5\u4f7f\u7528\u534f\u8bae\u7ee7\u627f\u6765\u6784\u5efa\u6570\u636e\u7c7b\u578b\u7684\u5c42\u6b21\u7ed3\u6784\uff0c\u7136\u540e\u5728\u7ed3\u6784\u4f53\u4e2d\u91c7\u7528\u8fd9\u4e9b\u534f\u8bae\u3002 If you're building an inheritance relationship from scratch, prefer protocol inheritance. Protocols permit classes, structures, and enumerations to participate in inheritance, while class inheritance is only compatible with other classes. When you're choosing how to model your data, try building the hierarchy of data types using protocol inheritance first, then adopt those protocols in your structures.","title":"\u4f7f\u7528\u7ed3\u6784\u4f53\u548c\u534f\u8bae\u6765\u6a21\u62df\u7ee7\u627f\u548c\u5171\u4eab\u884c\u4e3a"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/2.%E9%87%87%E7%94%A8%E5%85%B1%E5%90%8C%E5%8D%8F%E8%AE%AE-AdoptingCommonProtocols/","text":"\u91c7\u7528\u5171\u540c\u534f\u8bae-AdoptingCommonProtocols Make your custom types easier to use by ensuring that they conform to Swift protocols. \u6982\u8ff0 When using custom types to model data in your programs, you may frequently need to check whether two values are the same or different, or whether a particular value is included in a list of values. This capability, as well as the ability to store values in a set or use them as keys in a dictionary, are governed by two related standard library protocols, Equatable and Hashable. You can compare instances of an equatable type by using the equal-to (==) and not-equal-to (!=) operators. An instance of a hashable type can reduce its value mathematically to a single integer, which is used internally by sets and dictionaries to make lookups consistently fast. Many standard library types are both equatable and hashable, including strings, integers, floating-point values, Boolean values, and collections of equatable and hashable types. The == comparison and the contains(_:) method call in the following example depend on strings and integers being equatable: if username == \"Arturo\" { print(\"Hi, Arturo!\") } let favoriteNumbers = [4, 7, 8, 9] if favoriteNumbers.contains(todaysDate.day) { print(\"It's a good day today!\") } Conforming to the Equatable and Hashable protocols is straightforward and makes it easier to use your own types in Swift. It's a good idea for all your custom model types to conform. Conform Automatically to Equatable and Hashable You can make many custom types equatable and hashable by simply declaring these protocol conformances in the same file as the type's original declaration. Add Equatable and Hashable to the list of adopted protocols when declaring the type, and the compiler automatically fills in the requirements for the two protocols: /// A position in an x-y coordinate system. struct Position: Equatable, Hashable { var x: Int var y: Int init(_ x: Int, _ y: Int) { self.x = x self.y = y } } With Equatable conformance, you can use the equal-to operator (==) or the not-equal-to operator (!=) with any two instances of the Position type. let availablePositions = [Position(0, 0), Position(0, 1), Position(1, 0)] let gemPosition = Position(1, 0) for position in availablePositions { if gemPosition == position { print(\"Gem found at (\\(position.x), \\(position.y))!\") } else { print(\"No gem at (\\(position.x), \\(position.y))\") } } // No gem at (0, 0) // No gem at (0, 1) // Gem found at (1, 0)! Hashable conformance means that you can store positions in a set and quickly check whether you've visited a position before, as shown in the following example: var visitedPositions: Set = [Position(0, 0), Position(1, 0)] let currentPosition = Position(1, 3) if visitedPositions.contains(currentPosition) { print(\"Already visited (\\(currentPosition.x), \\(currentPosition.y))\") } else { print(\"First time at (\\(currentPosition.x), \\(currentPosition.y))\") visitedPositions.insert(currentPosition) } // First time at (1, 3) In addition to simplifying your code, this automatic conformance reduces errors, because any new properties you add to your custom types are automatically included when hashing and testing for equality. A type is eligible for automatic conformance to Equatable and Hashable when it's a structure or an enumeration that meets these criteria: For a structure, all its stored properties must conform to Equatable and Hashable. For an enumeration, all its associated values must conform to Equatable and Hashable. (Enumerations without associated values have Equatable and Hashable conformance even without declaring adoption.) Conform Manually to Equatable and Hashable You need to manually implement Equatable and Hashable conformance for a type in these cases: The type doesn't meet the criteria listed in the previous section. You want to customize the type's conformance. You want to extend a type declared in another file or module to conform. class Player { var name: String var position: Position init(name: String, position: Position) { self.name = name self.position = position } } The Player type is a class, so it doesn't qualify for automatic synthesis of the Equatable or Hashable requirements. To make this class conform to the Equatable protocol, declare conformance in an extension and implement the static == operator method. Compare each significant property for equality in your == method's implementation: extension Player: Equatable { static func ==(lhs: Player, rhs: Player) -> Bool { return lhs.name == rhs.name && lhs.position == rhs.position } } To make Player conform to the Hashable protocol, declare conformance in another extension and implement the hash(into:) method. In the hash(into:) method, call the combine(_:) method on the provided hasher with each significant property: extension Player: Hashable { func hash(into hasher: inout Hasher) { hasher.combine(name) hasher.combine(position) } } Use All Significant Properties for Equatable and Hashable When implementing the == method and the hash(into:) method, use all the properties that affect whether two instances of your custom type are considered equal. In the implementations above, the Player type uses name and position in both methods. If your type contains properties that don't affect whether two instances are considered equal, exclude those properties from comparison in the == method and from hashing in hash(into:). For example, a type might cache an expensive computed value so that it only needs to calculate it once. If you compare two instances of that type, whether or not the computed value has been cached shouldn't affect their equality, so the cached value should be excluded from comparison and hashing. Important Always use the same properties in both your == and hash(into:) methods. Using different groups of properties in the two methods can lead to unexpected behavior or performance when using your custom type in sets and dictionaries. Customize NSObject Subclass Behavior NSObject subclasses inherit conformance to the Equatable and Hashable protocols, with equality based on instance identity. If you need to customize this behavior, override the isEqual(_:) method and hash property instead of the == operator method and hashValue property. extension MyNSObjectSubclass { override func isEqual(_ object: Any?) -> Bool { guard let other = object as? MyNSObjectSubclass else { return false } return self.firstProperty == other.firstProperty && self.secondProperty == other.secondProperty } override var hash: Int { var hasher = Hasher() hasher.combine(firstProperty) hasher.combine(secondProperty) return hasher.finalize() } } As noted in the previous section, two instances that are considered equal must have the same hash value. If you override one of these declarations, you must also override the other to maintain that guarantee.","title":"\u91c7\u7528\u5171\u540c\u534f\u8bae-AdoptingCommonProtocols"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/2.%E9%87%87%E7%94%A8%E5%85%B1%E5%90%8C%E5%8D%8F%E8%AE%AE-AdoptingCommonProtocols/#-adoptingcommonprotocols","text":"Make your custom types easier to use by ensuring that they conform to Swift protocols.","title":"\u91c7\u7528\u5171\u540c\u534f\u8bae-AdoptingCommonProtocols"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/2.%E9%87%87%E7%94%A8%E5%85%B1%E5%90%8C%E5%8D%8F%E8%AE%AE-AdoptingCommonProtocols/#_1","text":"When using custom types to model data in your programs, you may frequently need to check whether two values are the same or different, or whether a particular value is included in a list of values. This capability, as well as the ability to store values in a set or use them as keys in a dictionary, are governed by two related standard library protocols, Equatable and Hashable. You can compare instances of an equatable type by using the equal-to (==) and not-equal-to (!=) operators. An instance of a hashable type can reduce its value mathematically to a single integer, which is used internally by sets and dictionaries to make lookups consistently fast. Many standard library types are both equatable and hashable, including strings, integers, floating-point values, Boolean values, and collections of equatable and hashable types. The == comparison and the contains(_:) method call in the following example depend on strings and integers being equatable: if username == \"Arturo\" { print(\"Hi, Arturo!\") } let favoriteNumbers = [4, 7, 8, 9] if favoriteNumbers.contains(todaysDate.day) { print(\"It's a good day today!\") } Conforming to the Equatable and Hashable protocols is straightforward and makes it easier to use your own types in Swift. It's a good idea for all your custom model types to conform.","title":"\u6982\u8ff0"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/2.%E9%87%87%E7%94%A8%E5%85%B1%E5%90%8C%E5%8D%8F%E8%AE%AE-AdoptingCommonProtocols/#conform-automatically-to-equatable-and-hashable","text":"You can make many custom types equatable and hashable by simply declaring these protocol conformances in the same file as the type's original declaration. Add Equatable and Hashable to the list of adopted protocols when declaring the type, and the compiler automatically fills in the requirements for the two protocols: /// A position in an x-y coordinate system. struct Position: Equatable, Hashable { var x: Int var y: Int init(_ x: Int, _ y: Int) { self.x = x self.y = y } } With Equatable conformance, you can use the equal-to operator (==) or the not-equal-to operator (!=) with any two instances of the Position type. let availablePositions = [Position(0, 0), Position(0, 1), Position(1, 0)] let gemPosition = Position(1, 0) for position in availablePositions { if gemPosition == position { print(\"Gem found at (\\(position.x), \\(position.y))!\") } else { print(\"No gem at (\\(position.x), \\(position.y))\") } } // No gem at (0, 0) // No gem at (0, 1) // Gem found at (1, 0)! Hashable conformance means that you can store positions in a set and quickly check whether you've visited a position before, as shown in the following example: var visitedPositions: Set = [Position(0, 0), Position(1, 0)] let currentPosition = Position(1, 3) if visitedPositions.contains(currentPosition) { print(\"Already visited (\\(currentPosition.x), \\(currentPosition.y))\") } else { print(\"First time at (\\(currentPosition.x), \\(currentPosition.y))\") visitedPositions.insert(currentPosition) } // First time at (1, 3) In addition to simplifying your code, this automatic conformance reduces errors, because any new properties you add to your custom types are automatically included when hashing and testing for equality. A type is eligible for automatic conformance to Equatable and Hashable when it's a structure or an enumeration that meets these criteria: For a structure, all its stored properties must conform to Equatable and Hashable. For an enumeration, all its associated values must conform to Equatable and Hashable. (Enumerations without associated values have Equatable and Hashable conformance even without declaring adoption.)","title":"Conform Automatically to Equatable and Hashable"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/2.%E9%87%87%E7%94%A8%E5%85%B1%E5%90%8C%E5%8D%8F%E8%AE%AE-AdoptingCommonProtocols/#conform-manually-to-equatable-and-hashable","text":"You need to manually implement Equatable and Hashable conformance for a type in these cases: The type doesn't meet the criteria listed in the previous section. You want to customize the type's conformance. You want to extend a type declared in another file or module to conform. class Player { var name: String var position: Position init(name: String, position: Position) { self.name = name self.position = position } } The Player type is a class, so it doesn't qualify for automatic synthesis of the Equatable or Hashable requirements. To make this class conform to the Equatable protocol, declare conformance in an extension and implement the static == operator method. Compare each significant property for equality in your == method's implementation: extension Player: Equatable { static func ==(lhs: Player, rhs: Player) -> Bool { return lhs.name == rhs.name && lhs.position == rhs.position } } To make Player conform to the Hashable protocol, declare conformance in another extension and implement the hash(into:) method. In the hash(into:) method, call the combine(_:) method on the provided hasher with each significant property: extension Player: Hashable { func hash(into hasher: inout Hasher) { hasher.combine(name) hasher.combine(position) } }","title":"Conform Manually to Equatable and Hashable"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/2.%E9%87%87%E7%94%A8%E5%85%B1%E5%90%8C%E5%8D%8F%E8%AE%AE-AdoptingCommonProtocols/#use-all-significant-properties-for-equatable-and-hashable","text":"When implementing the == method and the hash(into:) method, use all the properties that affect whether two instances of your custom type are considered equal. In the implementations above, the Player type uses name and position in both methods. If your type contains properties that don't affect whether two instances are considered equal, exclude those properties from comparison in the == method and from hashing in hash(into:). For example, a type might cache an expensive computed value so that it only needs to calculate it once. If you compare two instances of that type, whether or not the computed value has been cached shouldn't affect their equality, so the cached value should be excluded from comparison and hashing. Important Always use the same properties in both your == and hash(into:) methods. Using different groups of properties in the two methods can lead to unexpected behavior or performance when using your custom type in sets and dictionaries.","title":"Use All Significant Properties for Equatable and Hashable"},{"location":"Swift/2.%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-DataModeling/2.%E9%87%87%E7%94%A8%E5%85%B1%E5%90%8C%E5%8D%8F%E8%AE%AE-AdoptingCommonProtocols/#customize-nsobject-subclass-behavior","text":"NSObject subclasses inherit conformance to the Equatable and Hashable protocols, with equality based on instance identity. If you need to customize this behavior, override the isEqual(_:) method and hash property instead of the == operator method and hashValue property. extension MyNSObjectSubclass { override func isEqual(_ object: Any?) -> Bool { guard let other = object as? MyNSObjectSubclass else { return false } return self.firstProperty == other.firstProperty && self.secondProperty == other.secondProperty } override var hash: Int { var hasher = Hasher() hasher.combine(firstProperty) hasher.combine(secondProperty) return hasher.finalize() } } As noted in the previous section, two instances that are considered equal must have the same hash value. If you override one of these declarations, you must also override the other to maintain that guarantee.","title":"Customize NSObject Subclass Behavior"},{"location":"SwiftUI/0.swift%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/","text":"swift\u6587\u6863\u8bf4\u660e Essentials \u5fc5\u9700 UserInterface \u7528\u6237\u754c\u9762 DataAndEvents \u6570\u636e\u548c\u4e8b\u4ef6 PreviewsInXcode \u5728Xcode\u4e2d\u9884\u89c8","title":"swift\u6587\u6863\u8bf4\u660e"},{"location":"SwiftUI/0.swift%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/#swift","text":"Essentials \u5fc5\u9700 UserInterface \u7528\u6237\u754c\u9762 DataAndEvents \u6570\u636e\u548c\u4e8b\u4ef6 PreviewsInXcode \u5728Xcode\u4e2d\u9884\u89c8","title":"swift\u6587\u6863\u8bf4\u660e"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/1.%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%BB%84%E5%90%88%E8%A7%86%E5%9B%BE-CreatingAndCombiningViews/","text":"\u521b\u5efa\u5e76\u7ec4\u5408\u89c6\u56fe-CreatingAndCombiningViews \u672c\u6559\u7a0b\u5c06\u6307\u5bfc\u4f60\u6784\u5efa\u4e00\u4e2a\u7528\u4e8e\u53d1\u73b0\u548c\u5206\u4eab\u4f60\u6240\u559c\u7231\u5730\u65b9\u7684iOS\u5e94\u7528\u2014\u2014 \u201cLandmarks\u201d \u3002\u4f60\u5c06\u4ece\u6784\u5efa\u663e\u793a\u5730\u6807\u7ec6\u8282\u7684\u89c6\u56fe\u5f00\u59cb\u3002 \u4e3a\u4e86\u5e03\u7f6e\u89c6\u56fe\uff0c \u201cLandmarks\u201d \u4f7f\u7528 stacks \u6765\u7ec4\u5408\u548c\u5206\u5c42\u56fe\u50cf\u548c\u6587\u672c\u89c6\u56fe\u7ec4\u4ef6\u3002\u8981\u5728\u89c6\u56fe\u4e2d\u6dfb\u52a0\u5730\u56fe\uff0c\u4f60\u5c06\u5305\u542b\u4e00\u4e2a\u6807\u51c6\u7684 MapKit \u7ec4\u4ef6\u3002\u5f53\u60a8\u5b8c\u5584\u89c6\u56fe\u7684\u8bbe\u8ba1\u65f6\uff0cXcode\u4f1a\u63d0\u4f9b\u5b9e\u65f6\u53cd\u9988\uff0c\u8fd9\u6837\u60a8\u5c31\u53ef\u4ee5\u770b\u5230\u8fd9\u4e9b\u53d8\u5316\u662f\u5982\u4f55\u8f6c\u5316\u4e3a\u4ee3\u7801\u7684\u3002 \u4e0b\u8f7d\u9879\u76ee\u6587\u4ef6\u4ee5\u5f00\u59cb\u6784\u5efa\u8fd9\u4e2a\u9879\u76ee\uff0c\u5e76\u6309\u7167\u4ee5\u4e0b\u6b65\u9aa4\u8fdb\u884c\u3002 \u9879\u76ee\u6587\u4ef6\u4e0b\u8f7d This tutorial guides you through building_Landmarks\u2014 an iOS app for discovering and sharing the places you love. You\u2019ll start by building the view that shows a landmark\u2019s details. To lay out the views, Landmarks uses stacks to combine and layer the image and text view components. To add a map to the view, you\u2019ll include a standard MapKit component. As you refine the view\u2019s design, Xcode provides real-time feedback so you can see how those changes translate into code. Download the project files to begin building this project, and follow the steps below. \u521b\u5efa\u4e00\u4e2a\u65b0\u9879\u76ee\u5e76\u63a2\u7d22\u753b\u5e03-Create a New Project and Explore the Canvas \u521b\u5efa\u4e00\u4e2a\u4f7f\u7528SwiftUI\u7684\u65b0Xcode\u9879\u76ee\u3002\u63a2\u7d22\u753b\u5e03\u3001\u9884\u89c8\u548cSwiftUI\u6a21\u677f\u4ee3\u7801\u3002 \u8981\u5728Xcode\u4e2d\u9884\u89c8\u753b\u5e03\u5e76\u4e0e\u753b\u5e03\u4e2d\u7684\u89c6\u56fe\u8fdb\u884c\u4ea4\u4e92\uff0c\u8bf7\u786e\u4fdd\u60a8\u7684Mac\u6b63\u5728\u8fd0\u884cmacOS Catalina 10.15\u3002 Create a new Xcode project that uses SwiftUI. Explore the canvas, previews, and the SwiftUI template code. To preview and interact with views from the canvas in Xcode, ensure your Mac is running macOS Catalina 10.15. \u7b2c\u4e00\u6b65 \u6253\u5f00Xcode\uff0c\u5728Xcode\u7684\u542f\u52a8\u7a97\u53e3\u4e2d\u70b9\u51fb Create a new Xcode project \uff0c\u6216\u8005\u9009\u62e9 File > New > Project \u3002 \u7b2c\u4e8c\u6b65 \u5728\u6a21\u677f\u9009\u62e9\u5668\u4e2d\uff0c\u9009\u62e9 iOS \u4e3a\u5e73\u53f0\uff0c\u9009\u62e9 Single View App \u6a21\u677f\uff0c\u7136\u540e\u70b9\u51fb Next \u3002 \u7b2c\u4e09\u6b65 \u8f93\u5165 \"Landmarks \"\u4f5c\u4e3a\u5de5\u7a0b\u540d\u79f0\uff0c\u9009\u62e9 SwiftUI \u4f5c\u4e3a\u7528\u6237\u754c\u9762\uff0c\u7136\u540e\u70b9\u51fb Next \u3002\u5728Mac\u4e0a\u9009\u62e9\u4fdd\u5b58Landmarks\u9879\u76ee\u7684\u4f4d\u7f6e\u3002 \u7b2c\u56db\u6b65 \u5728\u9879\u76ee\u5bfc\u822a\u5668\u4e2d\uff0c\u9009\u62e9 ContentView.swift \u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cSwiftUI\u89c6\u56fe\u6587\u4ef6\u4f1a\u58f0\u660e\u4e24\u4e2a\u7ed3\u6784\u3002\u7b2c\u4e00\u4e2a\u7ed3\u6784\u7b26\u5408 View \u534f\u8bae\uff0c\u63cf\u8ff0\u4e86\u89c6\u56fe\u7684\u5185\u5bb9\u548c\u5e03\u5c40\u3002\u7b2c\u4e8c\u4e2a\u7ed3\u6784\u58f0\u660e\u4e86\u8be5\u89c6\u56fe\u7684\u9884\u89c8\u3002 import SwiftUI struct ContentView: View { var body: some View { Text(\"Hello World\") } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } \u7b2c\u4e94\u6b65 \u5728\u753b\u5e03\u4e2d\uff0c\u70b9\u51fb Resume(\u6062\u590d) \u663e\u793a\u9884\u89c8\u3002 \u6280\u5de7 \u5982\u679c\u753b\u5e03\u4e0d\u53ef\u89c1\uff0c\u9009\u62e9 Editor > Editor and Canvas \u6765\u663e\u793a\u5b83\u3002 \u7b2c\u516d\u6b65 \u5728 body property\u4e2d\uff0c\u5c06 \"Hello World \"\u6539\u4e3a\u81ea\u5df1\u7684\u95ee\u5019\u8bed\u3002 \u5f53\u60a8\u66f4\u6539\u89c6\u56fe\u7684 body \u5c5e\u6027\u4e2d\u7684\u4ee3\u7801\u65f6\uff0c\u9884\u89c8\u4f1a\u66f4\u65b0\u4ee5\u53cd\u6620\u4f60\u7684\u66f4\u6539\u3002 Step 1 Open Xcode and either click Create a new Xcode project in Xcode\u2019s startup window, or choose File > New > Project . Step 2 In the template selector, select iOS as the platform, select the Single View App template, and then click Next . Step 3 Enter \u201cLandmarks\u201d as the Product Name, select SwiftUI for the user interface, and click Next . Choose a location to save the Landmarks project on your Mac. Step 4 In the Project navigator, select ContentView.swift . By default, SwiftUI view files declare two structures. The first structure conforms to the View protocol and describes the view\u2019s content and layout. The second structure declares a preview for that view. Step 5 In the canvas, click Resume to display the preview. Tip If the canvas isn\u2019t visible, select Editor > Editor and Canvas to show it. Step 6 Inside the body property, change \u201cHello World\u201d to a greeting for yourself. As you change the code in a view\u2019s body property, the preview updates to reflect your changes. \u8bbe\u7f6e\u6587\u672c\u89c6\u56fe-Customize the Text View \u60a8\u53ef\u4ee5\u901a\u8fc7\u66f4\u6539\u4ee3\u7801\u6765\u5b9a\u5236\u89c6\u56fe\u7684\u663e\u793a\uff0c\u6216\u8005\u4f7f\u7528\u68c0\u67e5\u5668\u6765\u53d1\u73b0\u53ef\u7528\u7684\u5185\u5bb9\u5e76\u5e2e\u52a9\u60a8\u7f16\u5199\u4ee3\u7801\u3002 \u5f53\u4f60\u6784\u5efaLandmarks\u5e94\u7528\u65f6\uff0c\u4f60\u53ef\u4ee5\u7ed3\u5408\u4f7f\u7528\u4efb\u4f55\u4e00\u79cd\u7f16\u8f91\u5668\uff1a\u6e90\u7801\u7f16\u8f91\u5668\u3001\u753b\u5e03\u6216\u68c0\u67e5\u5668\u3002\u65e0\u8bba\u4f60\u4f7f\u7528\u54ea\u79cd\u5de5\u5177\uff0c\u4f60\u7684\u4ee3\u7801\u90fd\u4f1a\u4fdd\u6301\u66f4\u65b0\u3002 \u63a5\u4e0b\u6765\uff0c\u4f60\u5c06\u4f7f\u7528\u68c0\u67e5\u5668\u81ea\u5b9a\u4e49\u6587\u672c\u89c6\u56fe\u3002 You can customize a view\u2019s display by changing your code, or by using the inspector to discover what\u2019s available and to help you write code. As you build the Landmarks app, you can use any combination of editors: the source editor, the canvas, or the inspectors. Your code stays updated, regardless of which tool you use. Next, you\u2019ll customize the text view using the inspector. \u7b2c\u4e00\u6b65 \u5728\u9884\u89c8\u4e2d\uff0cCommand-\u70b9\u51fb\u95ee\u5019\u8bed\uff0c\u5f39\u51fa\u7ed3\u6784\u5316\u7f16\u8f91\u5f39\u7a97\uff0c\u9009\u62e9 Inspect\uff08\u68c0\u67e5\uff09 \u3002 \u8bd1\u8005\u6ce8 control-option-\u70b9\u51fb\u53ef\u4ee5\u76f4\u63a5\u6253\u5f00 Inspect \u5f39\u51fa\u5f0f\u83dc\u5355\u663e\u793a\u4e86\u4e0d\u540c\u7684\u5c5e\u6027\uff0c\u60a8\u53ef\u4ee5\u6839\u636e\u60a8\u68c0\u67e5\u7684\u89c6\u56fe\u7c7b\u578b\u8fdb\u884c\u81ea\u5b9a\u4e49\u3002 \u7b2c\u4e8c\u6b65 \u4f7f\u7528\u68c0\u67e5\u5668\u5c06\u6587\u672c\u66f4\u6539\u4e3a \"Turtle Rock\"\uff0c\u8fd9\u662f\u60a8\u5c06\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u663e\u793a\u7684\u7b2c\u4e00\u4e2a\u5730\u6807\u7684\u540d\u79f0\u3002 \u7b2c\u4e09\u6b65 \u5c06\u5b57\u4f53\u4fee\u9970\u7b26\u6539\u4e3a Title \u3002 \u8fd9\u5c06\u7cfb\u7edf\u5b57\u4f53\u5e94\u7528\u4e8e\u6587\u672c\uff0c\u4ee5\u4fbf\u5b83\u6b63\u786e\u54cd\u5e94\u7528\u6237\u7684\u9996\u9009\u5b57\u4f53\u5927\u5c0f\u548c\u8bbe\u7f6e\u3002 \u8981\u81ea\u5b9a\u4e49SwiftUI\u89c6\u56fe\uff0c\u4f60\u53ef\u4ee5\u8c03\u7528\u79f0\u4e3a \u4fee\u6539\u5668\uff08modifiers\uff09 \u7684\u65b9\u6cd5\u3002\u4fee\u6539\u5668\u5bf9\u89c6\u56fe\u8fdb\u884c\u5c01\u88c5\uff0c\u4ee5\u6539\u53d8\u5176\u663e\u793a\u6216\u5176\u4ed6\u5c5e\u6027\u3002\u6bcf\u4e00\u4e2a\u4fee\u6539\u5668\u90fd\u4f1a\u8fd4\u56de\u4e00\u4e2a\u65b0\u7684\u89c6\u56fe\uff0c\u6240\u4ee5\u901a\u5e38\u8fde\u7eed\u4f7f\u7528\u591a\u4e2a\u4fee\u6539\u5668\uff0c\u5e76\u5c06\u5b83\u4eec\u7eb5\u5411\u5806\u53e0\u3002 \u7b2c\u56db\u6b65 \u624b\u5de5\u7f16\u8f91\u4ee3\u7801\uff0c\u6dfb\u52a0 foregroundColor(.green) \u4fee\u6539\u5668\uff0c\u5c06\u6587\u5b57\u7684\u989c\u8272\u6539\u4e3a\u7eff\u8272\u3002 \u89c6\u56fe\u6c38\u8fdc\u662f\u4f60\u4ee3\u7801\u7684\u771f\u5b9e\u53cd\u6620\u3002\u5f53\u4f60\u4f7f\u7528\u68c0\u67e5\u5668\u66f4\u6539\u6216\u5220\u9664\u4e00\u4e2a\u4fee\u6539\u5668\u65f6\uff0cXcode\u4f1a\u7acb\u5373\u66f4\u65b0\u5e76\u5339\u914d\u4f60\u7684\u4ee3\u7801\u3002 \u7b2c\u4e94\u6b65 \u8fd9\u6b21\uff0c\u5728\u4ee3\u7801\u7f16\u8f91\u5668\u4e2d\u6309\u4e0bCommand-\u70b9\u51fb Text \uff0c\u6253\u5f00\u68c0\u67e5\u5668\uff0c\u7136\u540e\u4ece\u5f39\u51fa\u7684\u83dc\u5355\u4e2d\u9009\u62e9 Inspect \u3002\u70b9\u51fb Color \u5f39\u51fa\u83dc\u5355\uff0c\u9009\u62e9 Inherited\uff08\u7ee7\u627f\uff09 \uff0c\u5c06\u6587\u5b57\u989c\u8272\u518d\u6b21\u6539\u4e3a\u9ed1\u8272\u3002 \u7b2c\u516d\u6b65 \u6ce8\u610f\uff0cXcode\u4f1a\u81ea\u52a8\u66f4\u65b0\u4f60\u7684\u4ee3\u7801\u4ee5\u53cd\u6620\u53d8\u5316\uff0c\u5220\u9664 foregroundColor(.green) \u4fee\u6539\u5668\u3002 // // ContentView.swift // Landmarks // // Created by EchoSun on 2020/12/18. // import SwiftUI struct ContentView: View { var body: some View { Text(\"Turtle Rock\") .font(.title) } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } Next, you\u2019ll customize the text view using the inspector. Step 1 In the preview, Command-click the greeting to bring up the structured editing popover, and choose Inspect . The popover shows different attributes that you can customize, depending on the type of view you inspect. Step 2 Use the inspector to change the text to \u201cTurtle Rock\u201d, the name of the first landmark you\u2019ll show in your app. Step 3 Change the Font modifier to Title . This applies the system font to the text so that it responds correctly to the user\u2019s preferred font sizes and settings. To customize a SwiftUI view, you call methods called_modifiers_. Modifiers wrap a view to change its display or other properties. Each modifier returns a new view, so it\u2019s common to chain multiple modifiers, stacked vertically. Step 4 Edit the code by hand to add the foregroundColor(.green) modifier; this changes the text\u2019s color to green. Your code is always the source of truth for the view. When you use the inspector to change or remove a modifier, Xcode updates your code immediately to match. Step 5 This time, open the inspector by Command-clicking on the Text declaration in the code editor, and then choose Inspect from the popover. Click the Color pop-up menu and choose Inherited to change the text color to black again. Step 6 Notice that Xcode updates your code automatically to reflect the change, removing the foregroundColor(.green) modifier. \u4f7f\u7528\u5806\u6808\u7ec4\u5408\u89c6\u56fe-Combine Views Using Stacks \u9664\u4e86\u4e0a\u4e00\u8282\u4e2d\u521b\u5efa\u7684\u6807\u9898\u89c6\u56fe\u5916\uff0c\u60a8\u8fd8\u5c06\u6dfb\u52a0\u6587\u672c\u89c6\u56fe\u6765\u5305\u542b\u6709\u5173\u5730\u6807\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u4f8b\u5982\u516c\u56ed\u540d\u79f0\u548c\u5b83\u6240\u5904\u7684\u4f4d\u7f6e\u3002 \u5f53\u521b\u5efaSwiftUI\u89c6\u56fe\u65f6\uff0c\u60a8\u53ef\u4ee5\u5728\u89c6\u56fe\u7684 body \u5c5e\u6027\u4e2d\u63cf\u8ff0\u5b83\u7684\u5185\u5bb9\u3001\u5e03\u5c40\u548c\u884c\u4e3a\uff1b\u4f46\u662f\uff0c body \u5c5e\u6027\u53ea\u8fd4\u56de\u4e00\u4e2a\u89c6\u56fe\u3002\u60a8\u53ef\u4ee5\u5728 \u5806\u6808\uff08stacks\uff09 \u4e2d\u7ec4\u5408\u548c\u5d4c\u5165\u591a\u4e2a\u89c6\u56fe\uff0c\u5c06\u89c6\u56fe\u6c34\u5e73\u3001\u5782\u76f4\u6216\u4ece\u540e\u5230\u524d\u5730\u7ec4\u5408\u5728\u4e00\u8d77\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u4f60\u5c06\u4f7f\u7528\u6c34\u5e73\u5806\u6808\u653e\u7f6e\u516c\u56ed\u7684\u7ec6\u8282\uff0c\u5e76\u5c06\u5b83\u548c\u6807\u9898\u653e\u7f6e\u5230\u4e00\u4e2a\u5782\u76f4\u5806\u6808\u4e0a\u3002 Beyond the title view you created in the previous section, you\u2019ll add text views to contain details about the landmark, such as the name of the park and state it\u2019s in. When creating a SwiftUI view, you describe its content, layout, and behavior in the view\u2019s body property; however, the body property only returns a single view. You can combine and embed multiple views in stacks , which group views together horizontally, vertically, or back-to-front. In this section, you\u2019ll use a vertical stack to place the title above a horizontal stack that contains details about the park. \u60a8\u53ef\u4ee5\u4f7f\u7528Xcode\u7684\u7ed3\u6784\u5316\u7f16\u8f91\u652f\u6301\uff0c\u5c06\u4e00\u4e2a\u89c6\u56fe\u5d4c\u5165\u5230\u5bb9\u5668\u89c6\u56fe\u4e2d\uff0c\u6253\u5f00\u4e00\u4e2a\u68c0\u67e5\u5668\uff0c\u6216\u5e2e\u52a9\u8fdb\u884c\u5176\u4ed6\u6709\u7528\u7684\u66f4\u6539\u3002 \u7b2c1\u6b65 \u547d\u4ee4\u70b9\u51fb\u6587\u672c\u89c6\u56fe\u7684\u521d\u59cb\u5316\u5668\uff0c\u663e\u793a\u7ed3\u6784\u5316\u7f16\u8f91\u5f39\u51fa\u5668\uff0c\u7136\u540e\u9009\u62e9 Embed in VStack \u3002 \u63a5\u4e0b\u6765\uff0c\u4f60\u5c06\u901a\u8fc7\u4ece\u5e93\u4e2d\u62d6\u52a8\u4e00\u4e2a Text view\u6765\u6dfb\u52a0\u4e00\u4e2a\u6587\u672c\u89c6\u56fe\u5230\u5806\u6808\u4e2d\u3002 \u7b2c\u4e8c\u6b65 \u70b9\u51fbXcode\u7a97\u53e3\u53f3\u4e0a\u65b9\u7684\u52a0\u53f7\u6309\u94ae(+)\u6253\u5f00\u5e93\uff0c\u7136\u540e\u62d6\u52a8\u4e00\u4e2a Text \u7684view\u5230\u4ee3\u7801\u4e2d\u7d27\u6328\u7740 \"Turtle Rock \"\u6587\u672c\u89c6\u56fe\u7684\u5730\u65b9\u3002 \u8bd1\u8005\u6ce8 \u4f7f\u7528 library \u7a97\u53e3\u5feb\u901f\u6dfb\u52a0\u63a7\u4ef6\u7684\u5feb\u6377\u952e: \u21e7\u2318 L \u7b2c\u4e09\u6b65 \u5c06 Text \u7684\u5360\u4f4d\u6587\u5b57\u66ff\u6362\u4e3a Joshua Tree National Park \u3002 \u7136\u540e\u81ea\u5b9a\u4e49\u4f4d\u7f6e\u4ee5\u5339\u914d\u6240\u9700\u7684\u5e03\u5c40\u3002 \u7b2c\u56db\u6b65 \u5c06\u8be5\u4f4d\u7f6e\u7684\u5b57\u4f53\u8bbe\u7f6e\u4e3a subheadline \u3002 \u7b2c\u4e94\u6b65 \u7f16\u8f91 \"VStack \"\u521d\u59cb\u5316\u5668\u4f7f\u89c6\u56fe\u6cbf\u524d\u7f18\u5bf9\u9f50\u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5806\u6808\u5c06\u5176\u5185\u5bb9\u6cbf\u5176\u8f74\u7ebf\u5c45\u4e2d\uff0c\u5e76\u4e3a\u4e0a\u4e0b\u6587\u8bbe\u7f6e\u9002\u5f53\u7684\u95f4\u8ddd\u3002 \u63a5\u4e0b\u6765\uff0c\u60a8\u5c06\u5728\u4f4d\u7f6e\u7684\u53f3\u4fa7\u6dfb\u52a0\u53e6\u4e00\u4e2a\u6587\u672c\u89c6\u56fe\uff0c\u8fd9\u662f\u516c\u56ed\u7684\u4f4d\u7f6e\u3002 \u7b2c\u516d\u6b65 \u5728\u753b\u5e03\u4e2d\uff0c\u547d\u4ee4\u70b9\u51fb Joshua Tree National Park \uff0c\u5e76\u9009\u62e9 Embed in HStack\uff08\u5d4c\u5165\u5230HStack\u4e2d\uff09 \u3002 \u7b2c\u4e03\u6b65 \u5728\u4f4d\u7f6e\u540e\u9762\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u6587\u672c\u89c6\u56fe\uff0c\u5c06\u5360\u4f4d\u6587\u5b57\u6539\u4e3a\u516c\u56ed\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u5c06\u5176\u5b57\u4f53\u8bbe\u7f6e\u4e3a subheadline \u3002 \u7b2c\u516b\u6b65 \u4e3a\u4e86\u4f7f\u5e03\u5c40\u586b\u5145\u8bbe\u5907\u7684\u6574\u4e2a\u5bbd\u5ea6\uff0c\u6211\u4eec\u5728\u5305\u542b\u4e24\u4e2a\u6587\u672c\u89c6\u56fe\u7684\u6c34\u5e73\u5806\u6808\u4e2d\u6dfb\u52a0\u4e00\u4e2a \"\u95f4\u9694\u5668 \uff08Spacer\uff09\"\u6765\u5206\u79bb\u516c\u56ed\u548c\u4f4d\u7f6e\u3002 \u95f4\u9694\u5668 \uff08Spacer\uff09 \u5c06\u5360\u636e\u5176\u7236\u89c6\u56fe\u7684\u6240\u6709\u7a7a\u95f4\uff0c\u800c\u4e0d\u662f\u4ec5\u7531\u5176\u5185\u5bb9\u51b3\u5b9a\u5176\u5927\u5c0f\u3002 \u7b2c\u4e5d\u6b65 \u6700\u540e\uff0c\u4f7f\u7528 padding() \u4fee\u6539\u5668\u65b9\u6cd5\u7ed9\u5730\u6807\u7684\u540d\u79f0\u548c\u7ec6\u8282\u591a\u4e00\u70b9\u7a7a\u95f4\u3002 // // ContentView.swift // Landmarks // // Created by EchoSun on 2020/12/18. // import SwiftUI struct ContentView: View { var body: some View { VStack(alignment: .leading) { Text(\"Turtle Rock\") .font(.title) HStack { Text(\"Joshua Tree National Park\") .font(.subheadline) Spacer() Text(\"California\") .font(.subheadline) } } .padding() // \u589e\u52a0\u56db\u5468\u7684\u7a7a\u95f4 } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } You can use Xcode\u2019s structured editing support to embed a view in a container view, open an inspector, or help with other useful changes. Step 1 Command-click the text view\u2019s initializer to show the structured editing popover, and then choose Embed in VStack . Next, you\u2019ll add a text view to the stack by dragging a Text view from the library. Step 2 Open the library by clicking the plus button (+) at the top-right of the Xcode window, and then drag a Text view to the place in your code immediately after the \u201cTurtle Rock\u201d text view. Step 3 Replace the Text view\u2019s placeholder text with Joshua Tree National Park . Customize the location to match the desired layout. Step 4 Set the location\u2019s font to subheadline . Step 5 Edit the VStack initializer to align the views by their leading edges. By default, stacks center their contents along their axis and provide context-appropriate spacing. Next, you\u2019ll add another text view to the right of the location, this for the park\u2019s state. Step 6 In the canvas, Command-click Joshua Tree National Park , and choose Embed in HStack . Step 7 Add a new text view after the location, change the placeholder text to the park\u2019s state, and then set its font to subheadline . Step 8 To direct the layout to use the full width of the device, separate the park and the state by adding a Spacer to the horizontal stack holding the two text views. A spacer expands to make its containing view use all of the space of its parent view, instead of having its size defined only by its contents. Step 9 Finally, use the padding() modifier method to give the landmark\u2019s name and details a little more space. \u521b\u5efa\u56fe\u7247\u89c6\u56fe-Create a Custom Image View \u540d\u79f0\u548c\u4f4d\u7f6e\u89c6\u56fe\u90fd\u8bbe\u7f6e\u597d\u4e86\uff0c\u4e0b\u4e00\u6b65\u5c31\u662f\u4e3a\u5730\u6807\u6dfb\u52a0\u56fe\u50cf\u3002 \u5728\u8fd9\u4e2a\u6587\u4ef6\u4e2d\uff0c\u60a8\u5c06\u521b\u5efa\u4e00\u4e2a\u81ea\u5b9a\u4e49\u89c6\u56fe\uff0c\u4e3a\u56fe\u50cf\u5e94\u7528\u906e\u7f69\u3001\u8fb9\u6846\u548c\u9634\u5f71\uff0c\u800c\u4e0d\u662f\u6dfb\u52a0\u66f4\u591a\u4ee3\u7801\u3002 With the name and location views all set, the next step is to add an image for the landmark. Instead of adding more code in this file, you\u2019ll create a custom view that applies a mask, border, and drop shadow to the image. \u4ece\u6dfb\u52a0\u56fe\u50cf\u5230\u9879\u76ee\u7684\u8d44\u4ea7\u76ee\u5f55\u5f00\u59cb\u3002 \u7b2c\u4e00\u6b65 \u5728\u9879\u76ee\u6587\u4ef6\u7684 Resources(\u8d44\u6e90) \u6587\u4ef6\u5939\u4e2d\u627e\u5230 turtlerock.png \uff0c\u5e76\u5c06\u5176\u62d6\u5165\u8d44\u4ea7\uff08Assets\uff09\u76ee\u5f55\u7684\u7f16\u8f91\u5668\u4e2d\u3002Xcode\u5c06\u4e3a\u8be5\u56fe\u50cf\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u56fe\u50cf\u96c6\u3002 \u63a5\u4e0b\u6765\uff0c\u4f60\u5c06\u4e3a\u4f60\u7684\u81ea\u5b9a\u4e49\u56fe\u50cf\u89c6\u56fe\u521b\u5efa\u4e00\u4e2a\u65b0\u7684SwiftUI\u89c6\u56fe\u3002 \u7b2c\u4e8c\u6b65 \u9009\u62e9 File > New > File \uff0c\u518d\u6b21\u6253\u5f00\u6a21\u677f\u9009\u62e9\u5668\u3002\u5728 User Interface \u90e8\u5206\uff0c\u9009\u62e9 SwiftUI View \uff0c\u70b9\u51fb Next \u3002\u5c06\u6587\u4ef6\u547d\u540d\u4e3a CircleImage.swift \u5e76\u70b9\u51fb Create \u3002 \u4f60\u5df2\u7ecf\u51c6\u5907\u597d\u63d2\u5165\u56fe\u7247\u5e76\u4fee\u6539\u5176\u663e\u793a\u65b9\u5f0f\u4ee5\u7b26\u5408\u6240\u9700\u7684\u8bbe\u8ba1\u3002 \u7b2c\u4e09\u6b65 \u4f7f\u7528 Image(_:) \u521d\u59cb\u5316\u5668\u5c06\u6587\u672c\u89c6\u56fe\u66ff\u6362\u4e3aTurtle Rock\u7684\u56fe\u50cf\u3002 \u7b2c\u56db\u6b65 \u6dfb\u52a0\u4e00\u4e2a clipShape(Circle()) \uff0c\u5728\u56fe\u50cf\u4e0a\u526a\u88c1\u51fa\u4e00\u4e2a\u5706\u5f62\u3002 Circle \u7c7b\u578b\u662f\u4e00\u4e2a\u5f62\u72b6\uff0c\u4f60\u53ef\u4ee5\u7528\u5b83\u6765\u505a\u8499\u7248\uff0c\u6216\u8005\u901a\u8fc7\u7ed9\u5706\u5708\u4e00\u4e2a\u63cf\u8fb9\u6216\u586b\u5145\u6765\u505a\u89c6\u56fe\u3002 \u7b2c\u4e94\u6b65 \u7528\u7070\u8272\u7b14\u89e6\u521b\u5efa\u53e6\u4e00\u4e2a\u5706\u5708\uff0c\u7136\u540e\u5c06\u5176\u6dfb\u52a0\u4e3a\u53e0\u52a0\uff0c\u7ed9\u56fe\u50cf\u4e00\u4e2a\u8fb9\u6846\u3002 \u7b2c\u516d\u6b65 \u63a5\u4e0b\u6765\uff0c\u6dfb\u52a0\u4e00\u4e2a\u534a\u5f84\u4e3a10\u70b9\u7684\u9634\u5f71\u3002 \u7b2c\u4e03\u6b65 \u5c06\u8fb9\u6846\u989c\u8272\u5207\u6362\u4e3a\u767d\u8272\u3002 \u8fd9\u6837\u5c31\u5b8c\u6210\u4e86\u56fe\u50cf\u89c6\u56fe\u3002 // // CircleImage.swift.swift // Landmarks // // Created by EchoSun on 2020/12/18. // import SwiftUI struct CircleImage: View { var body: some View { Image(\"turtlerock\") .clipShape(Circle()) .overlay(Circle().stroke(Color.white, lineWidth: 4)) .shadow(radius: 10) } } struct CircleImage_Previews: PreviewProvider { static var previews: some View { CircleImage() } } Start by adding an image to the project\u2019s asset catalog. Step 1 Find turtlerock.png in the project files\u2019 Resources folder; drag it into the asset catalog\u2019s editor. Xcode creates a new image set for the image. Next, you\u2019ll create a new SwiftUI view for your custom image view. Step 2 Choose File > New > File to open the template selector again. In the User Interface section, select SwiftUI View and click Next . Name the file CircleImage.swift and click Create . You\u2019re ready to insert the image and modify its display to match the desired design. Step 3 Replace the text view with the image of Turtle Rock by using the Image(_:) initializer. Step 4 Add a call to clipShape(Circle()) to apply the circular clipping shape to the image. The Circle type is a shape that you can use as a mask, or as a view by giving the circle a stroke or fill. Step 5 Create another circle with a gray stroke, and then add it as an overlay to give the image a border. Step 6 Next, add a shadow with a 10 point radius. Step 7 Switch the border color to white. This completes the image view. \u540c\u65f6\u4f7f\u7528UIKit\u548cSwiftUI\u89c6\u56fe-Use UIKit and SwiftUI Views Together \u73b0\u5728\u4f60\u5df2\u7ecf\u51c6\u5907\u597d\u521b\u5efa\u4e00\u4e2a\u5730\u56fe\u89c6\u56fe\u4e86\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528MapKit\u7684 MKMapView \u7c7b\u6765\u6e32\u67d3\u5730\u56fe\u3002 \u8981\u5728SwiftUI\u4e2d\u4f7f\u7528 UIView \u5b50\u7c7b\uff0c\u4f60\u53ef\u4ee5\u5c06\u5176\u4ed6\u89c6\u56fe\u5305\u88f9\u5728\u7b26\u5408 UIViewRepresentable \u534f\u8bae\u7684SwiftUI\u89c6\u56fe\u4e2d\u3002SwiftUI\u5305\u62ec\u7c7b\u4f3c\u7684WatchKit\u548cAppKit\u89c6\u56fe\u7684\u534f\u8bae\u3002 Now you\u2019re ready to create a map view. You can use the MKMapView class from MapKit to render the map. To use UIView subclasses from within SwiftUI, you wrap the other view in a SwiftUI view that conforms to the UIViewRepresentable protocol. SwiftUI includes similar protocols for WatchKit and AppKit views. \u8981\u5f00\u59cb\uff0c\u4f60\u5c06\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\uff0c\u53ef\u4ee5\u5448\u73b0\u4e00\u4e2a MKMapView \u3002 \u7b2c\u4e00\u6b65 \u9009\u62e9 File > New > File \uff0c\u9009\u62e9 iOS \u4e3a\u5e73\u53f0\uff0c\u9009\u62e9 SwiftUI View \u6a21\u677f\uff0c\u70b9\u51fb Next \u3002\u5c06\u65b0\u6587\u4ef6\u547d\u540d\u4e3a MapView.swift \uff0c\u70b9\u51fb Create \u3002 \u7b2c\u4e8c\u6b65 \u4e3aMapKit\u6dfb\u52a0\u4e00\u4e2a import \u8bed\u53e5\uff0c\u5e76\u4e3a MapView \u7c7b\u578b\u58f0\u660e UIViewRepresentable \u7684\u4e00\u81f4\u6027\uff08conformance\uff09\u3002 \u4e0d\u8981\u62c5\u5fc3Xcode\u663e\u793a\u7684\u9519\u8bef\uff1b\u4f60\u5c06\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u4e2a\u6b65\u9aa4\u4e2d\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 UIViewRepresentable \u534f\u8bae\u6709\u4e24\u4e2a\u9700\u6c42\u4f60\u9700\u8981\u6dfb\u52a0\uff1a\u4e00\u4e2a makeUIView(context:) \u65b9\u6cd5\u521b\u5efa MKMapView \uff0c\u4e00\u4e2a updateUIView(_:context:) \u65b9\u6cd5\u914d\u7f6e\u5e76\u76f8\u5e94\u89c6\u56fe\u7684\u66f4\u65b0\u3002 \u7b2c\u4e09\u6b65 \u7528 makeUIView(context: Context) \u65b9\u6cd5\u66ff\u6362 body \u5c5e\u6027\uff0c\u521b\u5efa\u5e76\u8fd4\u56de\u4e00\u4e2a\u7a7a\u7684 MKMapView \u3002 \u7b2c\u56db\u6b65 \u521b\u5efa\u4e00\u4e2a updateUIView(_:context:) \u65b9\u6cd5\uff0c\u5c06\u5730\u56fe\u89c6\u56fe\u7684\u4f4d\u7f6e\u8bbe\u7f6e\u4e3a\u6b63\u786e\u7684\u5750\u6807\uff0c\u4f7f\u5730\u56fe\u4ee5Turtle Rock\u4e3a\u4e2d\u5fc3\u3002 \u5f53\u9884\u89c8\u5904\u4e8e\u9759\u6001\u6a21\u5f0f\u65f6\uff0c\u53ea\u80fd\u5b8c\u5168\u6e32\u67d3SwiftUI\u89c6\u56fe\u3002\u56e0\u4e3a MKMapView \u662f\u4e00\u4e2a UIView \u5b50\u7c7b\uff0c\u6240\u4ee5\u4f60\u9700\u8981\u5207\u6362\u5230\u5b9e\u65f6\u9884\u89c8\u6765\u67e5\u770b\u5730\u56fe\u3002 \u7b2c\u4e94\u6b65 \u70b9\u51fb \u76f4\u64ad\u9884\u89c8 \u6309\u94ae\uff0c\u5c06\u9884\u89c8\u5207\u6362\u5230\u76f4\u64ad\u6a21\u5f0f\u3002\u60a8\u53ef\u80fd\u9700\u8981\u70b9\u51fb\u9884\u89c8\u4e0a\u65b9\u7684 Try Again \u6216 Resume \u6309\u94ae\u3002 \u4e00\u4f1a\u513f\uff0c\u4f60\u5c31\u4f1a\u770b\u5230Joshua Tree\u56fd\u5bb6\u516c\u56ed\u7684\u5730\u56fe\uff0c\u4e5f\u5c31\u662fTurtle Rock\u7684\u6240\u5728\u5730\u3002 // // MapView.swift // Landmarks // // Created by EchoSun on 2020/12/18. // import SwiftUI import MapKit struct MapView: UIViewRepresentable { // \u521b\u5efa`MKMapView` func makeUIView(context: Context) -> MKMapView { MKMapView(frame: .zero) } // \u914d\u7f6e\u5e76\u76f8\u5e94\u89c6\u56fe\u7684\u66f4\u65b0 func updateUIView(_ uiView: MKMapView, context: Context) { let coordinate = CLLocationCoordinate2D( latitude: 34.011286, longitude: -116.166868) let span = MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0) let region = MKCoordinateRegion(center: coordinate, span: span) uiView.setRegion(region, animated: true) } } struct MapView_Previews: PreviewProvider { static var previews: some View { MapView() } } To get started, you\u2019ll create a new custom view that can present an MKMapView . Step 1 Choose File > New > File , select iOS as the platform, select the SwiftUI View template, and click Next . Name the new file MapView.swift and click Create . Step 2 Add an import statement for MapKit , and declare UIViewRepresentable conformance for the MapView type. Don\u2019t worry about the error that Xcode displays; you\u2019ll fix that in the next few steps. The UIViewRepresentable protocol has two requirements you need to add: a makeUIView(context:) method that creates an MKMapView , and an updateUIView(_:context:) method that configures the view and responds to any changes. Step 3 Replace the body property with a makeUIView(context:) method that creates and returns an empty MKMapView . Step 4 Create an updateUIView(_:context:) method that sets the map view\u2019s region to the correct coordinates to center the map on Turtle Rock. When previews are in static mode, they only fully render SwiftUI views. Because MKMapView is a UIView subclass, you\u2019ll need to switch to a live preview to see the map. Step 5 Click the Live Preview button to switch the preview to live mode. You might need to click the Try Again or Resume button above your preview. In a moment, you\u2019ll see a map of Joshua Tree National Park, home of Turtle Rock. \u7ec4\u6210\u8be6\u7ec6\u89c6\u56fe-Compose the Detail View \u73b0\u5728\uff0c\u60a8\u5df2\u7ecf\u62e5\u6709\u4e86\u6240\u9700\u7684\u6240\u6709\u7ec4\u4ef6\u2014\u2014\u540d\u79f0\u548c\u5730\u70b9\u3001\u5706\u5f62\u56fe\u50cf\u4ee5\u53ca\u4f4d\u7f6e\u7684\u5730\u56fe\u3002 \u5229\u7528\u60a8\u8fc4\u4eca\u4e3a\u6b62\u4f7f\u7528\u7684\u5de5\u5177\uff0c\u7ed3\u5408\u60a8\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\uff0c\u521b\u5efa\u5730\u6807\u7ec6\u8282\u89c6\u56fe\u7684\u6700\u7ec8\u8bbe\u8ba1\u3002 You now have all of the components you need \u2014 the name and place, a circular image, and a map for the location. With the tools you\u2019ve used so far, combine your custom views to create the final design for the landmark detail view. \u7b2c\u4e00\u6b65 \u5728\u9879\u76ee\u5bfc\u822a\u4e2d\uff0c\u9009\u62e9 ContentView.swift \u6587\u4ef6\u3002 \u7b2c\u4e8c\u6b65 \u5728\u5916\u90e8\u5d4c\u5165\u4e00\u4e2a VStack \uff0c\u4f7f\u5185\u90e8\u7684 VStack \u5bb9\u7eb3\u4e09\u4e2a\u6587\u672c\u89c6\u56fe\u3002 \u7b2c\u4e09\u6b65 \u5c06\u4f60\u7684\u81ea\u5b9a\u4e49 MapView \u6dfb\u52a0\u5230\u5806\u6808\u7684\u9876\u90e8\u3002\u5e76\u4f7f\u7528 frame(width:height:) \u8bbe\u7f6e MapView \u7684\u5927\u5c0f\u3002 \u5f53\u4f60\u53ea\u6307\u5b9a \"height \"\u53c2\u6570\u65f6\uff0c\u89c6\u56fe\u4f1a\u81ea\u52a8\u8c03\u6574\u4e3a\u5176\u5185\u5bb9\u7684\u5bbd\u5ea6\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\"MapView \"\u5c06\u5c55\u5f00\u4ee5\u586b\u5145\u53ef\u7528\u7a7a\u95f4\u3002 \u7b2c\u56db\u6b65 \u70b9\u51fb Live Preview \u6309\u94ae\uff0c\u53ef\u5728\u5408\u6210\u89c6\u56fe\u4e2d\u67e5\u770b\u6e32\u67d3\u7684\u5730\u56fe\u3002 \u60a8\u53ef\u4ee5\u5728\u663e\u793a\u5b9e\u65f6\u9884\u89c8\u7684\u540c\u65f6\u7ee7\u7eed\u7f16\u8f91\u89c6\u56fe\u3002 \u7b2c\u4e94\u6b65 \u5c06 CircleImage \u89c6\u56fe\u6dfb\u52a0\u5230\u5806\u6808\u4e2d\u3002 \u7b2c\u516d\u6b65\uff1a\u5c06 CircleImage \u89c6\u56fe\u6dfb\u52a0\u5230\u5806\u6808\u4e2d\u3002 \u8981\u5728\u5730\u56fe\u89c6\u56fe\u7684\u57fa\u7840\u4e0a\u53e0\u52a0\u56fe\u50cf\u89c6\u56fe\uff0c\u9700\u8981\u5728\u7eb5\u5411\u4e0a\u7ed9\u56fe\u50cf\u4e00\u4e2a-130\u70b9\u7684\u504f\u79fb\uff0c\u5e76\u5728\u56fe\u50cf\u89c6\u56fe\u5e95\u90e8\u7ed9\u56fe\u50cf\u4e00\u4e2a-130\u70b9\u7684\u586b\u5145\u3002 \u8fd9\u4e9b\u8c03\u6574\u901a\u8fc7\u5411\u4e0a\u79fb\u52a8\u56fe\u50cf\u6765\u4e3a\u6587\u5b57\u817e\u51fa\u7a7a\u95f4\u3002 \u7b2c\u4e03\u6b65 \u5728\u5916\u5c42 \"VStack \"\u7684\u5e95\u90e8\u6dfb\u52a0\u4e00\u4e2a Spacer \uff0c\u5c06\u5185\u5bb9\u63a8\u5230\u5c4f\u5e55\u9876\u90e8\u3002 \u7b2c\u516b\u6b65 \u6700\u540e\uff0c\u4e3a\u4e86\u8ba9\u5730\u56fe\u5185\u5bb9\u5ef6\u4f38\u5230\u5c4f\u5e55\u7684\u9876\u90e8\u8fb9\u7f18\uff0c\u5728\u5730\u56fe\u89c6\u56fe\u4e2d\u6dfb\u52a0 edgesIgnoringSafeArea(.top) \u4fee\u6539\u5668\u3002 \u8bd1\u8005\u6ce8 // // ContentView.swift // Landmarks // // Created by EchoSun on 2020/12/18. // import SwiftUI struct ContentView: View { var body: some View { VStack { MapView() .edgesIgnoringSafeArea(.top) .frame(height:300) CircleImage() .offset(y: -130) .padding(.bottom, -130) VStack(alignment: .leading) { Text(\"Turtle Rock\") .font(.title) HStack { Text(\"Joshua Tree National Park\") .font(.subheadline) Spacer() Text(\"California\") .font(.subheadline) } } .padding() Spacer() } } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } Step 1 In the Project navigator, select the ContentView.swift file. Step 2 Embed a VStack that holds the three text views in another VStack . Step 3 Add your custom MapView to the top of the stack. Set the size of the MapView with frame(width:height:) . When you specify only the height parameter, the view automatically sizes to the width of its content. In this case, MapView expands to fill the available space. Step 4 Click the Live Preview button to see the rendered map in the composed view. You can continue editing the view while showing a Live Preview. Step 5 Add the CircleImage view to the stack. Step 6 To layer the image view on top of the map view, give the image an offset of -130 points vertically, and padding of -130 points from the bottom of the view. These adjustments make room for the text by moving the image upwards. Step 7 Add a spacer at the bottom of the outer VStack to push the content to the top of the screen. Step 8 Finally, to allow the map content to extend to the top edge of the screen, add the edgesIgnoringSafeArea(.top) modifier to the map view.","title":"\u521b\u5efa\u5e76\u7ec4\u5408\u89c6\u56fe-CreatingAndCombiningViews"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/1.%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%BB%84%E5%90%88%E8%A7%86%E5%9B%BE-CreatingAndCombiningViews/#-creatingandcombiningviews","text":"\u672c\u6559\u7a0b\u5c06\u6307\u5bfc\u4f60\u6784\u5efa\u4e00\u4e2a\u7528\u4e8e\u53d1\u73b0\u548c\u5206\u4eab\u4f60\u6240\u559c\u7231\u5730\u65b9\u7684iOS\u5e94\u7528\u2014\u2014 \u201cLandmarks\u201d \u3002\u4f60\u5c06\u4ece\u6784\u5efa\u663e\u793a\u5730\u6807\u7ec6\u8282\u7684\u89c6\u56fe\u5f00\u59cb\u3002 \u4e3a\u4e86\u5e03\u7f6e\u89c6\u56fe\uff0c \u201cLandmarks\u201d \u4f7f\u7528 stacks \u6765\u7ec4\u5408\u548c\u5206\u5c42\u56fe\u50cf\u548c\u6587\u672c\u89c6\u56fe\u7ec4\u4ef6\u3002\u8981\u5728\u89c6\u56fe\u4e2d\u6dfb\u52a0\u5730\u56fe\uff0c\u4f60\u5c06\u5305\u542b\u4e00\u4e2a\u6807\u51c6\u7684 MapKit \u7ec4\u4ef6\u3002\u5f53\u60a8\u5b8c\u5584\u89c6\u56fe\u7684\u8bbe\u8ba1\u65f6\uff0cXcode\u4f1a\u63d0\u4f9b\u5b9e\u65f6\u53cd\u9988\uff0c\u8fd9\u6837\u60a8\u5c31\u53ef\u4ee5\u770b\u5230\u8fd9\u4e9b\u53d8\u5316\u662f\u5982\u4f55\u8f6c\u5316\u4e3a\u4ee3\u7801\u7684\u3002 \u4e0b\u8f7d\u9879\u76ee\u6587\u4ef6\u4ee5\u5f00\u59cb\u6784\u5efa\u8fd9\u4e2a\u9879\u76ee\uff0c\u5e76\u6309\u7167\u4ee5\u4e0b\u6b65\u9aa4\u8fdb\u884c\u3002 \u9879\u76ee\u6587\u4ef6\u4e0b\u8f7d This tutorial guides you through building_Landmarks\u2014 an iOS app for discovering and sharing the places you love. You\u2019ll start by building the view that shows a landmark\u2019s details. To lay out the views, Landmarks uses stacks to combine and layer the image and text view components. To add a map to the view, you\u2019ll include a standard MapKit component. As you refine the view\u2019s design, Xcode provides real-time feedback so you can see how those changes translate into code. Download the project files to begin building this project, and follow the steps below.","title":"\u521b\u5efa\u5e76\u7ec4\u5408\u89c6\u56fe-CreatingAndCombiningViews"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/1.%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%BB%84%E5%90%88%E8%A7%86%E5%9B%BE-CreatingAndCombiningViews/#-create-a-new-project-and-explore-the-canvas","text":"\u521b\u5efa\u4e00\u4e2a\u4f7f\u7528SwiftUI\u7684\u65b0Xcode\u9879\u76ee\u3002\u63a2\u7d22\u753b\u5e03\u3001\u9884\u89c8\u548cSwiftUI\u6a21\u677f\u4ee3\u7801\u3002 \u8981\u5728Xcode\u4e2d\u9884\u89c8\u753b\u5e03\u5e76\u4e0e\u753b\u5e03\u4e2d\u7684\u89c6\u56fe\u8fdb\u884c\u4ea4\u4e92\uff0c\u8bf7\u786e\u4fdd\u60a8\u7684Mac\u6b63\u5728\u8fd0\u884cmacOS Catalina 10.15\u3002 Create a new Xcode project that uses SwiftUI. Explore the canvas, previews, and the SwiftUI template code. To preview and interact with views from the canvas in Xcode, ensure your Mac is running macOS Catalina 10.15. \u7b2c\u4e00\u6b65 \u6253\u5f00Xcode\uff0c\u5728Xcode\u7684\u542f\u52a8\u7a97\u53e3\u4e2d\u70b9\u51fb Create a new Xcode project \uff0c\u6216\u8005\u9009\u62e9 File > New > Project \u3002 \u7b2c\u4e8c\u6b65 \u5728\u6a21\u677f\u9009\u62e9\u5668\u4e2d\uff0c\u9009\u62e9 iOS \u4e3a\u5e73\u53f0\uff0c\u9009\u62e9 Single View App \u6a21\u677f\uff0c\u7136\u540e\u70b9\u51fb Next \u3002 \u7b2c\u4e09\u6b65 \u8f93\u5165 \"Landmarks \"\u4f5c\u4e3a\u5de5\u7a0b\u540d\u79f0\uff0c\u9009\u62e9 SwiftUI \u4f5c\u4e3a\u7528\u6237\u754c\u9762\uff0c\u7136\u540e\u70b9\u51fb Next \u3002\u5728Mac\u4e0a\u9009\u62e9\u4fdd\u5b58Landmarks\u9879\u76ee\u7684\u4f4d\u7f6e\u3002 \u7b2c\u56db\u6b65 \u5728\u9879\u76ee\u5bfc\u822a\u5668\u4e2d\uff0c\u9009\u62e9 ContentView.swift \u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cSwiftUI\u89c6\u56fe\u6587\u4ef6\u4f1a\u58f0\u660e\u4e24\u4e2a\u7ed3\u6784\u3002\u7b2c\u4e00\u4e2a\u7ed3\u6784\u7b26\u5408 View \u534f\u8bae\uff0c\u63cf\u8ff0\u4e86\u89c6\u56fe\u7684\u5185\u5bb9\u548c\u5e03\u5c40\u3002\u7b2c\u4e8c\u4e2a\u7ed3\u6784\u58f0\u660e\u4e86\u8be5\u89c6\u56fe\u7684\u9884\u89c8\u3002 import SwiftUI struct ContentView: View { var body: some View { Text(\"Hello World\") } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } \u7b2c\u4e94\u6b65 \u5728\u753b\u5e03\u4e2d\uff0c\u70b9\u51fb Resume(\u6062\u590d) \u663e\u793a\u9884\u89c8\u3002 \u6280\u5de7 \u5982\u679c\u753b\u5e03\u4e0d\u53ef\u89c1\uff0c\u9009\u62e9 Editor > Editor and Canvas \u6765\u663e\u793a\u5b83\u3002 \u7b2c\u516d\u6b65 \u5728 body property\u4e2d\uff0c\u5c06 \"Hello World \"\u6539\u4e3a\u81ea\u5df1\u7684\u95ee\u5019\u8bed\u3002 \u5f53\u60a8\u66f4\u6539\u89c6\u56fe\u7684 body \u5c5e\u6027\u4e2d\u7684\u4ee3\u7801\u65f6\uff0c\u9884\u89c8\u4f1a\u66f4\u65b0\u4ee5\u53cd\u6620\u4f60\u7684\u66f4\u6539\u3002 Step 1 Open Xcode and either click Create a new Xcode project in Xcode\u2019s startup window, or choose File > New > Project . Step 2 In the template selector, select iOS as the platform, select the Single View App template, and then click Next . Step 3 Enter \u201cLandmarks\u201d as the Product Name, select SwiftUI for the user interface, and click Next . Choose a location to save the Landmarks project on your Mac. Step 4 In the Project navigator, select ContentView.swift . By default, SwiftUI view files declare two structures. The first structure conforms to the View protocol and describes the view\u2019s content and layout. The second structure declares a preview for that view. Step 5 In the canvas, click Resume to display the preview. Tip If the canvas isn\u2019t visible, select Editor > Editor and Canvas to show it. Step 6 Inside the body property, change \u201cHello World\u201d to a greeting for yourself. As you change the code in a view\u2019s body property, the preview updates to reflect your changes.","title":"\u521b\u5efa\u4e00\u4e2a\u65b0\u9879\u76ee\u5e76\u63a2\u7d22\u753b\u5e03-Create a New Project and Explore the Canvas"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/1.%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%BB%84%E5%90%88%E8%A7%86%E5%9B%BE-CreatingAndCombiningViews/#-customize-the-text-view","text":"\u60a8\u53ef\u4ee5\u901a\u8fc7\u66f4\u6539\u4ee3\u7801\u6765\u5b9a\u5236\u89c6\u56fe\u7684\u663e\u793a\uff0c\u6216\u8005\u4f7f\u7528\u68c0\u67e5\u5668\u6765\u53d1\u73b0\u53ef\u7528\u7684\u5185\u5bb9\u5e76\u5e2e\u52a9\u60a8\u7f16\u5199\u4ee3\u7801\u3002 \u5f53\u4f60\u6784\u5efaLandmarks\u5e94\u7528\u65f6\uff0c\u4f60\u53ef\u4ee5\u7ed3\u5408\u4f7f\u7528\u4efb\u4f55\u4e00\u79cd\u7f16\u8f91\u5668\uff1a\u6e90\u7801\u7f16\u8f91\u5668\u3001\u753b\u5e03\u6216\u68c0\u67e5\u5668\u3002\u65e0\u8bba\u4f60\u4f7f\u7528\u54ea\u79cd\u5de5\u5177\uff0c\u4f60\u7684\u4ee3\u7801\u90fd\u4f1a\u4fdd\u6301\u66f4\u65b0\u3002 \u63a5\u4e0b\u6765\uff0c\u4f60\u5c06\u4f7f\u7528\u68c0\u67e5\u5668\u81ea\u5b9a\u4e49\u6587\u672c\u89c6\u56fe\u3002 You can customize a view\u2019s display by changing your code, or by using the inspector to discover what\u2019s available and to help you write code. As you build the Landmarks app, you can use any combination of editors: the source editor, the canvas, or the inspectors. Your code stays updated, regardless of which tool you use. Next, you\u2019ll customize the text view using the inspector. \u7b2c\u4e00\u6b65 \u5728\u9884\u89c8\u4e2d\uff0cCommand-\u70b9\u51fb\u95ee\u5019\u8bed\uff0c\u5f39\u51fa\u7ed3\u6784\u5316\u7f16\u8f91\u5f39\u7a97\uff0c\u9009\u62e9 Inspect\uff08\u68c0\u67e5\uff09 \u3002 \u8bd1\u8005\u6ce8 control-option-\u70b9\u51fb\u53ef\u4ee5\u76f4\u63a5\u6253\u5f00 Inspect \u5f39\u51fa\u5f0f\u83dc\u5355\u663e\u793a\u4e86\u4e0d\u540c\u7684\u5c5e\u6027\uff0c\u60a8\u53ef\u4ee5\u6839\u636e\u60a8\u68c0\u67e5\u7684\u89c6\u56fe\u7c7b\u578b\u8fdb\u884c\u81ea\u5b9a\u4e49\u3002 \u7b2c\u4e8c\u6b65 \u4f7f\u7528\u68c0\u67e5\u5668\u5c06\u6587\u672c\u66f4\u6539\u4e3a \"Turtle Rock\"\uff0c\u8fd9\u662f\u60a8\u5c06\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u663e\u793a\u7684\u7b2c\u4e00\u4e2a\u5730\u6807\u7684\u540d\u79f0\u3002 \u7b2c\u4e09\u6b65 \u5c06\u5b57\u4f53\u4fee\u9970\u7b26\u6539\u4e3a Title \u3002 \u8fd9\u5c06\u7cfb\u7edf\u5b57\u4f53\u5e94\u7528\u4e8e\u6587\u672c\uff0c\u4ee5\u4fbf\u5b83\u6b63\u786e\u54cd\u5e94\u7528\u6237\u7684\u9996\u9009\u5b57\u4f53\u5927\u5c0f\u548c\u8bbe\u7f6e\u3002 \u8981\u81ea\u5b9a\u4e49SwiftUI\u89c6\u56fe\uff0c\u4f60\u53ef\u4ee5\u8c03\u7528\u79f0\u4e3a \u4fee\u6539\u5668\uff08modifiers\uff09 \u7684\u65b9\u6cd5\u3002\u4fee\u6539\u5668\u5bf9\u89c6\u56fe\u8fdb\u884c\u5c01\u88c5\uff0c\u4ee5\u6539\u53d8\u5176\u663e\u793a\u6216\u5176\u4ed6\u5c5e\u6027\u3002\u6bcf\u4e00\u4e2a\u4fee\u6539\u5668\u90fd\u4f1a\u8fd4\u56de\u4e00\u4e2a\u65b0\u7684\u89c6\u56fe\uff0c\u6240\u4ee5\u901a\u5e38\u8fde\u7eed\u4f7f\u7528\u591a\u4e2a\u4fee\u6539\u5668\uff0c\u5e76\u5c06\u5b83\u4eec\u7eb5\u5411\u5806\u53e0\u3002 \u7b2c\u56db\u6b65 \u624b\u5de5\u7f16\u8f91\u4ee3\u7801\uff0c\u6dfb\u52a0 foregroundColor(.green) \u4fee\u6539\u5668\uff0c\u5c06\u6587\u5b57\u7684\u989c\u8272\u6539\u4e3a\u7eff\u8272\u3002 \u89c6\u56fe\u6c38\u8fdc\u662f\u4f60\u4ee3\u7801\u7684\u771f\u5b9e\u53cd\u6620\u3002\u5f53\u4f60\u4f7f\u7528\u68c0\u67e5\u5668\u66f4\u6539\u6216\u5220\u9664\u4e00\u4e2a\u4fee\u6539\u5668\u65f6\uff0cXcode\u4f1a\u7acb\u5373\u66f4\u65b0\u5e76\u5339\u914d\u4f60\u7684\u4ee3\u7801\u3002 \u7b2c\u4e94\u6b65 \u8fd9\u6b21\uff0c\u5728\u4ee3\u7801\u7f16\u8f91\u5668\u4e2d\u6309\u4e0bCommand-\u70b9\u51fb Text \uff0c\u6253\u5f00\u68c0\u67e5\u5668\uff0c\u7136\u540e\u4ece\u5f39\u51fa\u7684\u83dc\u5355\u4e2d\u9009\u62e9 Inspect \u3002\u70b9\u51fb Color \u5f39\u51fa\u83dc\u5355\uff0c\u9009\u62e9 Inherited\uff08\u7ee7\u627f\uff09 \uff0c\u5c06\u6587\u5b57\u989c\u8272\u518d\u6b21\u6539\u4e3a\u9ed1\u8272\u3002 \u7b2c\u516d\u6b65 \u6ce8\u610f\uff0cXcode\u4f1a\u81ea\u52a8\u66f4\u65b0\u4f60\u7684\u4ee3\u7801\u4ee5\u53cd\u6620\u53d8\u5316\uff0c\u5220\u9664 foregroundColor(.green) \u4fee\u6539\u5668\u3002 // // ContentView.swift // Landmarks // // Created by EchoSun on 2020/12/18. // import SwiftUI struct ContentView: View { var body: some View { Text(\"Turtle Rock\") .font(.title) } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } Next, you\u2019ll customize the text view using the inspector. Step 1 In the preview, Command-click the greeting to bring up the structured editing popover, and choose Inspect . The popover shows different attributes that you can customize, depending on the type of view you inspect. Step 2 Use the inspector to change the text to \u201cTurtle Rock\u201d, the name of the first landmark you\u2019ll show in your app. Step 3 Change the Font modifier to Title . This applies the system font to the text so that it responds correctly to the user\u2019s preferred font sizes and settings. To customize a SwiftUI view, you call methods called_modifiers_. Modifiers wrap a view to change its display or other properties. Each modifier returns a new view, so it\u2019s common to chain multiple modifiers, stacked vertically. Step 4 Edit the code by hand to add the foregroundColor(.green) modifier; this changes the text\u2019s color to green. Your code is always the source of truth for the view. When you use the inspector to change or remove a modifier, Xcode updates your code immediately to match. Step 5 This time, open the inspector by Command-clicking on the Text declaration in the code editor, and then choose Inspect from the popover. Click the Color pop-up menu and choose Inherited to change the text color to black again. Step 6 Notice that Xcode updates your code automatically to reflect the change, removing the foregroundColor(.green) modifier.","title":"\u8bbe\u7f6e\u6587\u672c\u89c6\u56fe-Customize the Text View"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/1.%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%BB%84%E5%90%88%E8%A7%86%E5%9B%BE-CreatingAndCombiningViews/#-combine-views-using-stacks","text":"\u9664\u4e86\u4e0a\u4e00\u8282\u4e2d\u521b\u5efa\u7684\u6807\u9898\u89c6\u56fe\u5916\uff0c\u60a8\u8fd8\u5c06\u6dfb\u52a0\u6587\u672c\u89c6\u56fe\u6765\u5305\u542b\u6709\u5173\u5730\u6807\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u4f8b\u5982\u516c\u56ed\u540d\u79f0\u548c\u5b83\u6240\u5904\u7684\u4f4d\u7f6e\u3002 \u5f53\u521b\u5efaSwiftUI\u89c6\u56fe\u65f6\uff0c\u60a8\u53ef\u4ee5\u5728\u89c6\u56fe\u7684 body \u5c5e\u6027\u4e2d\u63cf\u8ff0\u5b83\u7684\u5185\u5bb9\u3001\u5e03\u5c40\u548c\u884c\u4e3a\uff1b\u4f46\u662f\uff0c body \u5c5e\u6027\u53ea\u8fd4\u56de\u4e00\u4e2a\u89c6\u56fe\u3002\u60a8\u53ef\u4ee5\u5728 \u5806\u6808\uff08stacks\uff09 \u4e2d\u7ec4\u5408\u548c\u5d4c\u5165\u591a\u4e2a\u89c6\u56fe\uff0c\u5c06\u89c6\u56fe\u6c34\u5e73\u3001\u5782\u76f4\u6216\u4ece\u540e\u5230\u524d\u5730\u7ec4\u5408\u5728\u4e00\u8d77\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u4f60\u5c06\u4f7f\u7528\u6c34\u5e73\u5806\u6808\u653e\u7f6e\u516c\u56ed\u7684\u7ec6\u8282\uff0c\u5e76\u5c06\u5b83\u548c\u6807\u9898\u653e\u7f6e\u5230\u4e00\u4e2a\u5782\u76f4\u5806\u6808\u4e0a\u3002 Beyond the title view you created in the previous section, you\u2019ll add text views to contain details about the landmark, such as the name of the park and state it\u2019s in. When creating a SwiftUI view, you describe its content, layout, and behavior in the view\u2019s body property; however, the body property only returns a single view. You can combine and embed multiple views in stacks , which group views together horizontally, vertically, or back-to-front. In this section, you\u2019ll use a vertical stack to place the title above a horizontal stack that contains details about the park. \u60a8\u53ef\u4ee5\u4f7f\u7528Xcode\u7684\u7ed3\u6784\u5316\u7f16\u8f91\u652f\u6301\uff0c\u5c06\u4e00\u4e2a\u89c6\u56fe\u5d4c\u5165\u5230\u5bb9\u5668\u89c6\u56fe\u4e2d\uff0c\u6253\u5f00\u4e00\u4e2a\u68c0\u67e5\u5668\uff0c\u6216\u5e2e\u52a9\u8fdb\u884c\u5176\u4ed6\u6709\u7528\u7684\u66f4\u6539\u3002 \u7b2c1\u6b65 \u547d\u4ee4\u70b9\u51fb\u6587\u672c\u89c6\u56fe\u7684\u521d\u59cb\u5316\u5668\uff0c\u663e\u793a\u7ed3\u6784\u5316\u7f16\u8f91\u5f39\u51fa\u5668\uff0c\u7136\u540e\u9009\u62e9 Embed in VStack \u3002 \u63a5\u4e0b\u6765\uff0c\u4f60\u5c06\u901a\u8fc7\u4ece\u5e93\u4e2d\u62d6\u52a8\u4e00\u4e2a Text view\u6765\u6dfb\u52a0\u4e00\u4e2a\u6587\u672c\u89c6\u56fe\u5230\u5806\u6808\u4e2d\u3002 \u7b2c\u4e8c\u6b65 \u70b9\u51fbXcode\u7a97\u53e3\u53f3\u4e0a\u65b9\u7684\u52a0\u53f7\u6309\u94ae(+)\u6253\u5f00\u5e93\uff0c\u7136\u540e\u62d6\u52a8\u4e00\u4e2a Text \u7684view\u5230\u4ee3\u7801\u4e2d\u7d27\u6328\u7740 \"Turtle Rock \"\u6587\u672c\u89c6\u56fe\u7684\u5730\u65b9\u3002 \u8bd1\u8005\u6ce8 \u4f7f\u7528 library \u7a97\u53e3\u5feb\u901f\u6dfb\u52a0\u63a7\u4ef6\u7684\u5feb\u6377\u952e: \u21e7\u2318 L \u7b2c\u4e09\u6b65 \u5c06 Text \u7684\u5360\u4f4d\u6587\u5b57\u66ff\u6362\u4e3a Joshua Tree National Park \u3002 \u7136\u540e\u81ea\u5b9a\u4e49\u4f4d\u7f6e\u4ee5\u5339\u914d\u6240\u9700\u7684\u5e03\u5c40\u3002 \u7b2c\u56db\u6b65 \u5c06\u8be5\u4f4d\u7f6e\u7684\u5b57\u4f53\u8bbe\u7f6e\u4e3a subheadline \u3002 \u7b2c\u4e94\u6b65 \u7f16\u8f91 \"VStack \"\u521d\u59cb\u5316\u5668\u4f7f\u89c6\u56fe\u6cbf\u524d\u7f18\u5bf9\u9f50\u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5806\u6808\u5c06\u5176\u5185\u5bb9\u6cbf\u5176\u8f74\u7ebf\u5c45\u4e2d\uff0c\u5e76\u4e3a\u4e0a\u4e0b\u6587\u8bbe\u7f6e\u9002\u5f53\u7684\u95f4\u8ddd\u3002 \u63a5\u4e0b\u6765\uff0c\u60a8\u5c06\u5728\u4f4d\u7f6e\u7684\u53f3\u4fa7\u6dfb\u52a0\u53e6\u4e00\u4e2a\u6587\u672c\u89c6\u56fe\uff0c\u8fd9\u662f\u516c\u56ed\u7684\u4f4d\u7f6e\u3002 \u7b2c\u516d\u6b65 \u5728\u753b\u5e03\u4e2d\uff0c\u547d\u4ee4\u70b9\u51fb Joshua Tree National Park \uff0c\u5e76\u9009\u62e9 Embed in HStack\uff08\u5d4c\u5165\u5230HStack\u4e2d\uff09 \u3002 \u7b2c\u4e03\u6b65 \u5728\u4f4d\u7f6e\u540e\u9762\u6dfb\u52a0\u4e00\u4e2a\u65b0\u7684\u6587\u672c\u89c6\u56fe\uff0c\u5c06\u5360\u4f4d\u6587\u5b57\u6539\u4e3a\u516c\u56ed\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u5c06\u5176\u5b57\u4f53\u8bbe\u7f6e\u4e3a subheadline \u3002 \u7b2c\u516b\u6b65 \u4e3a\u4e86\u4f7f\u5e03\u5c40\u586b\u5145\u8bbe\u5907\u7684\u6574\u4e2a\u5bbd\u5ea6\uff0c\u6211\u4eec\u5728\u5305\u542b\u4e24\u4e2a\u6587\u672c\u89c6\u56fe\u7684\u6c34\u5e73\u5806\u6808\u4e2d\u6dfb\u52a0\u4e00\u4e2a \"\u95f4\u9694\u5668 \uff08Spacer\uff09\"\u6765\u5206\u79bb\u516c\u56ed\u548c\u4f4d\u7f6e\u3002 \u95f4\u9694\u5668 \uff08Spacer\uff09 \u5c06\u5360\u636e\u5176\u7236\u89c6\u56fe\u7684\u6240\u6709\u7a7a\u95f4\uff0c\u800c\u4e0d\u662f\u4ec5\u7531\u5176\u5185\u5bb9\u51b3\u5b9a\u5176\u5927\u5c0f\u3002 \u7b2c\u4e5d\u6b65 \u6700\u540e\uff0c\u4f7f\u7528 padding() \u4fee\u6539\u5668\u65b9\u6cd5\u7ed9\u5730\u6807\u7684\u540d\u79f0\u548c\u7ec6\u8282\u591a\u4e00\u70b9\u7a7a\u95f4\u3002 // // ContentView.swift // Landmarks // // Created by EchoSun on 2020/12/18. // import SwiftUI struct ContentView: View { var body: some View { VStack(alignment: .leading) { Text(\"Turtle Rock\") .font(.title) HStack { Text(\"Joshua Tree National Park\") .font(.subheadline) Spacer() Text(\"California\") .font(.subheadline) } } .padding() // \u589e\u52a0\u56db\u5468\u7684\u7a7a\u95f4 } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } You can use Xcode\u2019s structured editing support to embed a view in a container view, open an inspector, or help with other useful changes. Step 1 Command-click the text view\u2019s initializer to show the structured editing popover, and then choose Embed in VStack . Next, you\u2019ll add a text view to the stack by dragging a Text view from the library. Step 2 Open the library by clicking the plus button (+) at the top-right of the Xcode window, and then drag a Text view to the place in your code immediately after the \u201cTurtle Rock\u201d text view. Step 3 Replace the Text view\u2019s placeholder text with Joshua Tree National Park . Customize the location to match the desired layout. Step 4 Set the location\u2019s font to subheadline . Step 5 Edit the VStack initializer to align the views by their leading edges. By default, stacks center their contents along their axis and provide context-appropriate spacing. Next, you\u2019ll add another text view to the right of the location, this for the park\u2019s state. Step 6 In the canvas, Command-click Joshua Tree National Park , and choose Embed in HStack . Step 7 Add a new text view after the location, change the placeholder text to the park\u2019s state, and then set its font to subheadline . Step 8 To direct the layout to use the full width of the device, separate the park and the state by adding a Spacer to the horizontal stack holding the two text views. A spacer expands to make its containing view use all of the space of its parent view, instead of having its size defined only by its contents. Step 9 Finally, use the padding() modifier method to give the landmark\u2019s name and details a little more space.","title":"\u4f7f\u7528\u5806\u6808\u7ec4\u5408\u89c6\u56fe-Combine Views Using Stacks"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/1.%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%BB%84%E5%90%88%E8%A7%86%E5%9B%BE-CreatingAndCombiningViews/#-create-a-custom-image-view","text":"\u540d\u79f0\u548c\u4f4d\u7f6e\u89c6\u56fe\u90fd\u8bbe\u7f6e\u597d\u4e86\uff0c\u4e0b\u4e00\u6b65\u5c31\u662f\u4e3a\u5730\u6807\u6dfb\u52a0\u56fe\u50cf\u3002 \u5728\u8fd9\u4e2a\u6587\u4ef6\u4e2d\uff0c\u60a8\u5c06\u521b\u5efa\u4e00\u4e2a\u81ea\u5b9a\u4e49\u89c6\u56fe\uff0c\u4e3a\u56fe\u50cf\u5e94\u7528\u906e\u7f69\u3001\u8fb9\u6846\u548c\u9634\u5f71\uff0c\u800c\u4e0d\u662f\u6dfb\u52a0\u66f4\u591a\u4ee3\u7801\u3002 With the name and location views all set, the next step is to add an image for the landmark. Instead of adding more code in this file, you\u2019ll create a custom view that applies a mask, border, and drop shadow to the image. \u4ece\u6dfb\u52a0\u56fe\u50cf\u5230\u9879\u76ee\u7684\u8d44\u4ea7\u76ee\u5f55\u5f00\u59cb\u3002 \u7b2c\u4e00\u6b65 \u5728\u9879\u76ee\u6587\u4ef6\u7684 Resources(\u8d44\u6e90) \u6587\u4ef6\u5939\u4e2d\u627e\u5230 turtlerock.png \uff0c\u5e76\u5c06\u5176\u62d6\u5165\u8d44\u4ea7\uff08Assets\uff09\u76ee\u5f55\u7684\u7f16\u8f91\u5668\u4e2d\u3002Xcode\u5c06\u4e3a\u8be5\u56fe\u50cf\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u56fe\u50cf\u96c6\u3002 \u63a5\u4e0b\u6765\uff0c\u4f60\u5c06\u4e3a\u4f60\u7684\u81ea\u5b9a\u4e49\u56fe\u50cf\u89c6\u56fe\u521b\u5efa\u4e00\u4e2a\u65b0\u7684SwiftUI\u89c6\u56fe\u3002 \u7b2c\u4e8c\u6b65 \u9009\u62e9 File > New > File \uff0c\u518d\u6b21\u6253\u5f00\u6a21\u677f\u9009\u62e9\u5668\u3002\u5728 User Interface \u90e8\u5206\uff0c\u9009\u62e9 SwiftUI View \uff0c\u70b9\u51fb Next \u3002\u5c06\u6587\u4ef6\u547d\u540d\u4e3a CircleImage.swift \u5e76\u70b9\u51fb Create \u3002 \u4f60\u5df2\u7ecf\u51c6\u5907\u597d\u63d2\u5165\u56fe\u7247\u5e76\u4fee\u6539\u5176\u663e\u793a\u65b9\u5f0f\u4ee5\u7b26\u5408\u6240\u9700\u7684\u8bbe\u8ba1\u3002 \u7b2c\u4e09\u6b65 \u4f7f\u7528 Image(_:) \u521d\u59cb\u5316\u5668\u5c06\u6587\u672c\u89c6\u56fe\u66ff\u6362\u4e3aTurtle Rock\u7684\u56fe\u50cf\u3002 \u7b2c\u56db\u6b65 \u6dfb\u52a0\u4e00\u4e2a clipShape(Circle()) \uff0c\u5728\u56fe\u50cf\u4e0a\u526a\u88c1\u51fa\u4e00\u4e2a\u5706\u5f62\u3002 Circle \u7c7b\u578b\u662f\u4e00\u4e2a\u5f62\u72b6\uff0c\u4f60\u53ef\u4ee5\u7528\u5b83\u6765\u505a\u8499\u7248\uff0c\u6216\u8005\u901a\u8fc7\u7ed9\u5706\u5708\u4e00\u4e2a\u63cf\u8fb9\u6216\u586b\u5145\u6765\u505a\u89c6\u56fe\u3002 \u7b2c\u4e94\u6b65 \u7528\u7070\u8272\u7b14\u89e6\u521b\u5efa\u53e6\u4e00\u4e2a\u5706\u5708\uff0c\u7136\u540e\u5c06\u5176\u6dfb\u52a0\u4e3a\u53e0\u52a0\uff0c\u7ed9\u56fe\u50cf\u4e00\u4e2a\u8fb9\u6846\u3002 \u7b2c\u516d\u6b65 \u63a5\u4e0b\u6765\uff0c\u6dfb\u52a0\u4e00\u4e2a\u534a\u5f84\u4e3a10\u70b9\u7684\u9634\u5f71\u3002 \u7b2c\u4e03\u6b65 \u5c06\u8fb9\u6846\u989c\u8272\u5207\u6362\u4e3a\u767d\u8272\u3002 \u8fd9\u6837\u5c31\u5b8c\u6210\u4e86\u56fe\u50cf\u89c6\u56fe\u3002 // // CircleImage.swift.swift // Landmarks // // Created by EchoSun on 2020/12/18. // import SwiftUI struct CircleImage: View { var body: some View { Image(\"turtlerock\") .clipShape(Circle()) .overlay(Circle().stroke(Color.white, lineWidth: 4)) .shadow(radius: 10) } } struct CircleImage_Previews: PreviewProvider { static var previews: some View { CircleImage() } } Start by adding an image to the project\u2019s asset catalog. Step 1 Find turtlerock.png in the project files\u2019 Resources folder; drag it into the asset catalog\u2019s editor. Xcode creates a new image set for the image. Next, you\u2019ll create a new SwiftUI view for your custom image view. Step 2 Choose File > New > File to open the template selector again. In the User Interface section, select SwiftUI View and click Next . Name the file CircleImage.swift and click Create . You\u2019re ready to insert the image and modify its display to match the desired design. Step 3 Replace the text view with the image of Turtle Rock by using the Image(_:) initializer. Step 4 Add a call to clipShape(Circle()) to apply the circular clipping shape to the image. The Circle type is a shape that you can use as a mask, or as a view by giving the circle a stroke or fill. Step 5 Create another circle with a gray stroke, and then add it as an overlay to give the image a border. Step 6 Next, add a shadow with a 10 point radius. Step 7 Switch the border color to white. This completes the image view.","title":"\u521b\u5efa\u56fe\u7247\u89c6\u56fe-Create a Custom Image View"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/1.%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%BB%84%E5%90%88%E8%A7%86%E5%9B%BE-CreatingAndCombiningViews/#uikitswiftui-use-uikit-and-swiftui-views-together","text":"\u73b0\u5728\u4f60\u5df2\u7ecf\u51c6\u5907\u597d\u521b\u5efa\u4e00\u4e2a\u5730\u56fe\u89c6\u56fe\u4e86\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528MapKit\u7684 MKMapView \u7c7b\u6765\u6e32\u67d3\u5730\u56fe\u3002 \u8981\u5728SwiftUI\u4e2d\u4f7f\u7528 UIView \u5b50\u7c7b\uff0c\u4f60\u53ef\u4ee5\u5c06\u5176\u4ed6\u89c6\u56fe\u5305\u88f9\u5728\u7b26\u5408 UIViewRepresentable \u534f\u8bae\u7684SwiftUI\u89c6\u56fe\u4e2d\u3002SwiftUI\u5305\u62ec\u7c7b\u4f3c\u7684WatchKit\u548cAppKit\u89c6\u56fe\u7684\u534f\u8bae\u3002 Now you\u2019re ready to create a map view. You can use the MKMapView class from MapKit to render the map. To use UIView subclasses from within SwiftUI, you wrap the other view in a SwiftUI view that conforms to the UIViewRepresentable protocol. SwiftUI includes similar protocols for WatchKit and AppKit views. \u8981\u5f00\u59cb\uff0c\u4f60\u5c06\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\uff0c\u53ef\u4ee5\u5448\u73b0\u4e00\u4e2a MKMapView \u3002 \u7b2c\u4e00\u6b65 \u9009\u62e9 File > New > File \uff0c\u9009\u62e9 iOS \u4e3a\u5e73\u53f0\uff0c\u9009\u62e9 SwiftUI View \u6a21\u677f\uff0c\u70b9\u51fb Next \u3002\u5c06\u65b0\u6587\u4ef6\u547d\u540d\u4e3a MapView.swift \uff0c\u70b9\u51fb Create \u3002 \u7b2c\u4e8c\u6b65 \u4e3aMapKit\u6dfb\u52a0\u4e00\u4e2a import \u8bed\u53e5\uff0c\u5e76\u4e3a MapView \u7c7b\u578b\u58f0\u660e UIViewRepresentable \u7684\u4e00\u81f4\u6027\uff08conformance\uff09\u3002 \u4e0d\u8981\u62c5\u5fc3Xcode\u663e\u793a\u7684\u9519\u8bef\uff1b\u4f60\u5c06\u5728\u63a5\u4e0b\u6765\u7684\u51e0\u4e2a\u6b65\u9aa4\u4e2d\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 UIViewRepresentable \u534f\u8bae\u6709\u4e24\u4e2a\u9700\u6c42\u4f60\u9700\u8981\u6dfb\u52a0\uff1a\u4e00\u4e2a makeUIView(context:) \u65b9\u6cd5\u521b\u5efa MKMapView \uff0c\u4e00\u4e2a updateUIView(_:context:) \u65b9\u6cd5\u914d\u7f6e\u5e76\u76f8\u5e94\u89c6\u56fe\u7684\u66f4\u65b0\u3002 \u7b2c\u4e09\u6b65 \u7528 makeUIView(context: Context) \u65b9\u6cd5\u66ff\u6362 body \u5c5e\u6027\uff0c\u521b\u5efa\u5e76\u8fd4\u56de\u4e00\u4e2a\u7a7a\u7684 MKMapView \u3002 \u7b2c\u56db\u6b65 \u521b\u5efa\u4e00\u4e2a updateUIView(_:context:) \u65b9\u6cd5\uff0c\u5c06\u5730\u56fe\u89c6\u56fe\u7684\u4f4d\u7f6e\u8bbe\u7f6e\u4e3a\u6b63\u786e\u7684\u5750\u6807\uff0c\u4f7f\u5730\u56fe\u4ee5Turtle Rock\u4e3a\u4e2d\u5fc3\u3002 \u5f53\u9884\u89c8\u5904\u4e8e\u9759\u6001\u6a21\u5f0f\u65f6\uff0c\u53ea\u80fd\u5b8c\u5168\u6e32\u67d3SwiftUI\u89c6\u56fe\u3002\u56e0\u4e3a MKMapView \u662f\u4e00\u4e2a UIView \u5b50\u7c7b\uff0c\u6240\u4ee5\u4f60\u9700\u8981\u5207\u6362\u5230\u5b9e\u65f6\u9884\u89c8\u6765\u67e5\u770b\u5730\u56fe\u3002 \u7b2c\u4e94\u6b65 \u70b9\u51fb \u76f4\u64ad\u9884\u89c8 \u6309\u94ae\uff0c\u5c06\u9884\u89c8\u5207\u6362\u5230\u76f4\u64ad\u6a21\u5f0f\u3002\u60a8\u53ef\u80fd\u9700\u8981\u70b9\u51fb\u9884\u89c8\u4e0a\u65b9\u7684 Try Again \u6216 Resume \u6309\u94ae\u3002 \u4e00\u4f1a\u513f\uff0c\u4f60\u5c31\u4f1a\u770b\u5230Joshua Tree\u56fd\u5bb6\u516c\u56ed\u7684\u5730\u56fe\uff0c\u4e5f\u5c31\u662fTurtle Rock\u7684\u6240\u5728\u5730\u3002 // // MapView.swift // Landmarks // // Created by EchoSun on 2020/12/18. // import SwiftUI import MapKit struct MapView: UIViewRepresentable { // \u521b\u5efa`MKMapView` func makeUIView(context: Context) -> MKMapView { MKMapView(frame: .zero) } // \u914d\u7f6e\u5e76\u76f8\u5e94\u89c6\u56fe\u7684\u66f4\u65b0 func updateUIView(_ uiView: MKMapView, context: Context) { let coordinate = CLLocationCoordinate2D( latitude: 34.011286, longitude: -116.166868) let span = MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0) let region = MKCoordinateRegion(center: coordinate, span: span) uiView.setRegion(region, animated: true) } } struct MapView_Previews: PreviewProvider { static var previews: some View { MapView() } } To get started, you\u2019ll create a new custom view that can present an MKMapView . Step 1 Choose File > New > File , select iOS as the platform, select the SwiftUI View template, and click Next . Name the new file MapView.swift and click Create . Step 2 Add an import statement for MapKit , and declare UIViewRepresentable conformance for the MapView type. Don\u2019t worry about the error that Xcode displays; you\u2019ll fix that in the next few steps. The UIViewRepresentable protocol has two requirements you need to add: a makeUIView(context:) method that creates an MKMapView , and an updateUIView(_:context:) method that configures the view and responds to any changes. Step 3 Replace the body property with a makeUIView(context:) method that creates and returns an empty MKMapView . Step 4 Create an updateUIView(_:context:) method that sets the map view\u2019s region to the correct coordinates to center the map on Turtle Rock. When previews are in static mode, they only fully render SwiftUI views. Because MKMapView is a UIView subclass, you\u2019ll need to switch to a live preview to see the map. Step 5 Click the Live Preview button to switch the preview to live mode. You might need to click the Try Again or Resume button above your preview. In a moment, you\u2019ll see a map of Joshua Tree National Park, home of Turtle Rock.","title":"\u540c\u65f6\u4f7f\u7528UIKit\u548cSwiftUI\u89c6\u56fe-Use UIKit and SwiftUI Views Together"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/1.%E5%88%9B%E5%BB%BA%E5%B9%B6%E7%BB%84%E5%90%88%E8%A7%86%E5%9B%BE-CreatingAndCombiningViews/#-compose-the-detail-view","text":"\u73b0\u5728\uff0c\u60a8\u5df2\u7ecf\u62e5\u6709\u4e86\u6240\u9700\u7684\u6240\u6709\u7ec4\u4ef6\u2014\u2014\u540d\u79f0\u548c\u5730\u70b9\u3001\u5706\u5f62\u56fe\u50cf\u4ee5\u53ca\u4f4d\u7f6e\u7684\u5730\u56fe\u3002 \u5229\u7528\u60a8\u8fc4\u4eca\u4e3a\u6b62\u4f7f\u7528\u7684\u5de5\u5177\uff0c\u7ed3\u5408\u60a8\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\uff0c\u521b\u5efa\u5730\u6807\u7ec6\u8282\u89c6\u56fe\u7684\u6700\u7ec8\u8bbe\u8ba1\u3002 You now have all of the components you need \u2014 the name and place, a circular image, and a map for the location. With the tools you\u2019ve used so far, combine your custom views to create the final design for the landmark detail view. \u7b2c\u4e00\u6b65 \u5728\u9879\u76ee\u5bfc\u822a\u4e2d\uff0c\u9009\u62e9 ContentView.swift \u6587\u4ef6\u3002 \u7b2c\u4e8c\u6b65 \u5728\u5916\u90e8\u5d4c\u5165\u4e00\u4e2a VStack \uff0c\u4f7f\u5185\u90e8\u7684 VStack \u5bb9\u7eb3\u4e09\u4e2a\u6587\u672c\u89c6\u56fe\u3002 \u7b2c\u4e09\u6b65 \u5c06\u4f60\u7684\u81ea\u5b9a\u4e49 MapView \u6dfb\u52a0\u5230\u5806\u6808\u7684\u9876\u90e8\u3002\u5e76\u4f7f\u7528 frame(width:height:) \u8bbe\u7f6e MapView \u7684\u5927\u5c0f\u3002 \u5f53\u4f60\u53ea\u6307\u5b9a \"height \"\u53c2\u6570\u65f6\uff0c\u89c6\u56fe\u4f1a\u81ea\u52a8\u8c03\u6574\u4e3a\u5176\u5185\u5bb9\u7684\u5bbd\u5ea6\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\"MapView \"\u5c06\u5c55\u5f00\u4ee5\u586b\u5145\u53ef\u7528\u7a7a\u95f4\u3002 \u7b2c\u56db\u6b65 \u70b9\u51fb Live Preview \u6309\u94ae\uff0c\u53ef\u5728\u5408\u6210\u89c6\u56fe\u4e2d\u67e5\u770b\u6e32\u67d3\u7684\u5730\u56fe\u3002 \u60a8\u53ef\u4ee5\u5728\u663e\u793a\u5b9e\u65f6\u9884\u89c8\u7684\u540c\u65f6\u7ee7\u7eed\u7f16\u8f91\u89c6\u56fe\u3002 \u7b2c\u4e94\u6b65 \u5c06 CircleImage \u89c6\u56fe\u6dfb\u52a0\u5230\u5806\u6808\u4e2d\u3002 \u7b2c\u516d\u6b65\uff1a\u5c06 CircleImage \u89c6\u56fe\u6dfb\u52a0\u5230\u5806\u6808\u4e2d\u3002 \u8981\u5728\u5730\u56fe\u89c6\u56fe\u7684\u57fa\u7840\u4e0a\u53e0\u52a0\u56fe\u50cf\u89c6\u56fe\uff0c\u9700\u8981\u5728\u7eb5\u5411\u4e0a\u7ed9\u56fe\u50cf\u4e00\u4e2a-130\u70b9\u7684\u504f\u79fb\uff0c\u5e76\u5728\u56fe\u50cf\u89c6\u56fe\u5e95\u90e8\u7ed9\u56fe\u50cf\u4e00\u4e2a-130\u70b9\u7684\u586b\u5145\u3002 \u8fd9\u4e9b\u8c03\u6574\u901a\u8fc7\u5411\u4e0a\u79fb\u52a8\u56fe\u50cf\u6765\u4e3a\u6587\u5b57\u817e\u51fa\u7a7a\u95f4\u3002 \u7b2c\u4e03\u6b65 \u5728\u5916\u5c42 \"VStack \"\u7684\u5e95\u90e8\u6dfb\u52a0\u4e00\u4e2a Spacer \uff0c\u5c06\u5185\u5bb9\u63a8\u5230\u5c4f\u5e55\u9876\u90e8\u3002 \u7b2c\u516b\u6b65 \u6700\u540e\uff0c\u4e3a\u4e86\u8ba9\u5730\u56fe\u5185\u5bb9\u5ef6\u4f38\u5230\u5c4f\u5e55\u7684\u9876\u90e8\u8fb9\u7f18\uff0c\u5728\u5730\u56fe\u89c6\u56fe\u4e2d\u6dfb\u52a0 edgesIgnoringSafeArea(.top) \u4fee\u6539\u5668\u3002 \u8bd1\u8005\u6ce8 // // ContentView.swift // Landmarks // // Created by EchoSun on 2020/12/18. // import SwiftUI struct ContentView: View { var body: some View { VStack { MapView() .edgesIgnoringSafeArea(.top) .frame(height:300) CircleImage() .offset(y: -130) .padding(.bottom, -130) VStack(alignment: .leading) { Text(\"Turtle Rock\") .font(.title) HStack { Text(\"Joshua Tree National Park\") .font(.subheadline) Spacer() Text(\"California\") .font(.subheadline) } } .padding() Spacer() } } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } Step 1 In the Project navigator, select the ContentView.swift file. Step 2 Embed a VStack that holds the three text views in another VStack . Step 3 Add your custom MapView to the top of the stack. Set the size of the MapView with frame(width:height:) . When you specify only the height parameter, the view automatically sizes to the width of its content. In this case, MapView expands to fill the available space. Step 4 Click the Live Preview button to see the rendered map in the composed view. You can continue editing the view while showing a Live Preview. Step 5 Add the CircleImage view to the stack. Step 6 To layer the image view on top of the map view, give the image an offset of -130 points vertically, and padding of -130 points from the bottom of the view. These adjustments make room for the text by moving the image upwards. Step 7 Add a spacer at the bottom of the outer VStack to push the content to the top of the screen. Step 8 Finally, to allow the map content to extend to the top edge of the screen, add the edgesIgnoringSafeArea(.top) modifier to the map view.","title":"\u7ec4\u6210\u8be6\u7ec6\u89c6\u56fe-Compose the Detail View"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/2.%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AF%BC%E8%88%AA-BuildingListsAndNavigation/","text":"\u6784\u5efa\u5217\u8868\u548c\u5bfc\u822a-BuildingListsAndNavigation \u5728\u8bbe\u7f6e\u4e86\u57fa\u672c\u7684\u5730\u6807\u8be6\u7ec6\u89c6\u56fe\u540e\uff0c\u60a8\u9700\u8981\u63d0\u4f9b\u4e00\u79cd\u65b9\u5f0f\u8ba9\u7528\u6237\u67e5\u770b\u5b8c\u6574\u7684\u5730\u6807\u5217\u8868\uff0c\u5e76\u67e5\u770b\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u8be6\u7ec6\u4fe1\u606f\u3002 \u60a8\u5c06\u521b\u5efa\u53ef\u4ee5\u663e\u793a\u4efb\u4f55\u5730\u6807\u4fe1\u606f\u7684\u89c6\u56fe\uff0c\u5e76\u52a8\u6001\u751f\u6210\u4e00\u4e2a\u6eda\u52a8\u5217\u8868\uff0c\u7528\u6237\u53ef\u4ee5\u70b9\u51fb\u8be5\u5217\u8868\u67e5\u770b\u67d0\u4e2a\u5730\u6807\u7684\u8be6\u7ec6\u89c6\u56fe\u3002\u4e3a\u4e86\u5bf9\u7528\u6237\u754c\u9762\u8fdb\u884c\u5fae\u8c03\uff0c\u60a8\u5c06\u4f7f\u7528Xcode\u7684\u753b\u5e03\u5728\u4e0d\u540c\u7684\u8bbe\u5907\u5c3a\u5bf8\u4e0b\u5448\u73b0\u591a\u4e2a\u9884\u89c8\u3002 \u4e0b\u8f7d\u9879\u76ee\u6587\u4ef6\u5f00\u59cb\u6784\u5efa\u8fd9\u4e2a\u9879\u76ee\uff0c\u5e76\u6309\u7167\u4ee5\u4e0b\u6b65\u9aa4\u8fdb\u884c\u3002 With the basic landmark detail view set up, you need to provide a way for users to see the full list of landmarks, and to view the details about each location. You\u2019ll create views that can show information about any landmark, and dynamically generate a scrolling list that a user can tap to see a detail view for a landmark. To fine-tune the UI, you\u2019ll use Xcode\u2019s canvas to render multiple previews at different device sizes. Download the project files to begin building this project, and follow the steps below. \u9879\u76ee\u6587\u4ef6\u4e0b\u8f7d 1.\u4e86\u89e3\u7b80\u5355\u6570\u636e-Get to Know the Sample Data \u5728\u7b2c\u4e00\u7bc7\u6559\u7a0b\u4e2d\uff0c\u4f60\u5c06\u4fe1\u606f\u786c\u7f16\u7801\u5230\u6240\u6709\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\u4e2d\u3002\u5728\u8fd9\u91cc\uff0c\u60a8\u5c06\u5b66\u4e60\u5982\u4f55\u5c06\u6570\u636e\u4f20\u9012\u5230\u60a8\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\u4e2d\u8fdb\u884c\u663e\u793a\u3002 \u4e0b\u8f7d\u5165\u95e8\u9879\u76ee\u5e76\u719f\u6089\u6837\u672c\u6570\u636e\uff0c\u5373\u53ef\u5f00\u59cb\u5b66\u4e60\u3002 In the first tutorial, you hard-coded information into all of your custom views. Here, you\u2019ll learn to pass data into your custom views for display. Get started by downloading the starter project and familiarizing yourself with the sample data. \u7b2c\u4e00\u6b65 \u5728\u9879\u76ee\u5bfc\u822a\u5668\u4e2d\uff0c\u9009\u62e9 Models > Landmark.swift \u3002 Landmark.swift \u58f0\u660e\u4e00\u4e2a Landmark \u7ed3\u6784\uff0c\u8be5\u7ed3\u6784\u5b58\u50a8\u4e86\u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u663e\u793a\u7684\u6240\u6709\u5730\u6807\u4fe1\u606f\uff0c\u5e76\u4ece landmarkData.json \u5bfc\u5165\u4e00\u4e2a\u5730\u6807\u6570\u636e\u6570\u7ec4\u3002 \u7b2c\u4e8c\u6b65 \u5728\u9879\u76ee\u5bfc\u822a\u5668\u4e2d\uff0c\u9009\u62e9 Resources > landmarkData.json \u3002 \u60a8\u5c06\u5728\u672c\u6559\u7a0b\u7684\u5176\u4f59\u90e8\u5206\u4ee5\u53ca\u540e\u7eed\u7684\u6240\u6709\u5185\u5bb9\u4e2d\u4f7f\u7528\u8fd9\u4e2a\u6837\u672c\u6570\u636e\u3002 \u7b2c\u4e09\u6b65 \u8bf7\u6ce8\u610f\uff0c \u521b\u5efa\u5e76\u7ec4\u5408\u89c6\u56fe-CreatingAndCombiningViews \u8fd9\u4e00\u8282\u4e2d\u7684 ContentView \u73b0\u5728\u88ab\u547d\u540d\u4e3a LandmarkDetail \u3002 \u5728\u672c\u6559\u7a0b\u548c\u4e0b\u9762\u7684\u6bcf\u4e2a\u6559\u7a0b\u4e2d\uff0c\u60a8\u5c06\u521b\u5efa\u66f4\u591a\u7684\u89c6\u56fe\u7c7b\u578b\u3002 // // Landmark.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import SwiftUI import CoreLocation struct Landmark: Hashable, Codable { var id: Int var name: String fileprivate var imageName: String fileprivate var coordinates: Coordinates var state: String var park: String var category: Category var locationCoordinate: CLLocationCoordinate2D { CLLocationCoordinate2D( latitude: coordinates.latitude, longitude: coordinates.longitude) } enum Category: String, CaseIterable, Codable, Hashable { case featured = \"Featured\" case lakes = \"Lakes\" case rivers = \"Rivers\" } } extension Landmark { var image: Image { ImageStore.shared.image(name: imageName) } } struct Coordinates: Hashable, Codable { var latitude: Double var longitude: Double } Step 1 In the Project navigator, choose Models > Landmark.swift . Landmark.swift declares a Landmark structure that stores all of the landmark information the app needs to display, and imports an array of landmark data from landmarkData.json . Step 2 In the Project navigator, choose Resources > landmarkData.json . You\u2019ll use this sample data throughout the remainder of this tutorial, and for all that follow. Step 3 Note that the ContentView type from Creating and Combining Views is now named LandmarkDetail . You\u2019ll create several more view types in this and each of the following tutorials. 2.\u521b\u5efa\u884c\u89c6\u56fe-Create the Row View \u5728\u672c\u6559\u7a0b\u4e2d\uff0c\u60a8\u5c06\u6784\u5efa\u7684\u7b2c\u4e00\u4e2a\u89c6\u56fe\u662f\u4e00\u4e2a\u7528\u4e8e\u663e\u793a\u6bcf\u4e2a\u5730\u6807\u8be6\u7ec6\u4fe1\u606f\u7684\u884c\u3002\u8fd9\u4e2a\u884c\u89c6\u56fe\u5c06\u4fe1\u606f\u5b58\u50a8\u5728\u5b83\u6240\u663e\u793a\u7684\u5730\u6807\u7684\u5c5e\u6027\u4e2d\uff0c\u56e0\u6b64\u4e00\u4e2a\u89c6\u56fe\u53ef\u4ee5\u663e\u793a\u4efb\u4f55\u5730\u6807\u3002\u7a0d\u540e\uff0c\u60a8\u5c06\u628a\u591a\u4e2a\u884c\u7ec4\u5408\u6210\u4e00\u4e2a\u5730\u6807\u5217\u8868\u3002 The first view you\u2019ll build in this tutorial is a row for displaying details about each landmark. This row view stores information in a property for the landmark it displays, so that one view can display any landmark. Later, you\u2019ll combine multiple rows into a list of landmarks. \u7b2c\u4e00\u6b65 \u521b\u5efa\u4e00\u4e2a\u65b0\u7684SwiftUI\u89c6\u56fe\uff0c\u547d\u540d\u4e3a LandmarkRow.swift \u3002 \u7b2c\u4e8c\u6b65 \u5982\u679c\u9884\u89c8\u8fd8\u4e0d\u53ef\u89c1\uff0c\u9009\u62e9 Editor > Canvas \uff0c\u7136\u540e\u70b9\u51fb Resume \u6765\u663e\u793a\u753b\u5e03\u3002 \u7b2c\u4e09\u6b65 \u6dfb\u52a0 landmark \u4f5c\u4e3a LandmarkRow \u7684\u4e00\u4e2a\u5b58\u50a8\u5c5e\u6027\u3002 \u5f53\u4f60\u6dfb\u52a0 landmark \u5c5e\u6027\u65f6\uff0c\u9884\u89c8\u505c\u6b62\u5de5\u4f5c\uff0c\u56e0\u4e3a LandmarkRow \u7c7b\u578b\u5728\u521d\u59cb\u5316\u65f6\u9700\u8981\u4e00\u4e2a\u5730\u6807\u5b9e\u4f8b\u3002 \u4e3a\u4e86\u6062\u590d\u9884\u89c8\uff0c\u4f60\u9700\u8981\u4fee\u6539\u9884\u89c8\u63d0\u4f9b\u8005(preview provider)\u3002 \u7b2c\u56db\u6b65 \u5728 LandmarkRow_Previews \u7684 previews static\u5c5e\u6027\u4e2d\uff0c\u5c06landmark\u53c2\u6570\u6dfb\u52a0\u5230 LandmarkRow \u521d\u59cb\u5316\u4e2d\uff0c\u6307\u5b9a landmarkData \u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u3002 \u9884\u89c8\u663e\u793a\u7684\u662f\u6587\u5b57\uff0c Hello World \u3002 \u56fa\u5b9a\u540e\uff0c\u60a8\u5c31\u53ef\u4ee5\u4e3a\u8be5\u884c\u5efa\u7acb\u5e03\u5c40\u4e86\u3002 \u7b2c\u4e94\u6b65 \u5c06\u73b0\u6709\u7684\u6587\u672c\u89c6\u56fe\u5d4c\u5165\u5230 HStack \u4e2d\u3002 \u7b2c\u516d\u6b65 \u4fee\u6539\u6587\u672c\u89c6\u56fe\uff0c\u4f7f\u7528 landmark \u5c5e\u6027\u7684 name \u3002 \u7b2c\u4e03\u6b65 \u5728\u6587\u672c\u89c6\u56fe\u524d\u6dfb\u52a0\u56fe\u50cf\uff0c\u5728\u6587\u672c\u89c6\u56fe\u540e\u6dfb\u52a0spacer\uff0c\u4ece\u800c\u5b8c\u6210\u884c // // LandmarkRow.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import SwiftUI struct LandmarkRow: View { var landmark: Landmark var body: some View { HStack { landmark.image .resizable() .frame(width: 50, height: 50) Text(landmark.name) Spacer() } } } struct LandmarkRow_Previews: PreviewProvider { static var previews: some View { LandmarkRow(landmark: landmarkData[0]) } } // // Landmark.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import SwiftUI import CoreLocation struct Landmark: Hashable, Codable { var id: Int var name: String fileprivate var imageName: String fileprivate var coordinates: Coordinates var state: String var park: String var category: Category var locationCoordinate: CLLocationCoordinate2D { CLLocationCoordinate2D( latitude: coordinates.latitude, longitude: coordinates.longitude) } enum Category: String, CaseIterable, Codable, Hashable { case featured = \"Featured\" case lakes = \"Lakes\" case rivers = \"Rivers\" } } extension Landmark { var image: Image { Image(imageName) // ImageStore.shared.image(name: imageName) } } struct Coordinates: Hashable, Codable { var latitude: Double var longitude: Double } // // ModelData.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import Foundation var landmarkData: [Landmark] = load(\"landmarkData.json\") func load<T: Decodable>(_ filename: String) -> T { let data: Data guard let file = Bundle.main.url(forResource: filename, withExtension: nil) else { fatalError(\"Couldn't find \\(filename) in main bundle.\") } do { data = try Data(contentsOf: file) } catch { fatalError(\"Couldn't load \\(filename) from main bundle:\\n\\(error)\") } do { let decoder = JSONDecoder() return try decoder.decode(T.self, from: data) } catch { fatalError(\"Couldn't parse \\(filename) as \\(T.self):\\n\\(error)\") } } Step 1 Create a new SwiftUI view, named LandmarkRow.swift . Step 2 If the preview isn\u2019t visible already, show the canvas by selecting Editor > Canvas , and then click Resume . Step 3 Add landmark as a stored property of LandmarkRow . When you add the landmark property, the preview stops working, because the LandmarkRow type needs a landmark instance during initialization. To fix the preview, you\u2019ll need to modify the preview provider. Step 4 In the previews static property of LandmarkRow_Previews , add the landmark parameter to the LandmarkRow initializer, specifying the first element of the landmarkData array. The preview displays the text, Hello World . With that fixed, you can build the layout for the row. Step 5 Embed the existing text view in an HStack . Step 6 Modify the text view to use the landmark property\u2019s name . Step 7 Complete the row by adding an image before the text view, and a spacer after it. 3.\u81ea\u5b9a\u4e49\u884c\u9884\u89c8-Customize the Row Preview Xcode\u7684\u753b\u5e03\u4f1a\u81ea\u52a8\u8bc6\u522b\u5e76\u663e\u793a\u5f53\u524d\u7f16\u8f91\u5668\u4e2d\u7b26\u5408 \"PreviewProvider \"\u534f\u8bae\u7684\u4efb\u4f55\u7c7b\u578b\u3002\u9884\u89c8\u63d0\u4f9b\u8005\u4f1a\u8fd4\u56de\u4e00\u4e2a\u6216\u591a\u4e2a\u89c6\u56fe\uff0c\u5e76\u63d0\u4f9b\u914d\u7f6e\u5927\u5c0f\u548c\u8bbe\u5907\u7684\u9009\u9879\u3002 \u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u4ece\u9884\u89c8\u63d0\u4f9b\u8005\u8fd4\u56de\u7684\u5185\u5bb9\uff0c\u4ee5\u51c6\u786e\u5730\u5448\u73b0\u5bf9\u60a8\u6700\u6709\u5e2e\u52a9\u7684\u9884\u89c8\u3002 Xcode\u2019s canvas automatically recognizes and displays any type in the current editor that conforms to the PreviewProvider protocol. A preview provider returns one or more views, with options to configure the size and device. You can customize the returned content from a preview provider to render exactly the previews that are most helpful to you. \u7b2c\u4e00\u6b65 \u5728 LandmarkRow_Previews \u4e2d\uff0c\u66f4\u65b0 landmark \u53c2\u6570\u4e3a landmarkData \u6570\u7ec4\u4e2d\u7684\u7b2c\u4e8c\u4e2a\u5143\u7d20\u3002 \u9884\u89c8\u4f1a\u7acb\u5373\u6539\u53d8\uff0c\u663e\u793a\u7b2c\u4e8c\u4e2a\u6837\u672c\u5730\u6807\u800c\u4e0d\u662f\u7b2c\u4e00\u4e2a\u3002 \u7b2c\u4e8c\u6b65 \u4f7f\u7528 previewLayout(_:) \u4fee\u6539\u5668\u6765\u8bbe\u7f6e\u4e00\u4e2a\u8fd1\u4f3c\u4e8e\u5217\u8868\u4e2d\u4e00\u884c\u7684\u5927\u5c0f\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 Group \u4ece\u4e00\u4e2a\u9884\u89c8\u63d0\u4f9b\u8005\u8fd4\u56de\u591a\u4e2a\u9884\u89c8\u3002 \u7b2c\u4e09\u6b65 \u5c06\u8fd4\u56de\u7684\u884c\u5305\u5728 Group \u4e2d\uff0c\u518d\u5c06\u7b2c\u4e00\u884c\u6dfb\u52a0\u56de\u6765\u3002 Group \u662f\u4e00\u4e2a\u7528\u4e8e\u5206\u7ec4\u89c6\u56fe\u5185\u5bb9\u7684\u5bb9\u5668\u3002Xcode\u5c06\u8be5\u7ec4\u7684\u5b50\u89c6\u56fe\u4f5c\u4e3a\u5355\u72ec\u7684\u9884\u89c8\u663e\u793a\u5728\u753b\u5e03\u4e2d\u3002 \u7b2c\u56db\u6b65 \u4e3a\u4e86\u7b80\u5316\u4ee3\u7801\uff0c\u5c06 previewLayout(_:) \u8c03\u7528\u79fb\u5230\u7ec4\u7684\u5b50\u58f0\u660e\u7684\u5916\u9762\u3002 \u89c6\u56fe\u7684\u5b50\u58f0\u660e\u7ee7\u627f\u4e86\u89c6\u56fe\u7684\u4e0a\u4e0b\u6587\u8bbe\u7f6e\uff0c\u5982\u9884\u89c8\u914d\u7f6e\u3002 \u60a8\u5728\u9884\u89c8\u63d0\u4f9b\u8005\u4e2d\u7f16\u5199\u7684\u4ee3\u7801\u53ea\u6539\u53d8Xcode\u5728\u753b\u5e03\u4e2d\u663e\u793a\u7684\u5185\u5bb9\u3002 // // LandmarkRow.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import SwiftUI struct LandmarkRow: View { var landmark: Landmark var body: some View { HStack { landmark.image .resizable() .frame(width: 50, height: 50) Text(landmark.name) Spacer() } } } struct LandmarkRow_Previews: PreviewProvider { static var previews: some View { Group { LandmarkRow(landmark: landmarkData[0]) LandmarkRow(landmark: landmarkData[1]) } .previewLayout(.fixed(width: 300, height: 70)) } } Step 1 In LandmarkRow_Previews , update the landmark parameter to be the second element in the landmarkData array. The preview immediately changes to show the second sample landmark instead of the first. Step 2 Use the previewLayout(_:) modifier to set a size that approximates a row in a list. You can use a Group to return multiple previews from a preview provider. Step 3 Wrap the returned row in a Group , and add the first row back again. Group is a container for grouping view content. Xcode renders the group\u2019s child views as separate previews in the canvas. Step 4 To simplify the code, move the previewLayout(_:) call to the outside of the group\u2019s child declarations. A view\u2019s children inherit the view\u2019s contextual settings, such as preview configurations. The code you write in a preview provider only changes what Xcode displays in the canvas. 4.\u521b\u5efa\u5730\u6807\u5217\u8868-Create the List of Landmarks \u5f53\u4f60\u4f7f\u7528SwiftUI\u7684 List \u7c7b\u578b\u65f6\uff0c\u4f60\u53ef\u4ee5\u663e\u793a\u4e00\u4e2a\u5e73\u53f0\u7279\u5b9a\u7684\u89c6\u56fe\u5217\u8868\u3002\u5217\u8868\u4e2d\u7684\u5143\u7d20\u53ef\u4ee5\u662f\u9759\u6001\u7684\uff0c\u6bd4\u5982\u5230\u76ee\u524d\u4e3a\u6b62\u4f60\u5df2\u7ecf\u521b\u5efa\u7684\u5806\u6808\u7684\u5b50\u89c6\u56fe\uff0c\u4e5f\u53ef\u4ee5\u662f\u52a8\u6001\u751f\u6210\u7684\u3002\u4f60\u751a\u81f3\u53ef\u4ee5\u6df7\u5408\u9759\u6001\u548c\u52a8\u6001\u751f\u6210\u7684\u89c6\u56fe\u3002 When you use SwiftUI\u2019s List type, you can display a platform-specific list of views. The elements of the list can be static, like the child views of the stacks you\u2019ve created so far, or dynamically generated. You can even mix static and dynamically generated views. \u7b2c1\u6b65 \u521b\u5efa\u4e00\u4e2a\u65b0\u7684SwiftUI\u89c6\u56fe\uff0c\u547d\u540d\u4e3a LandmarkList.swift \u3002 \u7b2c\u4e8c\u6b65 \u5c06\u9ed8\u8ba4\u7684 \"Text \"view\u66ff\u6362\u4e3a \"List\"\uff0c\u5e76\u63d0\u4f9b \"LandmarkRow \"\u5b9e\u4f8b\uff0c\u5c06\u524d\u4e24\u4e2a\u5730\u6807\u4f5c\u4e3a\u5217\u8868\u7684\u5b50\u8282\u70b9\u3002 \u9884\u89c8\u4ee5\u9002\u5408iOS\u7684\u5217\u8868\u6837\u5f0f\u663e\u793a\u4e24\u4e2a\u5730\u6807\u3002 // // LandmarkList.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import SwiftUI struct LandmarkList: View { var body: some View { List { LandmarkRow(landmark: landmarkData[0]) LandmarkRow(landmark: landmarkData[1]) } } } struct LandmarkList_Previews: PreviewProvider { static var previews: some View { LandmarkList() } } Step 1 Create a new SwiftUI view, named LandmarkList.swift . Step 2 Replace the default Text view with a List , and provide LandmarkRow instances with the first two landmarks as the list\u2019s children. The preview shows the two landmarks rendered in a list style that\u2019s appropriate for iOS. 5.\u521b\u5efa\u52a8\u6001\u5217\u8868-Make the List Dynamic \u4f60\u53ef\u4ee5\u4e0d\u5355\u72ec\u6307\u5b9a\u4e00\u4e2a\u5217\u8868\u7684\u5143\u7d20\uff0c\u800c\u662f\u76f4\u63a5\u4ece\u4e00\u4e2a\u96c6\u5408\u4e2d\u751f\u6210\u884c\u3002 \u60a8\u53ef\u4ee5\u901a\u8fc7\u4f20\u9012\u60a8\u7684\u6570\u636e\u96c6\u5408\u548c\u4e00\u4e2a\u4e3a\u96c6\u5408\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u63d0\u4f9b\u89c6\u56fe\u7684\u95ed\u5305\u6765\u521b\u5efa\u4e00\u4e2a\u663e\u793a\u96c6\u5408\u5143\u7d20\u7684\u5217\u8868\u3002\u5217\u8868\u901a\u8fc7\u4f7f\u7528\u63d0\u4f9b\u7684\u95ed\u5305\u5c06\u96c6\u5408\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8f6c\u6362\u4e3a\u4e00\u4e2a\u5b50\u89c6\u56fe\u3002 Instead of specifying a list\u2019s elements individually, you can generate rows directly from a collection. You can create a list that displays the elements of collection by passing your collection of data and a closure that provides a view for each element in the collection. The list transforms each element in the collection into a child view by using the supplied closure. \u6b65\u9aa41 \u5220\u9664\u4e24\u4e2a\u9759\u6001\u7684\u5730\u6807\u884c\uff0c\u800c\u5c06 landmarkData \u4f20\u9012\u7ed9 List initializer\u3002 Lists\u7684\u5de5\u4f5c\u539f\u7406\u662f identifiable data\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u4e24\u79cd\u65b9\u5f0f\u4e4b\u4e00\u6765\u4f7f\u4f60\u7684\u6570\u636e\u53ef\u8bc6\u522b\uff1a\u901a\u8fc7\u4e0e\u4f60\u7684\u6570\u636e\u4e00\u8d77\u4f20\u9012\u4e00\u4e2a\u952e\u8def\u5f84\u5230\u4e00\u4e2a\u552f\u4e00\u6807\u8bc6\u6bcf\u4e2a\u5143\u7d20\u7684\u5c5e\u6027\uff0c\u6216\u8005\u901a\u8fc7\u4f7f\u4f60\u7684\u6570\u636e\u7c7b\u578b\u7b26\u5408 Identifiable \u534f\u8bae\u3002 \u7b2c\u4e8c\u6b65 \u901a\u8fc7\u4ece\u95ed\u5305\u4e2d\u8fd4\u56de\u4e00\u4e2a LandmarkRow \u6765\u5b8c\u6210\u52a8\u6001\u751f\u6210\u7684\u5217\u8868\u3002 \u8fd9\u5c06\u4e3a \"landmarkData \"\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u521b\u5efa\u4e00\u4e2a \"LandmarkRow\"\u3002 \u63a5\u4e0b\u6765\uff0c\u4f60\u5c06\u901a\u8fc7\u5728 Landmark \u7c7b\u578b\u4e2d\u6dfb\u52a0 Identifiable conformance \u6765\u7b80\u5316 List \u4ee3\u7801\u3002 \u7b2c\u4e09\u6b65 \u5207\u6362\u5230 \"Landmark.swift \"\u5e76\u58f0\u660e\u7b26\u5408 \"Identifiable \"\u534f\u8bae\u3002 \u7531\u4e8e Landmark \u7c7b\u578b\u5df2\u7ecf\u5177\u6709 Identifiable protocol\u6240\u8981\u6c42\u7684 id \u5c5e\u6027\uff0c\u6240\u4ee5\u6ca1\u6709\u66f4\u591a\u7684\u5de5\u4f5c\u8981\u505a\u3002 \u7b2c\u56db\u6b65 \u5207\u6362\u56de LandmarkList.swift \u5e76\u5220\u9664 id \u53c2\u6570\u3002 \u4ece\u73b0\u5728\u5f00\u59cb\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 Landmark \u5143\u7d20\u7684\u96c6\u5408\u3002 Step 1 Remove the two static landmark rows, and instead pass landmarkData to the List initializer. Lists work with identifiable data. You can make your data identifiable in one of two ways: by passing along with your data a key path to a property that uniquely identifies each element, or by making your data type conform to the Identifiable protocol. Step 2 Complete the dynamically-generated list by returning a LandmarkRow from the closure. This creates one LandmarkRow for each element in the landmarkData array. Next, you\u2019ll simplify the List code by adding Identifiable conformance to the Landmark type. Step 3 Switch to Landmark.swift and declare conformance to the Identifiable protocol. Since the Landmark type already has the id property required by Identifiable protocol, there\u2019s no more work to do. Step 4 Switch back to LandmarkList.swift and remove the id parameter. From now on, you\u2019ll be able to use collections of Landmark elements directly. 6.\u8bbe\u7f6e\u5217\u8868\u548c\u8be6\u7ec6\u4fe1\u606f\u4e4b\u95f4\u7684\u5bfc\u822a-Set Up Navigation Between List and Detail \u5217\u8868\u663e\u793a\u6b63\u786e\uff0c\u4f46\u4f60\u8fd8\u4e0d\u80fd\u70b9\u51fb\u4e00\u4e2a\u5355\u72ec\u7684\u5730\u6807\u6765\u67e5\u770b\u8be5\u5730\u6807\u7684\u8be6\u7ec6\u9875\u9762\u3002 \u60a8\u53ef\u4ee5\u901a\u8fc7\u5c06\u5217\u8868\u5d4c\u5165\u5230\u4e00\u4e2a \"\u5bfc\u822a\u89c6\u56fe \"\u4e2d\u6765\u6dfb\u52a0\u5bfc\u822a\u529f\u80fd\uff0c\u7136\u540e\u5c06\u6bcf\u4e00\u884c\u5d4c\u5957\u5728\u4e00\u4e2a \"\u5bfc\u822a\u94fe\u63a5 \"\u4e2d\uff0c\u4ee5\u8bbe\u7f6e\u4e00\u4e2a\u5230\u76ee\u6807\u89c6\u56fe\u7684\u8f6c\u6362\u3002 The list renders properly, but you can\u2019t tap an individual landmark to see that landmark\u2019s detail page yet. You add navigation capabilities to a list by embedding it in a NavigationView , and then nesting each row in a NavigationLink to set up a transtition to a destination view. \u7b2c\u4e00\u6b65 \u5c06\u52a8\u6001\u751f\u6210\u7684\u5730\u6807\u5217\u8868\u5d4c\u5165\u5230 NavigationView \u4e2d\u3002 \u7b2c\u4e8c\u6b65\uff1a\u5c06\u52a8\u6001\u751f\u6210\u7684\u5730\u6807\u5217\u8868\u5d4c\u5165\u5230\u5bfc\u822a\u89c6\u56fe\u4e2d\u3002 \u8c03\u7528 navigationBarTitle(_:) \u4fee\u6539\u5668\u65b9\u6cd5\u6765\u8bbe\u7f6e\u663e\u793a\u5217\u8868\u65f6\u5bfc\u822a\u680f\u7684\u6807\u9898\u3002 \u7b2c\u4e09\u6b65 \u5728\u5217\u8868\u7684\u95ed\u5408\u4e2d\uff0c\u5c06\u8fd4\u56de\u7684\u884c\u5305\u88f9\u5728\u4e00\u4e2a NavigationLink \u4e2d\uff0c\u6307\u5b9a LandmarkDetail view\u4f5c\u4e3a\u76ee\u6807\u3002 \u7b2c\u56db\u6b65 \u60a8\u53ef\u4ee5\u901a\u8fc7\u5207\u6362\u5230\u5b9e\u65f6\u6a21\u5f0f\uff0c\u76f4\u63a5\u5728\u9884\u89c8\u4e2d\u8bd5\u7528\u5bfc\u822a\u3002\u70b9\u51fb \"\u5b9e\u65f6\u9884\u89c8 \"\u6309\u94ae\uff0c\u5e76\u70b9\u51fb\u4e00\u4e2a\u5730\u6807\u6765\u8bbf\u95ee\u8be6\u7ec6\u9875\u9762\u3002 Step 1 Embed the dynamically generated list of landmarks in a NavigationView . Step 2 Call the navigationBarTitle(_:) modifier method to set the title of the navigation bar when displaying the list. Step 3 Inside the list\u2019s closure, wrap the returned row in a NavigationLink , specifying the LandmarkDetail view as the destination. Step 4 You can try out the navigation directly in the preview by switching to live mode. Click the Live Preview button and tap a landmark to visit the detail page. 7.\u5c06\u6570\u636e\u4f20\u9012\u81f3\u5b50\u89c6\u56fe-Pass Data into Child Views \"LandmarkDetail \"\u89c6\u56fe\u4ecd\u7136\u4f7f\u7528\u786c\u7f16\u7801\u7684\u7ec6\u8282\u6765\u663e\u793a\u5176\u5730\u6807\u3002\u5c31\u50cf \"LandmarkRow \"\u4e00\u6837\uff0c\"LandmarkDetail \"\u7c7b\u578b\u548c\u5b83\u6240\u5305\u542b\u7684\u89c6\u56fe\u9700\u8981\u4f7f\u7528 \"landmark \"\u5c5e\u6027\u4f5c\u4e3a\u5176\u6570\u636e\u7684\u6765\u6e90\u3002 \u4ece\u5b50\u89c6\u56fe\u5f00\u59cb\uff0c\u4f60\u5c06\u8f6c\u6362 CircleImage \uff0c MapView \uff0c\u7136\u540e LandmarkDetail \u6765\u663e\u793a\u4f20\u5165\u7684\u6570\u636e\uff0c\u800c\u4e0d\u662f\u786c\u7f16\u7801\u6bcf\u884c\u3002 The LandmarkDetail view still uses hard-coded details to show its landmark. Just like LandmarkRow , the LandmarkDetail type and the views it comprises need to use a landmark property as the source for their data. Starting with the child views, you\u2019ll convert CircleImage , MapView , and then LandmarkDetail to display data that\u2019s passed in, rather than hard-coding each row. \u7b2c\u4e00\u6b65 \u5728 CircleImage.swift \u4e2d\uff0c\u4e3a CircleImage \u6dfb\u52a0\u4e00\u4e2a\u5b58\u50a8 \u56fe\u50cf \u5c5e\u6027\u3002 \u8fd9\u662f\u4f7f\u7528SwiftUI\u6784\u5efa\u89c6\u56fe\u65f6\u7684\u5e38\u89c1\u6a21\u5f0f\u3002\u4f60\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\u901a\u5e38\u4f1a\u5305\u88f9\u548c\u5c01\u88c5\u4e00\u7cfb\u5217\u7279\u5b9a\u89c6\u56fe\u7684\u4fee\u6539\u5668\u3002 \u7b2c\u4e8c\u6b65 \u66f4\u65b0\u9884\u89c8\u63d0\u4f9b\u8005\u4ee5\u4f20\u9012\u9f9f\u77f3\u7684\u56fe\u50cf\u3002 \u7b2c\u4e09\u6b65 \u5728MapView.swift\u4e2d\uff0c\u7ed9MapView\u6dfb\u52a0\u4e00\u4e2a\u5750\u6807\u5c5e\u6027\uff0c\u5e76\u5c06\u4ee3\u7801\u8f6c\u6362\u4e3a\u4f7f\u7528\u8be5\u5c5e\u6027\uff0c\u800c\u4e0d\u662f\u786c\u7f16\u7801\u7ecf\u7eac\u5ea6\u3002 \u7b2c\u56db\u6b65 \u66f4\u65b0\u9884\u89c8\u63d0\u4f9b\u8005\u4ee5\u4f20\u9012\u6570\u636e\u6570\u7ec4\u4e2d\u7b2c\u4e00\u4e2a\u5730\u6807\u7684\u5750\u6807\u3002 \u7b2c\u4e94\u6b65 \u66f4\u65b0\u9884\u89c8\u63d0\u4f9b\u8005\uff0c\u4f20\u9012\u6570\u636e\u9635\u5217\u4e2d\u7b2c\u4e00\u4e2a\u5730\u6807\u7684\u5750\u6807\u3002 \u5728 LandmarkDetail.swift \u4e2d\uff0c\u4e3a LandmarkDetail \u7c7b\u578b\u6dfb\u52a0 Landmark \u5c5e\u6027\u3002 \u7b2c\u516d\u6b65 \u66f4\u65b0\u9884\u89c8\uff0c\u4f7f\u7528 landmarkData \u4e2d\u7684\u7b2c\u4e00\u4e2a\u5730\u6807\u3002 \u7b2c\u4e03\u6b65 \u5c06\u6240\u9700\u6570\u636e\u4f20\u9012\u7ed9\u60a8\u7684\u81ea\u5b9a\u4e49\u7c7b\u578b\u3002 \u7b2c\u516b\u6b65 \u6700\u540e\uff0c\u8c03\u7528 navigationBarTitle(_:displayMode:) \u4fee\u6539\u5668\uff0c\u5728\u663e\u793a\u8be6\u7ec6\u89c6\u56fe\u65f6\uff0c\u7ed9\u5bfc\u822a\u680f\u4e00\u4e2a\u6807\u9898\u3002 \u7b2c\u4e5d\u6b65 \u5728 SceneDelegate.swift \u4e2d\uff0c\u5c06\u5e94\u7528\u7a0b\u5e8f\u7684\u6839\u89c6\u56fe\u5207\u6362\u4e3a LandmarkList \u3002 \u5f53\u5728\u6a21\u62df\u5668\u4e2d\u72ec\u7acb\u8fd0\u884c\u65f6\uff0c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u5c06\u4ee5 SceneDelegate \u4e2d\u5b9a\u4e49\u7684\u6839\u89c6\u56fe\u542f\u52a8\uff0c\u800c\u4e0d\u662f\u9884\u89c8\u3002 \u7b2c\u5341\u6b65\uff1a\u5c06\u5e94\u7528\u7a0b\u5e8f\u7684\u6839\u89c6\u56fe\u5207\u6362\u4e3a \"LandmarkList\"\u3002 \u5728 LandmarkList.swift \u4e2d\uff0c\u5c06\u5f53\u524d\u7684\u5730\u6807\u4f20\u9012\u7ed9\u76ee\u6807 LandmarkDetail \u3002 \u7b2c\u5341\u4e00\u6b65\uff1a\u5c06\u5f53\u524d\u7684\u5730\u6807\u4f20\u7ed9\u76ee\u7684\u5730 LandmarkDetail \u3002 \u5207\u6362\u5230\u5b9e\u65f6\u9884\u89c8\uff0c\u5f53\u60a8\u4ece\u5217\u8868\u4e2d\u5bfc\u822a\u65f6\uff0c\u53ef\u4ee5\u770b\u5230\u8be6\u7ec6\u89c6\u56fe\u663e\u793a\u6b63\u786e\u7684\u5730\u6807\u3002 Step 1 In CircleImage.swift , add a stored image property to CircleImage . This is a common pattern when building views using SwiftUI. Your custom views will often wrap and encapsulate a series of modifiers for a particular view. Step 2 Update the preview provider to pass the image of Turtle Rock. Step 3 In MapView.swift , add a coordinate property to MapView and convert the code to use that property instead of hard-coding the latitude and longitude. Step 4 Update the preview provider to pass the coordinate of the first landmark in the data array. Step 5 In LandmarkDetail.swift , add a Landmark property to the LandmarkDetail type. Step 6 Update the preview to use the first landmark from landmarkData . Step 7 Pass the required data down to your custom types. Step 8 Finally, call the navigationBarTitle(_:displayMode:) modifier to give the navigation bar a title when showing the detail view. Step 9 In SceneDelegate.swift , switch the root view of the app to be LandmarkList . Your app starts with the root view defined in the SceneDelegate when running standalone in the simulator instead of the preview. Step 10 In LandmarkList.swift , pass the current landmark to the destination LandmarkDetail . Step 11 Switch to the live preview to see the detail view show the correct landmarks when you navigate from the list. 8.\u52a8\u6001\u751f\u6210\u9884\u89c8- Previews Dynamically \u63a5\u4e0b\u6765\uff0c\u60a8\u5c06\u4e3a LandmarkList_Previews preview \u63d0\u4f9b\u8005\u6dfb\u52a0\u4ee3\u7801\uff0c\u4ee5\u5728\u4e0d\u540c\u7684\u8bbe\u5907\u5c3a\u5bf8\u4e0b\u6e32\u67d3\u5217\u8868\u89c6\u56fe\u7684\u9884\u89c8\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u9884\u89c8\u4ee5\u6d3b\u52a8\u65b9\u6848\u4e2d\u7684\u8bbe\u5907\u5c3a\u5bf8\u5448\u73b0\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 previewDevice(_:) modifier\u65b9\u6cd5\u6765\u6539\u53d8\u9884\u89c8\u8bbe\u5907\u3002 Next, you\u2019ll add code to the LandmarkList_Previews preview provider to render previews of the list view at different device sizes. By default, previews render at the size of the device in the active scheme. You can change the preview device by calling the previewDevice(_:) modifier method. \u6b65\u9aa4\u4e00 \u9996\u5148\u5c06\u5f53\u524d\u7684\u5217\u8868\u9884\u89c8\u6539\u4e3a\u4ee5iPhone SE\u7684\u5927\u5c0f\u8fdb\u884c\u6e32\u67d3\u3002 \u60a8\u53ef\u4ee5\u63d0\u4f9b\u4efb\u4f55\u8bbe\u5907\u7684\u540d\u79f0\uff0c\u56e0\u4e3a\u5b83\u51fa\u73b0\u5728Xcode\u7684\u65b9\u6848\u83dc\u5355\u4e2d\u3002 \u7b2c\u4e8c\u6b65 \u5728\u5217\u8868\u9884\u89c8\u4e2d\uff0c\u5c06 \"LandmarkList \"\u5d4c\u5165\u5230 \"ForEach \"\u5b9e\u4f8b\u4e2d\uff0c\u4f7f\u7528\u8bbe\u5907\u540d\u79f0\u6570\u7ec4\u4f5c\u4e3a\u6570\u636e\u3002 ForEach \u5bf9\u96c6\u5408\u7684\u64cd\u4f5c\u65b9\u5f0f\u4e0e\u5217\u8868\u76f8\u540c\uff0c\u8fd9\u610f\u5473\u7740\u60a8\u53ef\u4ee5\u5728\u4efb\u4f55\u53ef\u4ee5\u4f7f\u7528\u5b50\u89c6\u56fe\u7684\u5730\u65b9\u4f7f\u7528\u5b83\uff0c\u4f8b\u5982\u5728\u5806\u6808\u3001\u5217\u8868\u3001\u7ec4\u7b49\u4e2d\u3002\u5f53\u4f60\u7684\u6570\u636e\u5143\u7d20\u662f\u7b80\u5355\u7684\u503c\u7c7b\u578b\u65f6--\u5c31\u50cf\u4f60\u5728\u8fd9\u91cc\u4f7f\u7528\u7684\u5b57\u7b26\u4e32--\u4f60\u53ef\u4ee5\u4f7f\u7528 .self \u4f5c\u4e3a\u6807\u8bc6\u7b26\u7684\u952e\u8def\u5f84\u3002 \u7b2c\u4e09\u6b65 \u4f7f\u7528 previewDisplayName(_:) \u4fee\u6539\u5668\u6dfb\u52a0\u8bbe\u5907\u540d\u79f0\u4f5c\u4e3a\u9884\u89c8\u7684\u6807\u7b7e\u3002 \u7b2c\u56db\u6b65 \u60a8\u53ef\u4ee5\u4f7f\u7528\u4e0d\u540c\u7684\u8bbe\u5907\u8fdb\u884c\u5b9e\u9a8c\uff0c\u6bd4\u8f83\u60a8\u7684\u89c6\u56fe\u7684\u6e32\u67d3\u6548\u679c\uff0c\u6240\u6709\u8fd9\u4e9b\u90fd\u6765\u81ea\u753b\u5e03\u3002 Step 1 Start by changing the current list preview to render at the size of an iPhone SE. You can provide the name of any device as it appears in Xcode\u2019s scheme menu. Step 2 Within the list preview, embed the LandmarkList in a ForEach instance, using an array of device names as the data. ForEach operates on collections the same way as the list, which means you can use it anywhere you can use a child view, such as in stacks, lists, groups, and more. When the elements of your data are simple value types \u2014 like the strings you\u2019re using here \u2014 you can use \\.self as key path to the identifier. Step 3 Use the previewDisplayName(_:) modifier to add the device names as labels for the previews. Step 4 You can experiment with different devices to compare the renderings of your views, all from the canvas.","title":"\u6784\u5efa\u5217\u8868\u548c\u5bfc\u822a-BuildingListsAndNavigation"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/2.%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AF%BC%E8%88%AA-BuildingListsAndNavigation/#-buildinglistsandnavigation","text":"\u5728\u8bbe\u7f6e\u4e86\u57fa\u672c\u7684\u5730\u6807\u8be6\u7ec6\u89c6\u56fe\u540e\uff0c\u60a8\u9700\u8981\u63d0\u4f9b\u4e00\u79cd\u65b9\u5f0f\u8ba9\u7528\u6237\u67e5\u770b\u5b8c\u6574\u7684\u5730\u6807\u5217\u8868\uff0c\u5e76\u67e5\u770b\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u8be6\u7ec6\u4fe1\u606f\u3002 \u60a8\u5c06\u521b\u5efa\u53ef\u4ee5\u663e\u793a\u4efb\u4f55\u5730\u6807\u4fe1\u606f\u7684\u89c6\u56fe\uff0c\u5e76\u52a8\u6001\u751f\u6210\u4e00\u4e2a\u6eda\u52a8\u5217\u8868\uff0c\u7528\u6237\u53ef\u4ee5\u70b9\u51fb\u8be5\u5217\u8868\u67e5\u770b\u67d0\u4e2a\u5730\u6807\u7684\u8be6\u7ec6\u89c6\u56fe\u3002\u4e3a\u4e86\u5bf9\u7528\u6237\u754c\u9762\u8fdb\u884c\u5fae\u8c03\uff0c\u60a8\u5c06\u4f7f\u7528Xcode\u7684\u753b\u5e03\u5728\u4e0d\u540c\u7684\u8bbe\u5907\u5c3a\u5bf8\u4e0b\u5448\u73b0\u591a\u4e2a\u9884\u89c8\u3002 \u4e0b\u8f7d\u9879\u76ee\u6587\u4ef6\u5f00\u59cb\u6784\u5efa\u8fd9\u4e2a\u9879\u76ee\uff0c\u5e76\u6309\u7167\u4ee5\u4e0b\u6b65\u9aa4\u8fdb\u884c\u3002 With the basic landmark detail view set up, you need to provide a way for users to see the full list of landmarks, and to view the details about each location. You\u2019ll create views that can show information about any landmark, and dynamically generate a scrolling list that a user can tap to see a detail view for a landmark. To fine-tune the UI, you\u2019ll use Xcode\u2019s canvas to render multiple previews at different device sizes. Download the project files to begin building this project, and follow the steps below. \u9879\u76ee\u6587\u4ef6\u4e0b\u8f7d","title":"\u6784\u5efa\u5217\u8868\u548c\u5bfc\u822a-BuildingListsAndNavigation"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/2.%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AF%BC%E8%88%AA-BuildingListsAndNavigation/#1-get-to-know-the-sample-data","text":"\u5728\u7b2c\u4e00\u7bc7\u6559\u7a0b\u4e2d\uff0c\u4f60\u5c06\u4fe1\u606f\u786c\u7f16\u7801\u5230\u6240\u6709\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\u4e2d\u3002\u5728\u8fd9\u91cc\uff0c\u60a8\u5c06\u5b66\u4e60\u5982\u4f55\u5c06\u6570\u636e\u4f20\u9012\u5230\u60a8\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\u4e2d\u8fdb\u884c\u663e\u793a\u3002 \u4e0b\u8f7d\u5165\u95e8\u9879\u76ee\u5e76\u719f\u6089\u6837\u672c\u6570\u636e\uff0c\u5373\u53ef\u5f00\u59cb\u5b66\u4e60\u3002 In the first tutorial, you hard-coded information into all of your custom views. Here, you\u2019ll learn to pass data into your custom views for display. Get started by downloading the starter project and familiarizing yourself with the sample data. \u7b2c\u4e00\u6b65 \u5728\u9879\u76ee\u5bfc\u822a\u5668\u4e2d\uff0c\u9009\u62e9 Models > Landmark.swift \u3002 Landmark.swift \u58f0\u660e\u4e00\u4e2a Landmark \u7ed3\u6784\uff0c\u8be5\u7ed3\u6784\u5b58\u50a8\u4e86\u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u663e\u793a\u7684\u6240\u6709\u5730\u6807\u4fe1\u606f\uff0c\u5e76\u4ece landmarkData.json \u5bfc\u5165\u4e00\u4e2a\u5730\u6807\u6570\u636e\u6570\u7ec4\u3002 \u7b2c\u4e8c\u6b65 \u5728\u9879\u76ee\u5bfc\u822a\u5668\u4e2d\uff0c\u9009\u62e9 Resources > landmarkData.json \u3002 \u60a8\u5c06\u5728\u672c\u6559\u7a0b\u7684\u5176\u4f59\u90e8\u5206\u4ee5\u53ca\u540e\u7eed\u7684\u6240\u6709\u5185\u5bb9\u4e2d\u4f7f\u7528\u8fd9\u4e2a\u6837\u672c\u6570\u636e\u3002 \u7b2c\u4e09\u6b65 \u8bf7\u6ce8\u610f\uff0c \u521b\u5efa\u5e76\u7ec4\u5408\u89c6\u56fe-CreatingAndCombiningViews \u8fd9\u4e00\u8282\u4e2d\u7684 ContentView \u73b0\u5728\u88ab\u547d\u540d\u4e3a LandmarkDetail \u3002 \u5728\u672c\u6559\u7a0b\u548c\u4e0b\u9762\u7684\u6bcf\u4e2a\u6559\u7a0b\u4e2d\uff0c\u60a8\u5c06\u521b\u5efa\u66f4\u591a\u7684\u89c6\u56fe\u7c7b\u578b\u3002 // // Landmark.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import SwiftUI import CoreLocation struct Landmark: Hashable, Codable { var id: Int var name: String fileprivate var imageName: String fileprivate var coordinates: Coordinates var state: String var park: String var category: Category var locationCoordinate: CLLocationCoordinate2D { CLLocationCoordinate2D( latitude: coordinates.latitude, longitude: coordinates.longitude) } enum Category: String, CaseIterable, Codable, Hashable { case featured = \"Featured\" case lakes = \"Lakes\" case rivers = \"Rivers\" } } extension Landmark { var image: Image { ImageStore.shared.image(name: imageName) } } struct Coordinates: Hashable, Codable { var latitude: Double var longitude: Double } Step 1 In the Project navigator, choose Models > Landmark.swift . Landmark.swift declares a Landmark structure that stores all of the landmark information the app needs to display, and imports an array of landmark data from landmarkData.json . Step 2 In the Project navigator, choose Resources > landmarkData.json . You\u2019ll use this sample data throughout the remainder of this tutorial, and for all that follow. Step 3 Note that the ContentView type from Creating and Combining Views is now named LandmarkDetail . You\u2019ll create several more view types in this and each of the following tutorials.","title":"1.\u4e86\u89e3\u7b80\u5355\u6570\u636e-Get to Know the Sample Data"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/2.%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AF%BC%E8%88%AA-BuildingListsAndNavigation/#2-create-the-row-view","text":"\u5728\u672c\u6559\u7a0b\u4e2d\uff0c\u60a8\u5c06\u6784\u5efa\u7684\u7b2c\u4e00\u4e2a\u89c6\u56fe\u662f\u4e00\u4e2a\u7528\u4e8e\u663e\u793a\u6bcf\u4e2a\u5730\u6807\u8be6\u7ec6\u4fe1\u606f\u7684\u884c\u3002\u8fd9\u4e2a\u884c\u89c6\u56fe\u5c06\u4fe1\u606f\u5b58\u50a8\u5728\u5b83\u6240\u663e\u793a\u7684\u5730\u6807\u7684\u5c5e\u6027\u4e2d\uff0c\u56e0\u6b64\u4e00\u4e2a\u89c6\u56fe\u53ef\u4ee5\u663e\u793a\u4efb\u4f55\u5730\u6807\u3002\u7a0d\u540e\uff0c\u60a8\u5c06\u628a\u591a\u4e2a\u884c\u7ec4\u5408\u6210\u4e00\u4e2a\u5730\u6807\u5217\u8868\u3002 The first view you\u2019ll build in this tutorial is a row for displaying details about each landmark. This row view stores information in a property for the landmark it displays, so that one view can display any landmark. Later, you\u2019ll combine multiple rows into a list of landmarks. \u7b2c\u4e00\u6b65 \u521b\u5efa\u4e00\u4e2a\u65b0\u7684SwiftUI\u89c6\u56fe\uff0c\u547d\u540d\u4e3a LandmarkRow.swift \u3002 \u7b2c\u4e8c\u6b65 \u5982\u679c\u9884\u89c8\u8fd8\u4e0d\u53ef\u89c1\uff0c\u9009\u62e9 Editor > Canvas \uff0c\u7136\u540e\u70b9\u51fb Resume \u6765\u663e\u793a\u753b\u5e03\u3002 \u7b2c\u4e09\u6b65 \u6dfb\u52a0 landmark \u4f5c\u4e3a LandmarkRow \u7684\u4e00\u4e2a\u5b58\u50a8\u5c5e\u6027\u3002 \u5f53\u4f60\u6dfb\u52a0 landmark \u5c5e\u6027\u65f6\uff0c\u9884\u89c8\u505c\u6b62\u5de5\u4f5c\uff0c\u56e0\u4e3a LandmarkRow \u7c7b\u578b\u5728\u521d\u59cb\u5316\u65f6\u9700\u8981\u4e00\u4e2a\u5730\u6807\u5b9e\u4f8b\u3002 \u4e3a\u4e86\u6062\u590d\u9884\u89c8\uff0c\u4f60\u9700\u8981\u4fee\u6539\u9884\u89c8\u63d0\u4f9b\u8005(preview provider)\u3002 \u7b2c\u56db\u6b65 \u5728 LandmarkRow_Previews \u7684 previews static\u5c5e\u6027\u4e2d\uff0c\u5c06landmark\u53c2\u6570\u6dfb\u52a0\u5230 LandmarkRow \u521d\u59cb\u5316\u4e2d\uff0c\u6307\u5b9a landmarkData \u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u3002 \u9884\u89c8\u663e\u793a\u7684\u662f\u6587\u5b57\uff0c Hello World \u3002 \u56fa\u5b9a\u540e\uff0c\u60a8\u5c31\u53ef\u4ee5\u4e3a\u8be5\u884c\u5efa\u7acb\u5e03\u5c40\u4e86\u3002 \u7b2c\u4e94\u6b65 \u5c06\u73b0\u6709\u7684\u6587\u672c\u89c6\u56fe\u5d4c\u5165\u5230 HStack \u4e2d\u3002 \u7b2c\u516d\u6b65 \u4fee\u6539\u6587\u672c\u89c6\u56fe\uff0c\u4f7f\u7528 landmark \u5c5e\u6027\u7684 name \u3002 \u7b2c\u4e03\u6b65 \u5728\u6587\u672c\u89c6\u56fe\u524d\u6dfb\u52a0\u56fe\u50cf\uff0c\u5728\u6587\u672c\u89c6\u56fe\u540e\u6dfb\u52a0spacer\uff0c\u4ece\u800c\u5b8c\u6210\u884c // // LandmarkRow.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import SwiftUI struct LandmarkRow: View { var landmark: Landmark var body: some View { HStack { landmark.image .resizable() .frame(width: 50, height: 50) Text(landmark.name) Spacer() } } } struct LandmarkRow_Previews: PreviewProvider { static var previews: some View { LandmarkRow(landmark: landmarkData[0]) } } // // Landmark.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import SwiftUI import CoreLocation struct Landmark: Hashable, Codable { var id: Int var name: String fileprivate var imageName: String fileprivate var coordinates: Coordinates var state: String var park: String var category: Category var locationCoordinate: CLLocationCoordinate2D { CLLocationCoordinate2D( latitude: coordinates.latitude, longitude: coordinates.longitude) } enum Category: String, CaseIterable, Codable, Hashable { case featured = \"Featured\" case lakes = \"Lakes\" case rivers = \"Rivers\" } } extension Landmark { var image: Image { Image(imageName) // ImageStore.shared.image(name: imageName) } } struct Coordinates: Hashable, Codable { var latitude: Double var longitude: Double } // // ModelData.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import Foundation var landmarkData: [Landmark] = load(\"landmarkData.json\") func load<T: Decodable>(_ filename: String) -> T { let data: Data guard let file = Bundle.main.url(forResource: filename, withExtension: nil) else { fatalError(\"Couldn't find \\(filename) in main bundle.\") } do { data = try Data(contentsOf: file) } catch { fatalError(\"Couldn't load \\(filename) from main bundle:\\n\\(error)\") } do { let decoder = JSONDecoder() return try decoder.decode(T.self, from: data) } catch { fatalError(\"Couldn't parse \\(filename) as \\(T.self):\\n\\(error)\") } } Step 1 Create a new SwiftUI view, named LandmarkRow.swift . Step 2 If the preview isn\u2019t visible already, show the canvas by selecting Editor > Canvas , and then click Resume . Step 3 Add landmark as a stored property of LandmarkRow . When you add the landmark property, the preview stops working, because the LandmarkRow type needs a landmark instance during initialization. To fix the preview, you\u2019ll need to modify the preview provider. Step 4 In the previews static property of LandmarkRow_Previews , add the landmark parameter to the LandmarkRow initializer, specifying the first element of the landmarkData array. The preview displays the text, Hello World . With that fixed, you can build the layout for the row. Step 5 Embed the existing text view in an HStack . Step 6 Modify the text view to use the landmark property\u2019s name . Step 7 Complete the row by adding an image before the text view, and a spacer after it.","title":"2.\u521b\u5efa\u884c\u89c6\u56fe-Create the Row View"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/2.%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AF%BC%E8%88%AA-BuildingListsAndNavigation/#3-customize-the-row-preview","text":"Xcode\u7684\u753b\u5e03\u4f1a\u81ea\u52a8\u8bc6\u522b\u5e76\u663e\u793a\u5f53\u524d\u7f16\u8f91\u5668\u4e2d\u7b26\u5408 \"PreviewProvider \"\u534f\u8bae\u7684\u4efb\u4f55\u7c7b\u578b\u3002\u9884\u89c8\u63d0\u4f9b\u8005\u4f1a\u8fd4\u56de\u4e00\u4e2a\u6216\u591a\u4e2a\u89c6\u56fe\uff0c\u5e76\u63d0\u4f9b\u914d\u7f6e\u5927\u5c0f\u548c\u8bbe\u5907\u7684\u9009\u9879\u3002 \u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u4ece\u9884\u89c8\u63d0\u4f9b\u8005\u8fd4\u56de\u7684\u5185\u5bb9\uff0c\u4ee5\u51c6\u786e\u5730\u5448\u73b0\u5bf9\u60a8\u6700\u6709\u5e2e\u52a9\u7684\u9884\u89c8\u3002 Xcode\u2019s canvas automatically recognizes and displays any type in the current editor that conforms to the PreviewProvider protocol. A preview provider returns one or more views, with options to configure the size and device. You can customize the returned content from a preview provider to render exactly the previews that are most helpful to you. \u7b2c\u4e00\u6b65 \u5728 LandmarkRow_Previews \u4e2d\uff0c\u66f4\u65b0 landmark \u53c2\u6570\u4e3a landmarkData \u6570\u7ec4\u4e2d\u7684\u7b2c\u4e8c\u4e2a\u5143\u7d20\u3002 \u9884\u89c8\u4f1a\u7acb\u5373\u6539\u53d8\uff0c\u663e\u793a\u7b2c\u4e8c\u4e2a\u6837\u672c\u5730\u6807\u800c\u4e0d\u662f\u7b2c\u4e00\u4e2a\u3002 \u7b2c\u4e8c\u6b65 \u4f7f\u7528 previewLayout(_:) \u4fee\u6539\u5668\u6765\u8bbe\u7f6e\u4e00\u4e2a\u8fd1\u4f3c\u4e8e\u5217\u8868\u4e2d\u4e00\u884c\u7684\u5927\u5c0f\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 Group \u4ece\u4e00\u4e2a\u9884\u89c8\u63d0\u4f9b\u8005\u8fd4\u56de\u591a\u4e2a\u9884\u89c8\u3002 \u7b2c\u4e09\u6b65 \u5c06\u8fd4\u56de\u7684\u884c\u5305\u5728 Group \u4e2d\uff0c\u518d\u5c06\u7b2c\u4e00\u884c\u6dfb\u52a0\u56de\u6765\u3002 Group \u662f\u4e00\u4e2a\u7528\u4e8e\u5206\u7ec4\u89c6\u56fe\u5185\u5bb9\u7684\u5bb9\u5668\u3002Xcode\u5c06\u8be5\u7ec4\u7684\u5b50\u89c6\u56fe\u4f5c\u4e3a\u5355\u72ec\u7684\u9884\u89c8\u663e\u793a\u5728\u753b\u5e03\u4e2d\u3002 \u7b2c\u56db\u6b65 \u4e3a\u4e86\u7b80\u5316\u4ee3\u7801\uff0c\u5c06 previewLayout(_:) \u8c03\u7528\u79fb\u5230\u7ec4\u7684\u5b50\u58f0\u660e\u7684\u5916\u9762\u3002 \u89c6\u56fe\u7684\u5b50\u58f0\u660e\u7ee7\u627f\u4e86\u89c6\u56fe\u7684\u4e0a\u4e0b\u6587\u8bbe\u7f6e\uff0c\u5982\u9884\u89c8\u914d\u7f6e\u3002 \u60a8\u5728\u9884\u89c8\u63d0\u4f9b\u8005\u4e2d\u7f16\u5199\u7684\u4ee3\u7801\u53ea\u6539\u53d8Xcode\u5728\u753b\u5e03\u4e2d\u663e\u793a\u7684\u5185\u5bb9\u3002 // // LandmarkRow.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import SwiftUI struct LandmarkRow: View { var landmark: Landmark var body: some View { HStack { landmark.image .resizable() .frame(width: 50, height: 50) Text(landmark.name) Spacer() } } } struct LandmarkRow_Previews: PreviewProvider { static var previews: some View { Group { LandmarkRow(landmark: landmarkData[0]) LandmarkRow(landmark: landmarkData[1]) } .previewLayout(.fixed(width: 300, height: 70)) } } Step 1 In LandmarkRow_Previews , update the landmark parameter to be the second element in the landmarkData array. The preview immediately changes to show the second sample landmark instead of the first. Step 2 Use the previewLayout(_:) modifier to set a size that approximates a row in a list. You can use a Group to return multiple previews from a preview provider. Step 3 Wrap the returned row in a Group , and add the first row back again. Group is a container for grouping view content. Xcode renders the group\u2019s child views as separate previews in the canvas. Step 4 To simplify the code, move the previewLayout(_:) call to the outside of the group\u2019s child declarations. A view\u2019s children inherit the view\u2019s contextual settings, such as preview configurations. The code you write in a preview provider only changes what Xcode displays in the canvas.","title":"3.\u81ea\u5b9a\u4e49\u884c\u9884\u89c8-Customize the Row Preview"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/2.%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AF%BC%E8%88%AA-BuildingListsAndNavigation/#4-create-the-list-of-landmarks","text":"\u5f53\u4f60\u4f7f\u7528SwiftUI\u7684 List \u7c7b\u578b\u65f6\uff0c\u4f60\u53ef\u4ee5\u663e\u793a\u4e00\u4e2a\u5e73\u53f0\u7279\u5b9a\u7684\u89c6\u56fe\u5217\u8868\u3002\u5217\u8868\u4e2d\u7684\u5143\u7d20\u53ef\u4ee5\u662f\u9759\u6001\u7684\uff0c\u6bd4\u5982\u5230\u76ee\u524d\u4e3a\u6b62\u4f60\u5df2\u7ecf\u521b\u5efa\u7684\u5806\u6808\u7684\u5b50\u89c6\u56fe\uff0c\u4e5f\u53ef\u4ee5\u662f\u52a8\u6001\u751f\u6210\u7684\u3002\u4f60\u751a\u81f3\u53ef\u4ee5\u6df7\u5408\u9759\u6001\u548c\u52a8\u6001\u751f\u6210\u7684\u89c6\u56fe\u3002 When you use SwiftUI\u2019s List type, you can display a platform-specific list of views. The elements of the list can be static, like the child views of the stacks you\u2019ve created so far, or dynamically generated. You can even mix static and dynamically generated views. \u7b2c1\u6b65 \u521b\u5efa\u4e00\u4e2a\u65b0\u7684SwiftUI\u89c6\u56fe\uff0c\u547d\u540d\u4e3a LandmarkList.swift \u3002 \u7b2c\u4e8c\u6b65 \u5c06\u9ed8\u8ba4\u7684 \"Text \"view\u66ff\u6362\u4e3a \"List\"\uff0c\u5e76\u63d0\u4f9b \"LandmarkRow \"\u5b9e\u4f8b\uff0c\u5c06\u524d\u4e24\u4e2a\u5730\u6807\u4f5c\u4e3a\u5217\u8868\u7684\u5b50\u8282\u70b9\u3002 \u9884\u89c8\u4ee5\u9002\u5408iOS\u7684\u5217\u8868\u6837\u5f0f\u663e\u793a\u4e24\u4e2a\u5730\u6807\u3002 // // LandmarkList.swift // Landmarks // // Created by EchoSun on 2020/12/22. // import SwiftUI struct LandmarkList: View { var body: some View { List { LandmarkRow(landmark: landmarkData[0]) LandmarkRow(landmark: landmarkData[1]) } } } struct LandmarkList_Previews: PreviewProvider { static var previews: some View { LandmarkList() } } Step 1 Create a new SwiftUI view, named LandmarkList.swift . Step 2 Replace the default Text view with a List , and provide LandmarkRow instances with the first two landmarks as the list\u2019s children. The preview shows the two landmarks rendered in a list style that\u2019s appropriate for iOS.","title":"4.\u521b\u5efa\u5730\u6807\u5217\u8868-Create the List of Landmarks"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/2.%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AF%BC%E8%88%AA-BuildingListsAndNavigation/#5-make-the-list-dynamic","text":"\u4f60\u53ef\u4ee5\u4e0d\u5355\u72ec\u6307\u5b9a\u4e00\u4e2a\u5217\u8868\u7684\u5143\u7d20\uff0c\u800c\u662f\u76f4\u63a5\u4ece\u4e00\u4e2a\u96c6\u5408\u4e2d\u751f\u6210\u884c\u3002 \u60a8\u53ef\u4ee5\u901a\u8fc7\u4f20\u9012\u60a8\u7684\u6570\u636e\u96c6\u5408\u548c\u4e00\u4e2a\u4e3a\u96c6\u5408\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u63d0\u4f9b\u89c6\u56fe\u7684\u95ed\u5305\u6765\u521b\u5efa\u4e00\u4e2a\u663e\u793a\u96c6\u5408\u5143\u7d20\u7684\u5217\u8868\u3002\u5217\u8868\u901a\u8fc7\u4f7f\u7528\u63d0\u4f9b\u7684\u95ed\u5305\u5c06\u96c6\u5408\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8f6c\u6362\u4e3a\u4e00\u4e2a\u5b50\u89c6\u56fe\u3002 Instead of specifying a list\u2019s elements individually, you can generate rows directly from a collection. You can create a list that displays the elements of collection by passing your collection of data and a closure that provides a view for each element in the collection. The list transforms each element in the collection into a child view by using the supplied closure. \u6b65\u9aa41 \u5220\u9664\u4e24\u4e2a\u9759\u6001\u7684\u5730\u6807\u884c\uff0c\u800c\u5c06 landmarkData \u4f20\u9012\u7ed9 List initializer\u3002 Lists\u7684\u5de5\u4f5c\u539f\u7406\u662f identifiable data\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u4e24\u79cd\u65b9\u5f0f\u4e4b\u4e00\u6765\u4f7f\u4f60\u7684\u6570\u636e\u53ef\u8bc6\u522b\uff1a\u901a\u8fc7\u4e0e\u4f60\u7684\u6570\u636e\u4e00\u8d77\u4f20\u9012\u4e00\u4e2a\u952e\u8def\u5f84\u5230\u4e00\u4e2a\u552f\u4e00\u6807\u8bc6\u6bcf\u4e2a\u5143\u7d20\u7684\u5c5e\u6027\uff0c\u6216\u8005\u901a\u8fc7\u4f7f\u4f60\u7684\u6570\u636e\u7c7b\u578b\u7b26\u5408 Identifiable \u534f\u8bae\u3002 \u7b2c\u4e8c\u6b65 \u901a\u8fc7\u4ece\u95ed\u5305\u4e2d\u8fd4\u56de\u4e00\u4e2a LandmarkRow \u6765\u5b8c\u6210\u52a8\u6001\u751f\u6210\u7684\u5217\u8868\u3002 \u8fd9\u5c06\u4e3a \"landmarkData \"\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u521b\u5efa\u4e00\u4e2a \"LandmarkRow\"\u3002 \u63a5\u4e0b\u6765\uff0c\u4f60\u5c06\u901a\u8fc7\u5728 Landmark \u7c7b\u578b\u4e2d\u6dfb\u52a0 Identifiable conformance \u6765\u7b80\u5316 List \u4ee3\u7801\u3002 \u7b2c\u4e09\u6b65 \u5207\u6362\u5230 \"Landmark.swift \"\u5e76\u58f0\u660e\u7b26\u5408 \"Identifiable \"\u534f\u8bae\u3002 \u7531\u4e8e Landmark \u7c7b\u578b\u5df2\u7ecf\u5177\u6709 Identifiable protocol\u6240\u8981\u6c42\u7684 id \u5c5e\u6027\uff0c\u6240\u4ee5\u6ca1\u6709\u66f4\u591a\u7684\u5de5\u4f5c\u8981\u505a\u3002 \u7b2c\u56db\u6b65 \u5207\u6362\u56de LandmarkList.swift \u5e76\u5220\u9664 id \u53c2\u6570\u3002 \u4ece\u73b0\u5728\u5f00\u59cb\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 Landmark \u5143\u7d20\u7684\u96c6\u5408\u3002 Step 1 Remove the two static landmark rows, and instead pass landmarkData to the List initializer. Lists work with identifiable data. You can make your data identifiable in one of two ways: by passing along with your data a key path to a property that uniquely identifies each element, or by making your data type conform to the Identifiable protocol. Step 2 Complete the dynamically-generated list by returning a LandmarkRow from the closure. This creates one LandmarkRow for each element in the landmarkData array. Next, you\u2019ll simplify the List code by adding Identifiable conformance to the Landmark type. Step 3 Switch to Landmark.swift and declare conformance to the Identifiable protocol. Since the Landmark type already has the id property required by Identifiable protocol, there\u2019s no more work to do. Step 4 Switch back to LandmarkList.swift and remove the id parameter. From now on, you\u2019ll be able to use collections of Landmark elements directly.","title":"5.\u521b\u5efa\u52a8\u6001\u5217\u8868-Make the List Dynamic"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/2.%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AF%BC%E8%88%AA-BuildingListsAndNavigation/#6-set-up-navigation-between-list-and-detail","text":"\u5217\u8868\u663e\u793a\u6b63\u786e\uff0c\u4f46\u4f60\u8fd8\u4e0d\u80fd\u70b9\u51fb\u4e00\u4e2a\u5355\u72ec\u7684\u5730\u6807\u6765\u67e5\u770b\u8be5\u5730\u6807\u7684\u8be6\u7ec6\u9875\u9762\u3002 \u60a8\u53ef\u4ee5\u901a\u8fc7\u5c06\u5217\u8868\u5d4c\u5165\u5230\u4e00\u4e2a \"\u5bfc\u822a\u89c6\u56fe \"\u4e2d\u6765\u6dfb\u52a0\u5bfc\u822a\u529f\u80fd\uff0c\u7136\u540e\u5c06\u6bcf\u4e00\u884c\u5d4c\u5957\u5728\u4e00\u4e2a \"\u5bfc\u822a\u94fe\u63a5 \"\u4e2d\uff0c\u4ee5\u8bbe\u7f6e\u4e00\u4e2a\u5230\u76ee\u6807\u89c6\u56fe\u7684\u8f6c\u6362\u3002 The list renders properly, but you can\u2019t tap an individual landmark to see that landmark\u2019s detail page yet. You add navigation capabilities to a list by embedding it in a NavigationView , and then nesting each row in a NavigationLink to set up a transtition to a destination view. \u7b2c\u4e00\u6b65 \u5c06\u52a8\u6001\u751f\u6210\u7684\u5730\u6807\u5217\u8868\u5d4c\u5165\u5230 NavigationView \u4e2d\u3002 \u7b2c\u4e8c\u6b65\uff1a\u5c06\u52a8\u6001\u751f\u6210\u7684\u5730\u6807\u5217\u8868\u5d4c\u5165\u5230\u5bfc\u822a\u89c6\u56fe\u4e2d\u3002 \u8c03\u7528 navigationBarTitle(_:) \u4fee\u6539\u5668\u65b9\u6cd5\u6765\u8bbe\u7f6e\u663e\u793a\u5217\u8868\u65f6\u5bfc\u822a\u680f\u7684\u6807\u9898\u3002 \u7b2c\u4e09\u6b65 \u5728\u5217\u8868\u7684\u95ed\u5408\u4e2d\uff0c\u5c06\u8fd4\u56de\u7684\u884c\u5305\u88f9\u5728\u4e00\u4e2a NavigationLink \u4e2d\uff0c\u6307\u5b9a LandmarkDetail view\u4f5c\u4e3a\u76ee\u6807\u3002 \u7b2c\u56db\u6b65 \u60a8\u53ef\u4ee5\u901a\u8fc7\u5207\u6362\u5230\u5b9e\u65f6\u6a21\u5f0f\uff0c\u76f4\u63a5\u5728\u9884\u89c8\u4e2d\u8bd5\u7528\u5bfc\u822a\u3002\u70b9\u51fb \"\u5b9e\u65f6\u9884\u89c8 \"\u6309\u94ae\uff0c\u5e76\u70b9\u51fb\u4e00\u4e2a\u5730\u6807\u6765\u8bbf\u95ee\u8be6\u7ec6\u9875\u9762\u3002 Step 1 Embed the dynamically generated list of landmarks in a NavigationView . Step 2 Call the navigationBarTitle(_:) modifier method to set the title of the navigation bar when displaying the list. Step 3 Inside the list\u2019s closure, wrap the returned row in a NavigationLink , specifying the LandmarkDetail view as the destination. Step 4 You can try out the navigation directly in the preview by switching to live mode. Click the Live Preview button and tap a landmark to visit the detail page.","title":"6.\u8bbe\u7f6e\u5217\u8868\u548c\u8be6\u7ec6\u4fe1\u606f\u4e4b\u95f4\u7684\u5bfc\u822a-Set Up Navigation Between List and Detail"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/2.%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AF%BC%E8%88%AA-BuildingListsAndNavigation/#7-pass-data-into-child-views","text":"\"LandmarkDetail \"\u89c6\u56fe\u4ecd\u7136\u4f7f\u7528\u786c\u7f16\u7801\u7684\u7ec6\u8282\u6765\u663e\u793a\u5176\u5730\u6807\u3002\u5c31\u50cf \"LandmarkRow \"\u4e00\u6837\uff0c\"LandmarkDetail \"\u7c7b\u578b\u548c\u5b83\u6240\u5305\u542b\u7684\u89c6\u56fe\u9700\u8981\u4f7f\u7528 \"landmark \"\u5c5e\u6027\u4f5c\u4e3a\u5176\u6570\u636e\u7684\u6765\u6e90\u3002 \u4ece\u5b50\u89c6\u56fe\u5f00\u59cb\uff0c\u4f60\u5c06\u8f6c\u6362 CircleImage \uff0c MapView \uff0c\u7136\u540e LandmarkDetail \u6765\u663e\u793a\u4f20\u5165\u7684\u6570\u636e\uff0c\u800c\u4e0d\u662f\u786c\u7f16\u7801\u6bcf\u884c\u3002 The LandmarkDetail view still uses hard-coded details to show its landmark. Just like LandmarkRow , the LandmarkDetail type and the views it comprises need to use a landmark property as the source for their data. Starting with the child views, you\u2019ll convert CircleImage , MapView , and then LandmarkDetail to display data that\u2019s passed in, rather than hard-coding each row. \u7b2c\u4e00\u6b65 \u5728 CircleImage.swift \u4e2d\uff0c\u4e3a CircleImage \u6dfb\u52a0\u4e00\u4e2a\u5b58\u50a8 \u56fe\u50cf \u5c5e\u6027\u3002 \u8fd9\u662f\u4f7f\u7528SwiftUI\u6784\u5efa\u89c6\u56fe\u65f6\u7684\u5e38\u89c1\u6a21\u5f0f\u3002\u4f60\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\u901a\u5e38\u4f1a\u5305\u88f9\u548c\u5c01\u88c5\u4e00\u7cfb\u5217\u7279\u5b9a\u89c6\u56fe\u7684\u4fee\u6539\u5668\u3002 \u7b2c\u4e8c\u6b65 \u66f4\u65b0\u9884\u89c8\u63d0\u4f9b\u8005\u4ee5\u4f20\u9012\u9f9f\u77f3\u7684\u56fe\u50cf\u3002 \u7b2c\u4e09\u6b65 \u5728MapView.swift\u4e2d\uff0c\u7ed9MapView\u6dfb\u52a0\u4e00\u4e2a\u5750\u6807\u5c5e\u6027\uff0c\u5e76\u5c06\u4ee3\u7801\u8f6c\u6362\u4e3a\u4f7f\u7528\u8be5\u5c5e\u6027\uff0c\u800c\u4e0d\u662f\u786c\u7f16\u7801\u7ecf\u7eac\u5ea6\u3002 \u7b2c\u56db\u6b65 \u66f4\u65b0\u9884\u89c8\u63d0\u4f9b\u8005\u4ee5\u4f20\u9012\u6570\u636e\u6570\u7ec4\u4e2d\u7b2c\u4e00\u4e2a\u5730\u6807\u7684\u5750\u6807\u3002 \u7b2c\u4e94\u6b65 \u66f4\u65b0\u9884\u89c8\u63d0\u4f9b\u8005\uff0c\u4f20\u9012\u6570\u636e\u9635\u5217\u4e2d\u7b2c\u4e00\u4e2a\u5730\u6807\u7684\u5750\u6807\u3002 \u5728 LandmarkDetail.swift \u4e2d\uff0c\u4e3a LandmarkDetail \u7c7b\u578b\u6dfb\u52a0 Landmark \u5c5e\u6027\u3002 \u7b2c\u516d\u6b65 \u66f4\u65b0\u9884\u89c8\uff0c\u4f7f\u7528 landmarkData \u4e2d\u7684\u7b2c\u4e00\u4e2a\u5730\u6807\u3002 \u7b2c\u4e03\u6b65 \u5c06\u6240\u9700\u6570\u636e\u4f20\u9012\u7ed9\u60a8\u7684\u81ea\u5b9a\u4e49\u7c7b\u578b\u3002 \u7b2c\u516b\u6b65 \u6700\u540e\uff0c\u8c03\u7528 navigationBarTitle(_:displayMode:) \u4fee\u6539\u5668\uff0c\u5728\u663e\u793a\u8be6\u7ec6\u89c6\u56fe\u65f6\uff0c\u7ed9\u5bfc\u822a\u680f\u4e00\u4e2a\u6807\u9898\u3002 \u7b2c\u4e5d\u6b65 \u5728 SceneDelegate.swift \u4e2d\uff0c\u5c06\u5e94\u7528\u7a0b\u5e8f\u7684\u6839\u89c6\u56fe\u5207\u6362\u4e3a LandmarkList \u3002 \u5f53\u5728\u6a21\u62df\u5668\u4e2d\u72ec\u7acb\u8fd0\u884c\u65f6\uff0c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u5c06\u4ee5 SceneDelegate \u4e2d\u5b9a\u4e49\u7684\u6839\u89c6\u56fe\u542f\u52a8\uff0c\u800c\u4e0d\u662f\u9884\u89c8\u3002 \u7b2c\u5341\u6b65\uff1a\u5c06\u5e94\u7528\u7a0b\u5e8f\u7684\u6839\u89c6\u56fe\u5207\u6362\u4e3a \"LandmarkList\"\u3002 \u5728 LandmarkList.swift \u4e2d\uff0c\u5c06\u5f53\u524d\u7684\u5730\u6807\u4f20\u9012\u7ed9\u76ee\u6807 LandmarkDetail \u3002 \u7b2c\u5341\u4e00\u6b65\uff1a\u5c06\u5f53\u524d\u7684\u5730\u6807\u4f20\u7ed9\u76ee\u7684\u5730 LandmarkDetail \u3002 \u5207\u6362\u5230\u5b9e\u65f6\u9884\u89c8\uff0c\u5f53\u60a8\u4ece\u5217\u8868\u4e2d\u5bfc\u822a\u65f6\uff0c\u53ef\u4ee5\u770b\u5230\u8be6\u7ec6\u89c6\u56fe\u663e\u793a\u6b63\u786e\u7684\u5730\u6807\u3002 Step 1 In CircleImage.swift , add a stored image property to CircleImage . This is a common pattern when building views using SwiftUI. Your custom views will often wrap and encapsulate a series of modifiers for a particular view. Step 2 Update the preview provider to pass the image of Turtle Rock. Step 3 In MapView.swift , add a coordinate property to MapView and convert the code to use that property instead of hard-coding the latitude and longitude. Step 4 Update the preview provider to pass the coordinate of the first landmark in the data array. Step 5 In LandmarkDetail.swift , add a Landmark property to the LandmarkDetail type. Step 6 Update the preview to use the first landmark from landmarkData . Step 7 Pass the required data down to your custom types. Step 8 Finally, call the navigationBarTitle(_:displayMode:) modifier to give the navigation bar a title when showing the detail view. Step 9 In SceneDelegate.swift , switch the root view of the app to be LandmarkList . Your app starts with the root view defined in the SceneDelegate when running standalone in the simulator instead of the preview. Step 10 In LandmarkList.swift , pass the current landmark to the destination LandmarkDetail . Step 11 Switch to the live preview to see the detail view show the correct landmarks when you navigate from the list.","title":"7.\u5c06\u6570\u636e\u4f20\u9012\u81f3\u5b50\u89c6\u56fe-Pass Data into Child Views"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/2.%E6%9E%84%E5%BB%BA%E5%88%97%E8%A1%A8%E5%92%8C%E5%AF%BC%E8%88%AA-BuildingListsAndNavigation/#8-previews-dynamically","text":"\u63a5\u4e0b\u6765\uff0c\u60a8\u5c06\u4e3a LandmarkList_Previews preview \u63d0\u4f9b\u8005\u6dfb\u52a0\u4ee3\u7801\uff0c\u4ee5\u5728\u4e0d\u540c\u7684\u8bbe\u5907\u5c3a\u5bf8\u4e0b\u6e32\u67d3\u5217\u8868\u89c6\u56fe\u7684\u9884\u89c8\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u9884\u89c8\u4ee5\u6d3b\u52a8\u65b9\u6848\u4e2d\u7684\u8bbe\u5907\u5c3a\u5bf8\u5448\u73b0\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 previewDevice(_:) modifier\u65b9\u6cd5\u6765\u6539\u53d8\u9884\u89c8\u8bbe\u5907\u3002 Next, you\u2019ll add code to the LandmarkList_Previews preview provider to render previews of the list view at different device sizes. By default, previews render at the size of the device in the active scheme. You can change the preview device by calling the previewDevice(_:) modifier method. \u6b65\u9aa4\u4e00 \u9996\u5148\u5c06\u5f53\u524d\u7684\u5217\u8868\u9884\u89c8\u6539\u4e3a\u4ee5iPhone SE\u7684\u5927\u5c0f\u8fdb\u884c\u6e32\u67d3\u3002 \u60a8\u53ef\u4ee5\u63d0\u4f9b\u4efb\u4f55\u8bbe\u5907\u7684\u540d\u79f0\uff0c\u56e0\u4e3a\u5b83\u51fa\u73b0\u5728Xcode\u7684\u65b9\u6848\u83dc\u5355\u4e2d\u3002 \u7b2c\u4e8c\u6b65 \u5728\u5217\u8868\u9884\u89c8\u4e2d\uff0c\u5c06 \"LandmarkList \"\u5d4c\u5165\u5230 \"ForEach \"\u5b9e\u4f8b\u4e2d\uff0c\u4f7f\u7528\u8bbe\u5907\u540d\u79f0\u6570\u7ec4\u4f5c\u4e3a\u6570\u636e\u3002 ForEach \u5bf9\u96c6\u5408\u7684\u64cd\u4f5c\u65b9\u5f0f\u4e0e\u5217\u8868\u76f8\u540c\uff0c\u8fd9\u610f\u5473\u7740\u60a8\u53ef\u4ee5\u5728\u4efb\u4f55\u53ef\u4ee5\u4f7f\u7528\u5b50\u89c6\u56fe\u7684\u5730\u65b9\u4f7f\u7528\u5b83\uff0c\u4f8b\u5982\u5728\u5806\u6808\u3001\u5217\u8868\u3001\u7ec4\u7b49\u4e2d\u3002\u5f53\u4f60\u7684\u6570\u636e\u5143\u7d20\u662f\u7b80\u5355\u7684\u503c\u7c7b\u578b\u65f6--\u5c31\u50cf\u4f60\u5728\u8fd9\u91cc\u4f7f\u7528\u7684\u5b57\u7b26\u4e32--\u4f60\u53ef\u4ee5\u4f7f\u7528 .self \u4f5c\u4e3a\u6807\u8bc6\u7b26\u7684\u952e\u8def\u5f84\u3002 \u7b2c\u4e09\u6b65 \u4f7f\u7528 previewDisplayName(_:) \u4fee\u6539\u5668\u6dfb\u52a0\u8bbe\u5907\u540d\u79f0\u4f5c\u4e3a\u9884\u89c8\u7684\u6807\u7b7e\u3002 \u7b2c\u56db\u6b65 \u60a8\u53ef\u4ee5\u4f7f\u7528\u4e0d\u540c\u7684\u8bbe\u5907\u8fdb\u884c\u5b9e\u9a8c\uff0c\u6bd4\u8f83\u60a8\u7684\u89c6\u56fe\u7684\u6e32\u67d3\u6548\u679c\uff0c\u6240\u6709\u8fd9\u4e9b\u90fd\u6765\u81ea\u753b\u5e03\u3002 Step 1 Start by changing the current list preview to render at the size of an iPhone SE. You can provide the name of any device as it appears in Xcode\u2019s scheme menu. Step 2 Within the list preview, embed the LandmarkList in a ForEach instance, using an array of device names as the data. ForEach operates on collections the same way as the list, which means you can use it anywhere you can use a child view, such as in stacks, lists, groups, and more. When the elements of your data are simple value types \u2014 like the strings you\u2019re using here \u2014 you can use \\.self as key path to the identifier. Step 3 Use the previewDisplayName(_:) modifier to add the device names as labels for the previews. Step 4 You can experiment with different devices to compare the renderings of your views, all from the canvas.","title":"8.\u52a8\u6001\u751f\u6210\u9884\u89c8- Previews Dynamically"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/3.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-HandlingUserInput/","text":"\u5904\u7406\u7528\u6237\u8f93\u5165-HandlingUserInput \u5728\u5730\u6807APP\u4e2d\uff0c\u7528\u6237\u53ef\u4ee5\u6807\u8bb0\u4ed6\u4eec\u559c\u6b22\u7684\u5730\u65b9\uff0c In the Landmarks app, a user can flag their favorite places, and filter the list to show just their favorites. To create this feature, you\u2019ll start by adding a switch to the list so users can focus on just their favorites, and then you\u2019ll add a star-shaped button that a user taps to flag a landmark as a favorite. Download the starter project and follow along with this tutorial, or open the finished project and explore the code on your own. \u5de5\u7a0b\u6587\u4ef6\u4e0b\u8f7d Mark the User\u2019s Favorite Landmarks Begin by enhancing the list to show users their favorites at a glance. Add a star to each LandmarkRow that shows a favorite landmark. Step 1 Open the starting point Xcode project, and then select LandmarkRow.swift in the Project navigator. Step 2 After the spacer, add a star image inside an if statement to test whether the current landmark is a favorite. In SwiftUI blocks, you use if statements to conditionally include views. Step 3 Because system images are vector based, you can change their color with the foregroundColor(_:) modifier. The star is present whenever a landmark\u2019s isFavorite property is true . You\u2019ll see how to modify that property later in this tutorial. Filter the List View You can customize the list view so that it shows all of the landmarks, or just the user\u2019s favorites. To do this, you\u2019ll need to add a bit of_state_to the LandmarkList type. State is a value, or a set of values, that can change over time, and that affects a view\u2019s behavior, content, or layout. You use a property with the @State attribute to add state to a view. Step 1 Select LandmarkList.swift in the Project navigator. Add a @State property called showFavoritesOnly to LandmarkList , with its initial value set to false . Step 2 Refresh the canvas by clicking the Resume button. When you make changes to your view\u2019s structure, like adding or modifying a property, you need to manually refresh the canvas. Step 3 Filter the list of landmarks by checking the showFavoritesOnly property and each landmark.isFavorite value. Add a Control to Toggle the State To give the user control over the list\u2019s filter, you need to add a control that can alter the value of showFavoritesOnly . You do this by passing a binding to a toggle control. A binding acts as a reference to a mutable state. When a user taps the toggle from off to on, and off again, the control uses the binding to update the view\u2019s state accordingly. Step 1 Create a nested ForEach group to transform the landmarks into rows. To combine static and dynamic views in a list, or to combine two or more different groups of dynamic views, use the ForEach type instead of passing your collection of data to List . Step 2 Add a Toggle view as the first child of the List view, passing a binding to showFavoritesOnly . You use the $ prefix to access a binding to a state variable, or one of its properties. Step 3 Use the live preview and try out this new functionality by tapping the toggle. Use an Observable Object for Storage To prepare for the user to control which particular landmarks are favorites, you\u2019ll first store the landmark data in an_observable object._ An observable object is a custom object for your data that can be bound to a view from storage in SwiftUI\u2019s environment. SwiftUI watches for any changes to observable objects that could affect a view, and displays the correct version of the view after a change. Step 1 Create a new Swift file named UserData.swift . Step 2 Declare a new model type that conforms to the ObservableObject protocol from the Combine framework. SwiftUI subscribes to your observable object, and updates any views that need refreshing when the data changes. Step 3 Add stored properties for showFavoritesOnly and landmarks , along with their initial values. An observable object needs to publish any changes to its data, so that its subscribers can pick up the change. Step 4 Add the @Published attribute to each property in the model. Adopt the Model Object in Your Views Now that you\u2019ve created the UserData object, you need to update your views to adopt it as the data store for your app. Step 1 In LandmarkList.swift , replace the showFavoritesOnly declaration with an @EnvironmentObject property, and add an environmentObject(_:) modifier to the preview. This userData property gets its value automatically, as long as the environmentObject(_:) modifier has been applied to a parent. Step 2 Replace the uses of showFavoritesOnly by accessing the same property on userData . Just like on @State properties, you can access a binding to a member of the userData object by using the $ prefix. Step 3 Use userData.landmarks as the data when creating the ForEach instance. Step 4 In SceneDelegate.swift , add the environmentObject(_:) modifier to the LandmarkList . If you build and run Landmarks in the simulator or on a device, rather than using the preview, this update ensures that LandmarkList has a UserData object in the environment. Step 5 Update the LandmarkDetail view to work with the UserData object in the environment. You\u2019ll use landmarkIndex when accessing or updating the landmark\u2019s favorite status, so that you\u2019re always accessing the correct version of that data. Step 6 Switch back to LandmarkList.swift and turn on the live preview to verify that everything is working as it should be. Create a Favorite Button for Each Landmark The Landmarks app can now switch between a filtered and unfiltered view of the landmarks, but the list of favorite landmarks is still hard coded. To allow the user to add and remove favorites, you need to add a favorite button to the landmark detail view. Step 1 In LandmarkDetail.swift , embed the landmark\u2019s name in an HStack . Step 2 Create a new button next to the landmark\u2019s name. Use an if - else conditional statement to provide different images that indicate whether the landmark is a favorite. In the button\u2019s action closure, the code uses landmarkIndex with the userData object to update the landmark in place. Step 3 Switch back to LandmarkList.swift , and turn on the live preview. As you navigate from the list to the detail and tap the button, those changes persist when you return to the list. Because both views are accessing the same model object in the environment, the two views maintain consistency.","title":"\u5904\u7406\u7528\u6237\u8f93\u5165-HandlingUserInput"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/3.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-HandlingUserInput/#-handlinguserinput","text":"\u5728\u5730\u6807APP\u4e2d\uff0c\u7528\u6237\u53ef\u4ee5\u6807\u8bb0\u4ed6\u4eec\u559c\u6b22\u7684\u5730\u65b9\uff0c In the Landmarks app, a user can flag their favorite places, and filter the list to show just their favorites. To create this feature, you\u2019ll start by adding a switch to the list so users can focus on just their favorites, and then you\u2019ll add a star-shaped button that a user taps to flag a landmark as a favorite. Download the starter project and follow along with this tutorial, or open the finished project and explore the code on your own. \u5de5\u7a0b\u6587\u4ef6\u4e0b\u8f7d","title":"\u5904\u7406\u7528\u6237\u8f93\u5165-HandlingUserInput"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/3.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-HandlingUserInput/#mark-the-users-favorite-landmarks","text":"Begin by enhancing the list to show users their favorites at a glance. Add a star to each LandmarkRow that shows a favorite landmark. Step 1 Open the starting point Xcode project, and then select LandmarkRow.swift in the Project navigator. Step 2 After the spacer, add a star image inside an if statement to test whether the current landmark is a favorite. In SwiftUI blocks, you use if statements to conditionally include views. Step 3 Because system images are vector based, you can change their color with the foregroundColor(_:) modifier. The star is present whenever a landmark\u2019s isFavorite property is true . You\u2019ll see how to modify that property later in this tutorial.","title":"Mark the User\u2019s Favorite Landmarks"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/3.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-HandlingUserInput/#filter-the-list-view","text":"You can customize the list view so that it shows all of the landmarks, or just the user\u2019s favorites. To do this, you\u2019ll need to add a bit of_state_to the LandmarkList type. State is a value, or a set of values, that can change over time, and that affects a view\u2019s behavior, content, or layout. You use a property with the @State attribute to add state to a view. Step 1 Select LandmarkList.swift in the Project navigator. Add a @State property called showFavoritesOnly to LandmarkList , with its initial value set to false . Step 2 Refresh the canvas by clicking the Resume button. When you make changes to your view\u2019s structure, like adding or modifying a property, you need to manually refresh the canvas. Step 3 Filter the list of landmarks by checking the showFavoritesOnly property and each landmark.isFavorite value.","title":"Filter the List View"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/3.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-HandlingUserInput/#add-a-control-to-toggle-the-state","text":"To give the user control over the list\u2019s filter, you need to add a control that can alter the value of showFavoritesOnly . You do this by passing a binding to a toggle control. A binding acts as a reference to a mutable state. When a user taps the toggle from off to on, and off again, the control uses the binding to update the view\u2019s state accordingly. Step 1 Create a nested ForEach group to transform the landmarks into rows. To combine static and dynamic views in a list, or to combine two or more different groups of dynamic views, use the ForEach type instead of passing your collection of data to List . Step 2 Add a Toggle view as the first child of the List view, passing a binding to showFavoritesOnly . You use the $ prefix to access a binding to a state variable, or one of its properties. Step 3 Use the live preview and try out this new functionality by tapping the toggle.","title":"Add a Control to Toggle the State"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/3.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-HandlingUserInput/#use-an-observable-object-for-storage","text":"To prepare for the user to control which particular landmarks are favorites, you\u2019ll first store the landmark data in an_observable object._ An observable object is a custom object for your data that can be bound to a view from storage in SwiftUI\u2019s environment. SwiftUI watches for any changes to observable objects that could affect a view, and displays the correct version of the view after a change. Step 1 Create a new Swift file named UserData.swift . Step 2 Declare a new model type that conforms to the ObservableObject protocol from the Combine framework. SwiftUI subscribes to your observable object, and updates any views that need refreshing when the data changes. Step 3 Add stored properties for showFavoritesOnly and landmarks , along with their initial values. An observable object needs to publish any changes to its data, so that its subscribers can pick up the change. Step 4 Add the @Published attribute to each property in the model.","title":"Use an Observable Object for Storage"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/3.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-HandlingUserInput/#adopt-the-model-object-in-your-views","text":"Now that you\u2019ve created the UserData object, you need to update your views to adopt it as the data store for your app. Step 1 In LandmarkList.swift , replace the showFavoritesOnly declaration with an @EnvironmentObject property, and add an environmentObject(_:) modifier to the preview. This userData property gets its value automatically, as long as the environmentObject(_:) modifier has been applied to a parent. Step 2 Replace the uses of showFavoritesOnly by accessing the same property on userData . Just like on @State properties, you can access a binding to a member of the userData object by using the $ prefix. Step 3 Use userData.landmarks as the data when creating the ForEach instance. Step 4 In SceneDelegate.swift , add the environmentObject(_:) modifier to the LandmarkList . If you build and run Landmarks in the simulator or on a device, rather than using the preview, this update ensures that LandmarkList has a UserData object in the environment. Step 5 Update the LandmarkDetail view to work with the UserData object in the environment. You\u2019ll use landmarkIndex when accessing or updating the landmark\u2019s favorite status, so that you\u2019re always accessing the correct version of that data. Step 6 Switch back to LandmarkList.swift and turn on the live preview to verify that everything is working as it should be.","title":"Adopt the Model Object in Your Views"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/1.SwiftUI%E5%9F%BA%E6%9C%AC%E4%BB%B6-SwiftUIEssentials/3.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-HandlingUserInput/#create-a-favorite-button-for-each-landmark","text":"The Landmarks app can now switch between a filtered and unfiltered view of the landmarks, but the list of favorite landmarks is still hard coded. To allow the user to add and remove favorites, you need to add a favorite button to the landmark detail view. Step 1 In LandmarkDetail.swift , embed the landmark\u2019s name in an HStack . Step 2 Create a new button next to the landmark\u2019s name. Use an if - else conditional statement to provide different images that indicate whether the landmark is a favorite. In the button\u2019s action closure, the code uses landmarkIndex with the userData object to update the landmark in place. Step 3 Switch back to LandmarkList.swift , and turn on the live preview. As you navigate from the list to the detail and tap the button, those changes persist when you return to the list. Because both views are accessing the same model object in the environment, the two views maintain consistency.","title":"Create a Favorite Button for Each Landmark"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/4.%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90-FrameworkIntegration/1.%E7%BB%93%E5%90%88UIKit-InterfacingWithUIKit/","text":"\u7ed3\u5408UIKit-InterfacingWithUIKit SwiftUI\u53ef\u4ee5\u4e0e\u6240\u6709\u82f9\u679c\u5e73\u53f0\u4e0a\u73b0\u6709\u7684UI\u6846\u67b6\u65e0\u7f1d\u914d\u5408\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u5728SwiftUI\u89c6\u56fe\u4e2d\u653e\u7f6eUIKit\u89c6\u56fe\u548c\u89c6\u56fe\u63a7\u5236\u5668\uff0c\u53cd\u4e4b\u4ea6\u7136\u3002 \u672c\u6559\u7a0b\u5c55\u793a\u4e86\u5982\u4f55\u5c06\u4e3b\u5c4f\u5e55\u4e0a\u7684\u7279\u8272\u5730\u6807\u8f6c\u6362\u4e3a UIPageViewController \u548c UIPageControl \u7684\u5b9e\u4f8b\u3002\u4f60\u5c06\u4f7f\u7528 UIPageViewController \u6765\u663e\u793aSwiftUI\u89c6\u56fe\u7684\u65cb\u8f6c\u6728\u9a6c\uff0c\u5e76\u4f7f\u7528\u72b6\u6001\u53d8\u91cf\u548c\u7ed1\u5b9a\u6765\u534f\u8c03\u6574\u4e2a\u7528\u6237\u754c\u9762\u7684\u6570\u636e\u66f4\u65b0\u3002 \u6309\u7167\u6b65\u9aa4\u6765\u6784\u5efa\u8fd9\u4e2a\u9879\u76ee\uff0c\u6216\u8005\u4e0b\u8f7d\u5b8c\u6210\u7684\u9879\u76ee\u6765\u81ea\u5df1\u63a2\u7d22\u3002 \u5de5\u7a0b\u6587\u4ef6\u4e0b\u8f7d SwiftUI works seamlessly with the existing UI frameworks on all Apple platforms. For example, you can place UIKit views and view controllers inside SwiftUI views, and vice versa. This tutorial shows you how to convert the featured landmark from the home screen to wrap instances of UIPageViewController and UIPageControl . You\u2019ll use UIPageViewController to display a carousel of SwiftUI views, and use state variables and bindings to coordinate data updates throughout the user interface. Follow the steps to build this project, or download the finished project to explore on your own.","title":"\u7ed3\u5408UIKit-InterfacingWithUIKit"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/1.SwiftUI%E4%BB%8B%E7%BB%8D-IntroducingSwiftUI/4.%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90-FrameworkIntegration/1.%E7%BB%93%E5%90%88UIKit-InterfacingWithUIKit/#uikit-interfacingwithuikit","text":"SwiftUI\u53ef\u4ee5\u4e0e\u6240\u6709\u82f9\u679c\u5e73\u53f0\u4e0a\u73b0\u6709\u7684UI\u6846\u67b6\u65e0\u7f1d\u914d\u5408\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u5728SwiftUI\u89c6\u56fe\u4e2d\u653e\u7f6eUIKit\u89c6\u56fe\u548c\u89c6\u56fe\u63a7\u5236\u5668\uff0c\u53cd\u4e4b\u4ea6\u7136\u3002 \u672c\u6559\u7a0b\u5c55\u793a\u4e86\u5982\u4f55\u5c06\u4e3b\u5c4f\u5e55\u4e0a\u7684\u7279\u8272\u5730\u6807\u8f6c\u6362\u4e3a UIPageViewController \u548c UIPageControl \u7684\u5b9e\u4f8b\u3002\u4f60\u5c06\u4f7f\u7528 UIPageViewController \u6765\u663e\u793aSwiftUI\u89c6\u56fe\u7684\u65cb\u8f6c\u6728\u9a6c\uff0c\u5e76\u4f7f\u7528\u72b6\u6001\u53d8\u91cf\u548c\u7ed1\u5b9a\u6765\u534f\u8c03\u6574\u4e2a\u7528\u6237\u754c\u9762\u7684\u6570\u636e\u66f4\u65b0\u3002 \u6309\u7167\u6b65\u9aa4\u6765\u6784\u5efa\u8fd9\u4e2a\u9879\u76ee\uff0c\u6216\u8005\u4e0b\u8f7d\u5b8c\u6210\u7684\u9879\u76ee\u6765\u81ea\u5df1\u63a2\u7d22\u3002 \u5de5\u7a0b\u6587\u4ef6\u4e0b\u8f7d SwiftUI works seamlessly with the existing UI frameworks on all Apple platforms. For example, you can place UIKit views and view controllers inside SwiftUI views, and vice versa. This tutorial shows you how to convert the featured landmark from the home screen to wrap instances of UIPageViewController and UIPageControl . You\u2019ll use UIPageViewController to display a carousel of SwiftUI views, and use state variables and bindings to coordinate data updates throughout the user interface. Follow the steps to build this project, or download the finished project to explore on your own.","title":"\u7ed3\u5408UIKit-InterfacingWithUIKit"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/2.APP%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA-App%20Structure%20and%20Behavior/0.APP%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA-App%20Structure%20and%20Behavior/","text":"0.APP\u7ed3\u6784\u548c\u884c\u4e3a-App Structure and Behavior \u5b9a\u4e49\u5e94\u7528\u7684\u5165\u53e3\u70b9\u548c\u9876\u5c42\u7ed3\u6784\u3002 Define the entry point and top-level organization of your app. \u6982\u8ff0 \u901a\u8fc7\u521b\u5efa\u4e00\u4e2a\u7b26\u5408App\u534f\u8bae\u7684\u7ed3\u6784\u6765\u58f0\u660e\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u5411\u5b83\u6dfb\u52a0\u4e00\u4e2a\u6216\u591a\u4e2a\u573a\u666f\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528\u5185\u7f6e\u7684\u573a\u666f\uff0c\u5982WindowGroup\uff0c\u6216\u8005\u60a8\u53ef\u4ee5\u7f16\u5199\u7b26\u5408\u573a\u666f\u534f\u8bae\u7684\u81ea\u5b9a\u4e49\u573a\u666f\u3002\u573a\u666f\u5305\u542b\u5b9a\u4e49\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\u7684\u7528\u6237\u754c\u9762\u7684\u89c6\u56fe\u5c42\u6b21\u7ed3\u6784\uff0c\u5e76\u6709\u4e00\u4e2a\u7cfb\u7edf\u7ba1\u7406\u7684\u751f\u547d\u5468\u671f\u3002 Declare your app by creating a structure that conforms to the App protocol and add one or more scenes to it. You can use built-in scenes, like WindowGroup, or you can compose custom scenes that conform to the Scene protocol. Scenes contain the view hierarchies that define the user interface of your app, and have a life cycle that the system manages. \u901a\u8fc7\u5e94\u7528CommandMenu\u5b9e\u4f8b\u5411\u573a\u666f\u6dfb\u52a0\u83dc\u5355\u547d\u4ee4\u3002\u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528CommandGroup\u66f4\u65b0\u7cfb\u7edf\u63d0\u4f9b\u7684\u83dc\u5355\u3002\u5f53\u4f60\u4e3a\u547d\u4ee4\u63d0\u4f9b\u952e\u76d8\u5feb\u6377\u952e\u65f6\uff0ciOS\u3001iPadOS\u548ctvOS\u4f1a\u5c06\u8fd9\u4e9b\u5feb\u6377\u952e\u4f5c\u4e3a\u6309\u952e\u547d\u4ee4\u4f7f\u7528\u3002 Add menu commands to a scene by applying CommandMenu instances. You can also update system-provided menus using a CommandGroup. When you provide keyboard shortcuts for commands, iOS, iPadOS, and tvOS make those available as key commands. \u4f60\u53ef\u4ee5\u914d\u5408WidgetKit\u548cSwiftUI\u4e3a\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6dfb\u52a0widget\u3002Widget\u63d0\u4f9b\u4e86\u5bf9\u5e94\u7528\u7a0b\u5e8f\u4e2d\u76f8\u5173\u5185\u5bb9\u7684\u5feb\u901f\u8bbf\u95ee\u3002\u5b9a\u4e49\u4e00\u4e2a\u7b26\u5408Widget\u534f\u8bae\u7684\u7ed3\u6784\uff0c\u5e76\u4e3awidget\u58f0\u660e\u4e00\u4e2a\u89c6\u56fe\u5c42\u6b21\u7ed3\u6784\u3002 You can use SwiftUI, working together with WidgetKit, to add widgets to your app. Widgets provide quick access to relevant content from your app. Define a structure that conforms to the Widget protocol, and declare a view hierarchy for the widget. \u901a\u8fc7\u8c03\u7528\u52a8\u4f5c\u4e0e\u7cfb\u7edf\u7684\u5176\u4ed6\u90e8\u5206\u8fdb\u884c\u4ea4\u4e92\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u7528OpenURLAction\u5b9e\u4f8b\u6253\u5f00\u4e00\u4e2aURL\u3002 Interact with other parts of the system by invoking actions. For example, you can open a URL with an OpenURLAction instance.","title":"0.APP\u7ed3\u6784\u548c\u884c\u4e3a-App Structure and Behavior"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/2.APP%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA-App%20Structure%20and%20Behavior/0.APP%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA-App%20Structure%20and%20Behavior/#0app-app-structure-and-behavior","text":"\u5b9a\u4e49\u5e94\u7528\u7684\u5165\u53e3\u70b9\u548c\u9876\u5c42\u7ed3\u6784\u3002 Define the entry point and top-level organization of your app. \u6982\u8ff0 \u901a\u8fc7\u521b\u5efa\u4e00\u4e2a\u7b26\u5408App\u534f\u8bae\u7684\u7ed3\u6784\u6765\u58f0\u660e\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u5411\u5b83\u6dfb\u52a0\u4e00\u4e2a\u6216\u591a\u4e2a\u573a\u666f\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528\u5185\u7f6e\u7684\u573a\u666f\uff0c\u5982WindowGroup\uff0c\u6216\u8005\u60a8\u53ef\u4ee5\u7f16\u5199\u7b26\u5408\u573a\u666f\u534f\u8bae\u7684\u81ea\u5b9a\u4e49\u573a\u666f\u3002\u573a\u666f\u5305\u542b\u5b9a\u4e49\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\u7684\u7528\u6237\u754c\u9762\u7684\u89c6\u56fe\u5c42\u6b21\u7ed3\u6784\uff0c\u5e76\u6709\u4e00\u4e2a\u7cfb\u7edf\u7ba1\u7406\u7684\u751f\u547d\u5468\u671f\u3002 Declare your app by creating a structure that conforms to the App protocol and add one or more scenes to it. You can use built-in scenes, like WindowGroup, or you can compose custom scenes that conform to the Scene protocol. Scenes contain the view hierarchies that define the user interface of your app, and have a life cycle that the system manages. \u901a\u8fc7\u5e94\u7528CommandMenu\u5b9e\u4f8b\u5411\u573a\u666f\u6dfb\u52a0\u83dc\u5355\u547d\u4ee4\u3002\u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528CommandGroup\u66f4\u65b0\u7cfb\u7edf\u63d0\u4f9b\u7684\u83dc\u5355\u3002\u5f53\u4f60\u4e3a\u547d\u4ee4\u63d0\u4f9b\u952e\u76d8\u5feb\u6377\u952e\u65f6\uff0ciOS\u3001iPadOS\u548ctvOS\u4f1a\u5c06\u8fd9\u4e9b\u5feb\u6377\u952e\u4f5c\u4e3a\u6309\u952e\u547d\u4ee4\u4f7f\u7528\u3002 Add menu commands to a scene by applying CommandMenu instances. You can also update system-provided menus using a CommandGroup. When you provide keyboard shortcuts for commands, iOS, iPadOS, and tvOS make those available as key commands. \u4f60\u53ef\u4ee5\u914d\u5408WidgetKit\u548cSwiftUI\u4e3a\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6dfb\u52a0widget\u3002Widget\u63d0\u4f9b\u4e86\u5bf9\u5e94\u7528\u7a0b\u5e8f\u4e2d\u76f8\u5173\u5185\u5bb9\u7684\u5feb\u901f\u8bbf\u95ee\u3002\u5b9a\u4e49\u4e00\u4e2a\u7b26\u5408Widget\u534f\u8bae\u7684\u7ed3\u6784\uff0c\u5e76\u4e3awidget\u58f0\u660e\u4e00\u4e2a\u89c6\u56fe\u5c42\u6b21\u7ed3\u6784\u3002 You can use SwiftUI, working together with WidgetKit, to add widgets to your app. Widgets provide quick access to relevant content from your app. Define a structure that conforms to the Widget protocol, and declare a view hierarchy for the widget. \u901a\u8fc7\u8c03\u7528\u52a8\u4f5c\u4e0e\u7cfb\u7edf\u7684\u5176\u4ed6\u90e8\u5206\u8fdb\u884c\u4ea4\u4e92\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u7528OpenURLAction\u5b9e\u4f8b\u6253\u5f00\u4e00\u4e2aURL\u3002 Interact with other parts of the system by invoking actions. For example, you can open a URL with an OpenURLAction instance.","title":"0.APP\u7ed3\u6784\u548c\u884c\u4e3a-App Structure and Behavior"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/2.APP%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA-App%20Structure%20and%20Behavior/1.%E5%BF%85%E9%9C%80-Essentials/1.App/","text":"App \u5b9a\u4e49\u4f60\u7684\u5e94\u7528\u7684\u5165\u53e3\u70b9\u548c\u9876\u5c42\u7ec4\u7ec7\u3002 Define the entry point and top-level organization of your app. \u8bf4\u660e protocol Scene \u6982\u8ff0 \u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u5e94\u7528\u7a0b\u5e8f\u7684\u4e3b\u4f53\u4e2d\u7ec4\u5408\u4e00\u4e2a\u6216\u591a\u4e2a\u7b26\u5408Scene\u534f\u8bae\u7684\u5b9e\u4f8b\u6765\u521b\u5efa\u5e94\u7528\u7a0b\u5e8f\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528 SwiftUI \u63d0\u4f9b\u7684\u539f\u59cb\u573a\u666f\uff0c\u5982 WindowGroup\uff0c\u4ee5\u53ca\u60a8\u4ece\u5176\u4ed6\u573a\u666f\u4e2d\u5408\u6210\u7684\u81ea\u5b9a\u4e49\u573a\u666f\u3002\u8981\u521b\u5efa\u4e00\u4e2a\u81ea\u5b9a\u4e49\u573a\u666f\uff0c\u9700\u8981\u58f0\u660e\u4e00\u4e2a\u7b26\u5408Scene\u534f\u8bae\u7684\u7c7b\u578b\u3002\u5b9e\u73b0\u6240\u9700\u7684\u4e3b\u4f53\u8ba1\u7b97\u5c5e\u6027\uff0c\u5e76\u4e3a\u4f60\u7684\u81ea\u5b9a\u4e49\u573a\u666f\u63d0\u4f9b\u5185\u5bb9\u3002 You create an App by combining one or more instances that conform to the Scene protocol in the app\u2019s body. You can use the primitive scenes that SwiftUI provides, like WindowGroup, along with custom scenes that you compose from other scenes. To create a custom scene, declare a type that conforms to the Scene protocol. Implement the required body computed property and provide the content for your custom scene: struct MyScene: Scene { var body: some Scene { WindowGroup { MyRootView() } } } \u573a\u666f\u4f5c\u4e3a\u60a8\u8981\u5411\u7528\u6237\u663e\u793a\u7684\u89c6\u56fe\u5c42\u6b21\u7ed3\u6784\u7684\u5bb9\u5668\u3002\u7cfb\u7edf\u51b3\u5b9a\u4f55\u65f6\u4ee5\u53ca\u5982\u4f55\u5728\u7528\u6237\u754c\u9762\u4e2d\u4ee5\u9002\u5408\u5e73\u53f0\u7684\u65b9\u5f0f\u5448\u73b0\u89c6\u56fe\u5c42\u6b21\u7ed3\u6784\uff0c\u5e76\u53d6\u51b3\u4e8e\u5e94\u7528\u7a0b\u5e8f\u7684\u5f53\u524d\u72b6\u6001\u3002\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u56fe\u6240\u793a\u7684\u7a97\u53e3\u7ec4\uff0c\u7cfb\u7edf\u8ba9\u7528\u6237\u5728macOS\u548ciPadOS\u7b49\u5e73\u53f0\u4e0a\u521b\u5efa\u6216\u5220\u9664\u5305\u542bMyRootView\u7684\u7a97\u53e3\u3002\u5728\u5176\u4ed6\u5e73\u53f0\u4e0a\uff0c\u540c\u6837\u7684\u89c6\u56fe\u5c42\u6b21\u7ed3\u6784\u5728\u6d3b\u52a8\u65f6\u53ef\u80fd\u4f1a\u5360\u636e\u6574\u4e2a\u663e\u793a\u5c4f\u3002 A scene acts as a container for a view hierarchy that you want to display to the user. The system decides when and how to present the view hierarchy in the user interface in a way that\u2019s platform-appropriate and dependent on the current state of the app. For example, for the window group shown above, the system lets the user create or remove windows that contain MyRootView on platforms like macOS and iPadOS. On other platforms, the same view hierarchy might consume the entire display when active. \u4ece\u573a\u666f\u6216\u5b83\u7684\u4e00\u4e2a\u89c6\u56fe\u4e2d\u8bfb\u53d6 scenePhase \u73af\u5883\u503c\uff0c\u4ee5\u68c0\u67e5\u573a\u666f\u662f\u5426\u5904\u4e8e\u6d3b\u52a8\u72b6\u6001\u6216\u5176\u4ed6\u72b6\u6001\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528\u73af\u5883\u5c5e\u6027\u521b\u5efa\u4e00\u4e2a\u5305\u542b\u573a\u666f\u9636\u6bb5\u7684\u5c5e\u6027\uff0c\u5b83\u662fScenePhase\u679a\u4e3e\u4e2d\u7684\u4e00\u4e2a\u503c\u3002 Read the scenePhase environment value from within a scene or one of its views to check whether a scene is active or in some other state. You can create a property that contains the scene phase, which is one of the values in the ScenePhase enumeration, using the Environment attribute: struct MyScene: Scene { @Environment(\\.scenePhase) private var scenePhase // ... } Scene\u534f\u8bae\u63d0\u4f9b\u4e86\u573a\u666f\u4fee\u9970\u7b26\uff0c\u8fd9\u4e9b\u4fee\u9970\u7b26\u88ab\u5b9a\u4e49\u4e3a\u5177\u6709\u9ed8\u8ba4\u5b9e\u73b0\u7684\u534f\u8bae\u65b9\u6cd5\uff0c\u4f60\u53ef\u4ee5\u7528\u5b83\u4eec\u6765\u914d\u7f6e\u573a\u666f\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528onChange(of:perform:)\u4fee\u9970\u7b26\u5728\u503c\u6539\u53d8\u65f6\u89e6\u53d1\u4e00\u4e2a\u52a8\u4f5c\u3002\u5f53\u7a97\u53e3\u7ec4\u4e2d\u7684\u6240\u6709\u573a\u666f\u90fd\u79fb\u52a8\u5230\u540e\u53f0\u65f6\uff0c\u4e0b\u9762\u7684\u4ee3\u7801\u4f1a\u6e05\u7a7a\u7f13\u5b58\u3002 The Scene protocol provides scene modifiers, defined as protocol methods with default implementations, that you use to configure a scene. For example, you can use the onChange(of:perform:) modifier to trigger an action when a value changes. The following code empties a cache when all of the scenes in the window group have moved to the background: struct MyScene: Scene { @Environment(\\.scenePhase) private var scenePhase @StateObject private var cache = DataCache() var body: some Scene { WindowGroup { MyRootView() } .onChange(of: scenePhase) { newScenePhase in if newScenePhase == .background { cache.empty() } } } }","title":"App"},{"location":"SwiftUI/1.%E5%BF%85%E9%9C%80-Essentials/2.APP%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA-App%20Structure%20and%20Behavior/1.%E5%BF%85%E9%9C%80-Essentials/1.App/#app","text":"\u5b9a\u4e49\u4f60\u7684\u5e94\u7528\u7684\u5165\u53e3\u70b9\u548c\u9876\u5c42\u7ec4\u7ec7\u3002 Define the entry point and top-level organization of your app. \u8bf4\u660e protocol Scene \u6982\u8ff0 \u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u5e94\u7528\u7a0b\u5e8f\u7684\u4e3b\u4f53\u4e2d\u7ec4\u5408\u4e00\u4e2a\u6216\u591a\u4e2a\u7b26\u5408Scene\u534f\u8bae\u7684\u5b9e\u4f8b\u6765\u521b\u5efa\u5e94\u7528\u7a0b\u5e8f\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528 SwiftUI \u63d0\u4f9b\u7684\u539f\u59cb\u573a\u666f\uff0c\u5982 WindowGroup\uff0c\u4ee5\u53ca\u60a8\u4ece\u5176\u4ed6\u573a\u666f\u4e2d\u5408\u6210\u7684\u81ea\u5b9a\u4e49\u573a\u666f\u3002\u8981\u521b\u5efa\u4e00\u4e2a\u81ea\u5b9a\u4e49\u573a\u666f\uff0c\u9700\u8981\u58f0\u660e\u4e00\u4e2a\u7b26\u5408Scene\u534f\u8bae\u7684\u7c7b\u578b\u3002\u5b9e\u73b0\u6240\u9700\u7684\u4e3b\u4f53\u8ba1\u7b97\u5c5e\u6027\uff0c\u5e76\u4e3a\u4f60\u7684\u81ea\u5b9a\u4e49\u573a\u666f\u63d0\u4f9b\u5185\u5bb9\u3002 You create an App by combining one or more instances that conform to the Scene protocol in the app\u2019s body. You can use the primitive scenes that SwiftUI provides, like WindowGroup, along with custom scenes that you compose from other scenes. To create a custom scene, declare a type that conforms to the Scene protocol. Implement the required body computed property and provide the content for your custom scene: struct MyScene: Scene { var body: some Scene { WindowGroup { MyRootView() } } } \u573a\u666f\u4f5c\u4e3a\u60a8\u8981\u5411\u7528\u6237\u663e\u793a\u7684\u89c6\u56fe\u5c42\u6b21\u7ed3\u6784\u7684\u5bb9\u5668\u3002\u7cfb\u7edf\u51b3\u5b9a\u4f55\u65f6\u4ee5\u53ca\u5982\u4f55\u5728\u7528\u6237\u754c\u9762\u4e2d\u4ee5\u9002\u5408\u5e73\u53f0\u7684\u65b9\u5f0f\u5448\u73b0\u89c6\u56fe\u5c42\u6b21\u7ed3\u6784\uff0c\u5e76\u53d6\u51b3\u4e8e\u5e94\u7528\u7a0b\u5e8f\u7684\u5f53\u524d\u72b6\u6001\u3002\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u56fe\u6240\u793a\u7684\u7a97\u53e3\u7ec4\uff0c\u7cfb\u7edf\u8ba9\u7528\u6237\u5728macOS\u548ciPadOS\u7b49\u5e73\u53f0\u4e0a\u521b\u5efa\u6216\u5220\u9664\u5305\u542bMyRootView\u7684\u7a97\u53e3\u3002\u5728\u5176\u4ed6\u5e73\u53f0\u4e0a\uff0c\u540c\u6837\u7684\u89c6\u56fe\u5c42\u6b21\u7ed3\u6784\u5728\u6d3b\u52a8\u65f6\u53ef\u80fd\u4f1a\u5360\u636e\u6574\u4e2a\u663e\u793a\u5c4f\u3002 A scene acts as a container for a view hierarchy that you want to display to the user. The system decides when and how to present the view hierarchy in the user interface in a way that\u2019s platform-appropriate and dependent on the current state of the app. For example, for the window group shown above, the system lets the user create or remove windows that contain MyRootView on platforms like macOS and iPadOS. On other platforms, the same view hierarchy might consume the entire display when active. \u4ece\u573a\u666f\u6216\u5b83\u7684\u4e00\u4e2a\u89c6\u56fe\u4e2d\u8bfb\u53d6 scenePhase \u73af\u5883\u503c\uff0c\u4ee5\u68c0\u67e5\u573a\u666f\u662f\u5426\u5904\u4e8e\u6d3b\u52a8\u72b6\u6001\u6216\u5176\u4ed6\u72b6\u6001\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528\u73af\u5883\u5c5e\u6027\u521b\u5efa\u4e00\u4e2a\u5305\u542b\u573a\u666f\u9636\u6bb5\u7684\u5c5e\u6027\uff0c\u5b83\u662fScenePhase\u679a\u4e3e\u4e2d\u7684\u4e00\u4e2a\u503c\u3002 Read the scenePhase environment value from within a scene or one of its views to check whether a scene is active or in some other state. You can create a property that contains the scene phase, which is one of the values in the ScenePhase enumeration, using the Environment attribute: struct MyScene: Scene { @Environment(\\.scenePhase) private var scenePhase // ... } Scene\u534f\u8bae\u63d0\u4f9b\u4e86\u573a\u666f\u4fee\u9970\u7b26\uff0c\u8fd9\u4e9b\u4fee\u9970\u7b26\u88ab\u5b9a\u4e49\u4e3a\u5177\u6709\u9ed8\u8ba4\u5b9e\u73b0\u7684\u534f\u8bae\u65b9\u6cd5\uff0c\u4f60\u53ef\u4ee5\u7528\u5b83\u4eec\u6765\u914d\u7f6e\u573a\u666f\u3002\u4f8b\u5982\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528onChange(of:perform:)\u4fee\u9970\u7b26\u5728\u503c\u6539\u53d8\u65f6\u89e6\u53d1\u4e00\u4e2a\u52a8\u4f5c\u3002\u5f53\u7a97\u53e3\u7ec4\u4e2d\u7684\u6240\u6709\u573a\u666f\u90fd\u79fb\u52a8\u5230\u540e\u53f0\u65f6\uff0c\u4e0b\u9762\u7684\u4ee3\u7801\u4f1a\u6e05\u7a7a\u7f13\u5b58\u3002 The Scene protocol provides scene modifiers, defined as protocol methods with default implementations, that you use to configure a scene. For example, you can use the onChange(of:perform:) modifier to trigger an action when a value changes. The following code empties a cache when all of the scenes in the window group have moved to the background: struct MyScene: Scene { @Environment(\\.scenePhase) private var scenePhase @StateObject private var cache = DataCache() var body: some Scene { WindowGroup { MyRootView() } .onChange(of: scenePhase) { newScenePhase in if newScenePhase == .background { cache.empty() } } } }","title":"App"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/0.%E9%A2%84%E8%A7%88-Previews/","text":"\u9884\u89c8- Previews \u4e3a\u60a8\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\u751f\u6210\u52a8\u6001\u3001\u4ea4\u4e92\u5f0f\u9884\u89c8\u3002 Generate dynamic, interactive previews of your custom views.","title":"0.\u9884\u89c8 Previews"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/0.%E9%A2%84%E8%A7%88-Previews/#-previews","text":"\u4e3a\u60a8\u7684\u81ea\u5b9a\u4e49\u89c6\u56fe\u751f\u6210\u52a8\u6001\u3001\u4ea4\u4e92\u5f0f\u9884\u89c8\u3002 Generate dynamic, interactive previews of your custom views.","title":"\u9884\u89c8- Previews"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/0.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/","text":"\u9884\u89c8\u63d0\u4f9b\u8005-PreviewProvider \u4e00\u4e2a\u5728Xcode\u4e2d\u4ea7\u751f\u89c6\u56fe\u9884\u89c8\u7684\u7c7b\u578b\u3002 A type that produces view previews in Xcode. \u8bf4\u660e-Declaration protocol PreviewProvider : _PreviewProvide \u6982\u8ff0-Overview Xcode\u9759\u6001\u5730\u5728\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\u53d1\u73b0\u7b26\u5408 PreviewProvider \u534f\u8bae\u7684\u7c7b\u578b\uff0c\u5e76\u4e3a\u5b83\u53d1\u73b0\u7684\u6bcf\u4e2a\u63d0\u4f9b\u8005\u751f\u6210\u9884\u89c8\u3002 Xcode statically discovers types that conform to the PreviewProvider protocol in your app, and generates previews for each provider it discovers.","title":"\u9884\u89c8\u63d0\u4f9b\u8005-PreviewProvider"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/0.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/#-previewprovider","text":"\u4e00\u4e2a\u5728Xcode\u4e2d\u4ea7\u751f\u89c6\u56fe\u9884\u89c8\u7684\u7c7b\u578b\u3002 A type that produces view previews in Xcode.","title":"\u9884\u89c8\u63d0\u4f9b\u8005-PreviewProvider"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/0.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/#-declaration","text":"protocol PreviewProvider : _PreviewProvide","title":"\u8bf4\u660e-Declaration"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/0.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/#-overview","text":"Xcode\u9759\u6001\u5730\u5728\u4f60\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\u53d1\u73b0\u7b26\u5408 PreviewProvider \u534f\u8bae\u7684\u7c7b\u578b\uff0c\u5e76\u4e3a\u5b83\u53d1\u73b0\u7684\u6bcf\u4e2a\u63d0\u4f9b\u8005\u751f\u6210\u9884\u89c8\u3002 Xcode statically discovers types that conform to the PreviewProvider protocol in your app, and generates previews for each provider it discovers.","title":"\u6982\u8ff0-Overview"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/1.%E8%AE%BE%E7%BD%AE%E7%B1%BB%E5%9E%8B-SettingTheType/1.Previews/","text":"Associated Type \u9884\u89c8-Previews \u9884\u89c8\u7c7b\u578b \u5fc5\u9700 The type to preview. Required. \u8bf4\u660e-Declaration ```swift associatedtype Previews : View ```","title":"1.Previews"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/1.%E8%AE%BE%E7%BD%AE%E7%B1%BB%E5%9E%8B-SettingTheType/1.Previews/#-previews","text":"\u9884\u89c8\u7c7b\u578b \u5fc5\u9700 The type to preview. Required.","title":"\u9884\u89c8-Previews"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/1.%E8%AE%BE%E7%BD%AE%E7%B1%BB%E5%9E%8B-SettingTheType/1.Previews/#-declaration","text":"```swift associatedtype Previews : View ```","title":"\u8bf4\u660e-Declaration"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/1.platform/","text":"Type Property \u5e73\u53f0-platform \u8fd0\u884c\u63d0\u4f9b\u8005\u7684\u5e73\u53f0\u3002 \u5fc5\u9700 \u63d0\u4f9b\u7684\u9ed8\u8ba4\u6267\u884c\u3002 The platform on which to run the provider. Required. Default implementation provided. \u8bf4\u660e-Declaration static var platform: PreviewPlatform? { get } \u8ba8\u8bba-Discussion \u5982\u679c\u9884\u89c8\u63d0\u4f9b\u8005\u5bf9\u8fd9\u4e2a\u5c5e\u6027\u8fd4\u56de nil \uff0cXcode\u4f1a\u6839\u636e\u5b9a\u4e49\u4e86 PreviewProvider \u7684\u6587\u4ef6\u6765\u63a8\u65ad\u5e73\u53f0\u3002\u53ea\u6709\u5f53\u6587\u4ef6\u5728\u4e00\u4e2a\u652f\u6301\u591a\u4e2a\u5e73\u53f0\u7684\u76ee\u6807\u4e2d\u65f6\uff0c\u624d\u8fd4\u56de nil \u3002 If the preview provider returns nil for this property, Xcode infers the platform based on the file in which the PreviewProvider is defined. Return nil only when the file is in a target that supports multiple platforms. \u9ed8\u8ba4\u5b9e\u73b0-Default Implementations PreviewProvider\u5b9e\u73b0- static var platform: PreviewPlatform? \u8fd0\u884c\u4f9b\u5e94\u5546\u7684\u5e73\u53f0\u3002 The platform on which to run the provider. \u5e73\u53f0- platform \u8fd0\u884c\u63d0\u4f9b\u8005\u7684\u5e73\u53f0\u3002 The platform on which to run the provider. \u8bf4\u660e-Declaration static var platform: PreviewPlatform? { get } \u8ba8\u8bba-Discussion \u5982\u679c\u9884\u89c8\u63d0\u4f9b\u8005\u5bf9\u8fd9\u4e2a\u5c5e\u6027\u8fd4\u56de nil \uff0cXcode\u4f1a\u6839\u636e\u5b9a\u4e49\u4e86 PreviewProvider \u7684\u6587\u4ef6\u6765\u63a8\u65ad\u5e73\u53f0\u3002\u53ea\u6709\u5f53\u6587\u4ef6\u5728\u4e00\u4e2a\u652f\u6301\u591a\u4e2a\u5e73\u53f0\u7684\u76ee\u6807\u4e2d\u65f6\uff0c\u624d\u8fd4\u56de nil \u3002 If the preview provider returns nil for this property, Xcode infers the platform based on the file in which the PreviewProvider is defined. Return nil only when the file is in a target that supports multiple platforms.","title":"1.platform"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/1.platform/#-platform","text":"\u8fd0\u884c\u63d0\u4f9b\u8005\u7684\u5e73\u53f0\u3002 \u5fc5\u9700 \u63d0\u4f9b\u7684\u9ed8\u8ba4\u6267\u884c\u3002 The platform on which to run the provider. Required. Default implementation provided.","title":"\u5e73\u53f0-platform"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/1.platform/#-declaration","text":"static var platform: PreviewPlatform? { get }","title":"\u8bf4\u660e-Declaration"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/1.platform/#-discussion","text":"\u5982\u679c\u9884\u89c8\u63d0\u4f9b\u8005\u5bf9\u8fd9\u4e2a\u5c5e\u6027\u8fd4\u56de nil \uff0cXcode\u4f1a\u6839\u636e\u5b9a\u4e49\u4e86 PreviewProvider \u7684\u6587\u4ef6\u6765\u63a8\u65ad\u5e73\u53f0\u3002\u53ea\u6709\u5f53\u6587\u4ef6\u5728\u4e00\u4e2a\u652f\u6301\u591a\u4e2a\u5e73\u53f0\u7684\u76ee\u6807\u4e2d\u65f6\uff0c\u624d\u8fd4\u56de nil \u3002 If the preview provider returns nil for this property, Xcode infers the platform based on the file in which the PreviewProvider is defined. Return nil only when the file is in a target that supports multiple platforms.","title":"\u8ba8\u8bba-Discussion"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/1.platform/#-default-implementations","text":"PreviewProvider\u5b9e\u73b0- static var platform: PreviewPlatform? \u8fd0\u884c\u4f9b\u5e94\u5546\u7684\u5e73\u53f0\u3002 The platform on which to run the provider.","title":"\u9ed8\u8ba4\u5b9e\u73b0-Default Implementations"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/1.platform/#-platform_1","text":"\u8fd0\u884c\u63d0\u4f9b\u8005\u7684\u5e73\u53f0\u3002 The platform on which to run the provider.","title":"\u5e73\u53f0- platform"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/1.platform/#-declaration_1","text":"static var platform: PreviewPlatform? { get }","title":"\u8bf4\u660e-Declaration"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/1.platform/#-discussion_1","text":"\u5982\u679c\u9884\u89c8\u63d0\u4f9b\u8005\u5bf9\u8fd9\u4e2a\u5c5e\u6027\u8fd4\u56de nil \uff0cXcode\u4f1a\u6839\u636e\u5b9a\u4e49\u4e86 PreviewProvider \u7684\u6587\u4ef6\u6765\u63a8\u65ad\u5e73\u53f0\u3002\u53ea\u6709\u5f53\u6587\u4ef6\u5728\u4e00\u4e2a\u652f\u6301\u591a\u4e2a\u5e73\u53f0\u7684\u76ee\u6807\u4e2d\u65f6\uff0c\u624d\u8fd4\u56de nil \u3002 If the preview provider returns nil for this property, Xcode infers the platform based on the file in which the PreviewProvider is defined. Return nil only when the file is in a target that supports multiple platforms.","title":"\u8ba8\u8bba-Discussion"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/2.previews/","text":"Type Property \u9884\u89c8-previews \u751f\u6210\u4e00\u4e2a\u9884\u89c8\u7684\u96c6\u5408\u3002 \u5fc5\u9700 \u3002 Generates a collection of previews. Required. \u8bf4\u660e-Declaration static var previews: Self.Previews { get } \u8ba8\u8bba-Discussion \u4ee5\u4e0b\u4ee3\u7801\u663e\u793a\u4e86\u5982\u4f55\u521b\u5efa\u4e00\u4e2a\u9884\u89c8\u63d0\u4f9b\u8005\uff0c\u4ee5\u9884\u89c8\u540d\u4e3a \"MyView \"for iPhone X\u7684\u89c6\u56fe\u3002 The following code shows how to create a preview provider that previews a view called MyView for iPhone X: struct MyPreviews : PreviewProvider { static var previews: some View { MyView() .previewDevice(\"iPhone X\") } }","title":"2.previews"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/2.previews/#-previews","text":"\u751f\u6210\u4e00\u4e2a\u9884\u89c8\u7684\u96c6\u5408\u3002 \u5fc5\u9700 \u3002 Generates a collection of previews. Required.","title":"\u9884\u89c8-previews"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/2.previews/#-declaration","text":"static var previews: Self.Previews { get }","title":"\u8bf4\u660e-Declaration"},{"location":"SwiftUI/4.%E5%9C%A8Xcode%E4%B8%AD%E9%A2%84%E8%A7%88-PreviewsInXcode/1.%E9%A2%84%E8%A7%88-Previews/1.%E5%88%9B%E5%BB%BA%E9%A2%84%E8%A7%88-PreviewCreation/1.%E9%A2%84%E8%A7%88%E6%8F%90%E4%BE%9B%E8%80%85-PreviewProvider/2.%E7%94%9F%E6%88%90%E9%A2%84%E8%A7%88%E8%80%85-GeneratingPreviews/2.previews/#-discussion","text":"\u4ee5\u4e0b\u4ee3\u7801\u663e\u793a\u4e86\u5982\u4f55\u521b\u5efa\u4e00\u4e2a\u9884\u89c8\u63d0\u4f9b\u8005\uff0c\u4ee5\u9884\u89c8\u540d\u4e3a \"MyView \"for iPhone X\u7684\u89c6\u56fe\u3002 The following code shows how to create a preview provider that previews a view called MyView for iPhone X: struct MyPreviews : PreviewProvider { static var previews: some View { MyView() .previewDevice(\"iPhone X\") } }","title":"\u8ba8\u8bba-Discussion"}]}